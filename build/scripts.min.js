/* TODO
	prerobiť nech ID nieje iba nazov vrstvy ale aj nejaky prefix
	JShint 4.2.2017
*/
class LayersViewer{
	constructor(arg){
		if(G.isDefined(LayersViewer.instance)){
			alert("Nieje možné vytvoriť viac ako jednu inštanciu LayersViewera!!!!");
			return;
		}
		LayersViewer.instance = this;
		if(typeof arg !== "object"){
			alert("Argument musí byť objekt");
			return;
		}

		if(typeof arg.element === "undefined"){
			alert("arg.element musí byť definovaný");
			return;
		}

		var element 			= arg.element;
		this._defaultName 		= arg.defaultLayertName || "Layer_";
		this._counter 			= 0;
		this._layers 			= {};
		this._activeLayer 		= "";
		this._existingLayers 	= 0;
		this._selectedLayer 	= null;
		this._layersViewer 		= this._createDiv();
		this.visible 			= arg.visible !== false || false;


		element.appendChild(this._layersViewer.first());

		if(typeof Scene !== "undefined" && G.isObject(Scene) && G.isDefined(Scene._layers)){
			each(Scene._layers, e => this.createLayer(e), this);
		}
	}

	set visible(val){
		val ? this._layersViewer.show() : this._layersViewer.hide();
	}

	hover(x, y){return false;}
	clickIn(x, y){return false;}

	static clickOnLayersViewer(e){
		if(typeof draw === "function"){
			draw();
		}
		if(!G(e.target).is(".options")){
			G("#layerContextMenu").delete();
		}
	}
	_createDiv(){
		this._layersBody = G("div", {attr: {id: "layersBody"}});
		return G("div", {
			attr: {id: "layersViewer", onclick:"LayersViewer.clickOnLayersViewer(event)", class: "minimalized"}, 
			cont: [
				G.createElement("div", {id: "layersHeader"}, [
					G.createElement("div", {
						class: "layersHeaderButton", 
						id: "addLayerButton", 
						onclick: "LayersViewer.createAnonymLayer()"
					}, "+"),
					G.createElement("div", {
						class: "layersHeaderButton", 
						id: "removeLayerButton", 
						onclick: "LayersViewer.removeActiveLayer()"
					}, "×"),
					G.createElement("div", {
						class: "layersHeaderButton", 
						id: "toggleLayerButton",
						onclick: "G('#layersViewer').toggleClass('minimalized');"
					}, "-")
	 			]),
	 			this._layersBody.first()
 			]
		});
	}


	static setName(element){
		var input 	= G(element);
		var oldName = input.parent().attr("oldName");
		var newName = input.first().value;
		
		element.onblur = element.onkeydown = null;

		//aj je nový názov prázdny tak vložíme pôvodný názov
		if(newName.length === 0){
			Logger.error("Názov nemôže byť prázdny");
			input.parent().text(oldName);
			return;
		}

		//ak vrstva už existuje tak uporoníme používatela
		if(G.isDefined(LayersViewer.instance._layers[newName])){
			Logger.error("vrstva " + newName + " už existuje")
			input.parent().text(oldName);
			return;
		}

		input.parent().text(newName);

		//ak sa názov nezmenil nič nepremenujeme
		if(oldName === newName){
			return;
		}
		

		if(typeof Scene !== "undefined" && Scene.renameLayer){
			Scene.renameLayer(oldName, newName);
		}
		else{
			alert("Scene nieje definovaná");
		}

		LayersViewer.instance._layers[newName] = LayersViewer.instance._layers[oldName];
		LayersViewer.instance._layers[newName].title = newName;
		delete LayersViewer.instance._layers[oldName];

	}

	static changeName(element){
		var textBox = G(element);
		var text = textBox.text();
		textBox.attr("oldName", text);
		var input = G.createElement("input", {
			class: "tmpLayerInput",
			type: "text",
			onblur:"LayersViewer.setName(this)",
			onkeydown:"if(event.keyCode === 13){LayersViewer.setName(this)}",
			value: text
		});
		textBox.text("").append(input);
		input.focus();
		input.select();
	}

	static changeVisibility(element, e){
		var layer = LayersViewer.instance._layers[G(element).parent().text()];
		if(layer){
			layer.div.find(".visible.true").toggleClass("false");
			layer.layer.visible = !layer.layer.visible;
		}
	}

	static showOptions(element, e){
		var data = {
			"items" : [
				{
					"key" : "lockLayer",
					"type" : "boolean",
					"attr" : "locked",
					"label" : "Zamknuta"
				},
				{
					"key" : "drawPaint",
					"attr" : "drawPaint",
					"type" : "boolean",
					"label" : "Zobraziť malbu"
				},
				{
					"key" : "animatePaint",
					"type" : "button",
					"label" : "Prehrať malbu"
				},
				{
					"key" : "clearPaint",
					"type" : "button",
					"label" : "Vyčistiť malbu"
				},
				{
					"key" : "clearLayer",
					"type" : "button",
					"label" : "Vyčistiť vrstvu"
				}
			]
		};
		var pos = G.position(element);
		var size = G.size(element);
		G("#layerContextMenu").delete();

		var items = [];
		G.each(data.items, (e) => {
			var element = G.createElement("li", {onclick: "LayersViewer.clickOnContext(this, \"" + e.attr + "\")"}, G.createElement("a", {}, e.label));
			if(e.type === "boolean"){
				var classa = "visible";
				if(LayersViewer.instance.activeLayer[e.attr] === false){
					classa += " false";
				}
				element.append(G.createElement("div", {class: classa, attr: e.attr}));
			}
			items.push(element);
		});

		LayersViewer.instance._layersViewer.append(
			G.createElement("nav", {id: "layerContextMenu"}, 
				G.createElement("ul", {}, items), 
			{top: (pos.y + size.height) + "px", right: (window.innerWidth - pos.x - size.width) + "px"})
		);
	}

	static clickOnContext(element, key){
		var el = G(element);
		var childrens = el.children(".visible");
		if(!childrens.isEmpty()){
			LayersViewer.instance.activeLayer[key] = !LayersViewer.instance.activeLayer[key];
			childrens.class("/false");
		}
		else{
			G("#layerContextMenu").delete();
		}
		if(typeof draw === "function"){
			draw();
		}
		//alert("klikol si na " + key);
	}

	static removeActiveLayer(){
		if(LayersViewer.instance._layersViewer.class("minimalized")){
			return;
		}
		if(Scene && Scene.createLayer){
			Scene.deleteLayer(LayersViewer.instance.activeLayerName);
		}
	}

	static createAnonymLayer(){
		if(LayersViewer.instance._layersViewer.class("minimalized")){
			return;
		}
		if(Scene && Scene.createLayer){
			Scene.createLayer(LayersViewer.instance._defaultName + LayersViewer.instance._counter);
		}
	}

	static makeSelected(element){
		var layer = new G(element);
		if(layer.hasClass("selected")){
			return;
		}

		G("#layersViewer .layer").each(function(){
			G(this).removeClass("selected");
		});
		LayersViewer.instance.selectedLayer = layer.text();
		layer.addClass("selected");
	}

	set selectedLayer(val){
		this._selectedLayer = this._layers[val];
		if(!this._selectedLayer){
			alert("nieje označenážiadna vrstva");
		}
	}

	_createLayerDiv(title){
		return G("div", {
			attr: {
				class: "layer",
				id: title,
				onclick: "LayersViewer.makeSelected(this, event)"},
			cont: [
				G.createElement("div", {class: "visible true", onclick: "LayersViewer.changeVisibility(this, event)"}),
				G.createElement("div", {class: "title", ondblclick: "LayersViewer.changeName(this, event)"}, title),
				G.createElement("div", {class: "options", onclick: "LayersViewer.showOptions(this, event)"})
			]
		});
	}
	createLayer(layer){
		this._counter++;
		this._existingLayers++;
		this._layers[layer.title] = {
			layer: layer,
			title: layer.title,
			div: this._createLayerDiv(layer.title)
		};
		this._layersBody.append(this._layers[layer.title].div);

		if(this._existingLayers === 1){
			LayersViewer.makeSelected(this._layers[layer.title].div.first());
		}
	}

	onScreenResize(){
	}

	get activeLayerName(){//DEPTECATED 4.2.2017
		return this.selectedLayer;
	}

	get selectedLayer(){
		return this._selectedLayer.title;
	}

	get activeLayer(){
		//TODO toto si niekde ukladať
		return this._selectedLayer.layer;
	}

	deleteLayer(title){
		if(typeof title != "string" || title.length === 0){
			title = this.activeLayerName;
		}

		var layer = this._layers[title].div;

		//ak sa maže označená vrstva tak sa označí dalšia;
		if(layer.hasClass("selected") && this._existingLayers > 1){
			for(var i in this._layers){
				if(i !== title && this._layers.hasOwnProperty(i)){
					this._layers[i].div.addClass("selected");
					break;
				}
			}
		}
		layer.delete();
		delete this._layers[title];
		this._existingLayers--;
	}
}

"use strict";

function initContextMenu(query){
	//var taskItemClassName = 'task';
	var items = document.querySelectorAll(query);
	//var menuState = 0;
	var menu = document.querySelector("#context-menu");
	document.addEventListener("click", function(e){
		var target = e.target;
		
		do{
			if(target.getAttribute("id") === "context-menu"){
				return;
			}
		}while(target = target.parentElement);
		menu.classList.remove("active");
		menu.classList.remove("left");
	});
	var contextMenuListener = function(el){
		el.addEventListener("contextmenu", function(e) {
			e.preventDefault();
			showMenu(e);
			return false;
		});
	};

	var showMenu = function(e){
		//var contexMenuWidth = 240;
		menu.classList.add("active");
		var contextMenuWidth = menu.querySelector("ul").offsetWidth;
		var contextMenuHeight = menu.querySelector("ul").offsetHeight;

		menu.style.top = Math.min(e.clientY, (window.innerHeight - contextMenuHeight)) + "px";
		menu.style.left = Math.min(e.clientX, (window.innerWidth - contextMenuWidth)) + "px";
		console.log(menu.style.left, window.innerWidth - (contexMenuWidth << 1));
		menu.classList.toggle("left", parseInt(menu.style.left.replace("px", "")) > window.innerWidth - (contexMenuWidth << 1));

	};
	for(var i=0 ; i<items.length; i++){
		contextMenuListener(items[i]);
	}
}



class LogManager {
	constructor(){
		LogManager.LOGS 	= "logs";
		LogManager.WARNS 	= "warns";
		LogManager.ERRORS 	= "errors";

		this._logs = [];
		this._data = {};
		this._show = {};
		
		this._data[LogManager.LOGS]		= {};
		this._data[LogManager.WARNS]	= {};
		this._data[LogManager.ERRORS]	= {};

		this._show[LogManager.LOGS] = this._show[LogManager.WARNS] = this._show[LogManager.ERRORS] = true;
	}

	log(msg, type){
		var source = "unknown";
		try {
			throw new Error();
		}
		catch (e) { 
			source = e.stack.split("\n")[2].trim();
		}
		this._logs.push([Date.now(), msg, type, source]);
	}

	exception(msg, error){
		this.error(msg + ": " + error);
	}

	write(msg){
		Alert.info(msg);
		this._data[LogManager.LOGS][Date.now()] = msg;
		if(this._show[LogManager.LOGS]){
			console.log(msg);
		}
	}

	error(msg, id){
		Alert.danger(msg);
		this._data[LogManager.ERRORS][Date.now()] = msg;
		if(this._show[LogManager.ERRORS]){
			if(id){
				console.error(getErrorMessage(id) + msg);
			}
			else{
				console.error(typeof msg === "number" ? getErrorMessage(msg) : msg);
			}
		}
	}

	warn(msg){
		Alert.warning(msg);
		this._data[LogManager.WARNS][Date.now()] = msg;
		if(this._show[LogManager.WARNS]){
			console.warn(msg);
		}
	}


	showLogs(){
		var div = G("#showLogs");
		if(div.length() > 0){
			div.empty().append(FormManager.createTable(["Time", "Message", "Type", "Source"], this._logs));
			G("#showLogs").show();
    		G("#modalWindow").show();
		}
	}

	get data(){
		return this_data;
	}
}


var getErrorMessage = function(id){
	switch(id){
		case 0 :
			return "Nezadaný parameter";
		case 1 :
			return "Neznáma Input akcia: ";
		case 2 :
			return "Neznáma Object akcia: ";
		case 3 :
			return "Neznáma Paint akcia: ";
		default :
			return "Neznáma chyba";
	}
};
var Alert = {
	_closeParent: function(el){
		el.parentElement.style.opacity = 0;
		setTimeout(() => {
			if(el.parentElement.parentElement !== null){
				el.parentElement.parentElement.removeChild(el.parentElement);
			}
		}, 300);
	},
	success: (text, time = 5000) => Alert._showAlert(text, "success", time),
	warning: (text, time = 5000) => Alert._showAlert(text, "warning", time),
	danger: (text, time = 5000) => Alert._showAlert(text, "danger", time),
	info: (text, time = 5000) => Alert._showAlert(text, "info", time),
	_showAlert: function(text, type, time){
		if(typeof document === "undefined" || typeof  document.body === "undefined"){
			return false;
		}
		var createElement = function(name, params, text){
			var el = document.createElement(name);
			if(typeof params === "object"){
				for(var i in params){
					if(params.hasOwnProperty(i)){
						el.setAttribute(i, params[i]);
					}
				}
			}
			typeof text === "string" && el.appendChild(document.createTextNode(text));
			return el;
		};
		var div = createElement("div",{class: "alert alert-" + type});
		var a = createElement("a", {
			onclick: "Alert.removeEvent(event)",
			class: "close"
		}, "×");

		switch(type){
			case "success":
				type = "success! ";
				break;
			case "info":
				type = "Info! ";
				break;
			case "warning":
				type = "Warning! ";
				break;
			case "danger":
				type = "Danger! ";
				break;
		}

		div.appendChild(createElement(  "strong", {}, type));
		div.appendChild(a);
		if(typeof text === "string"){
			div.appendChild(document.createTextNode(text));
		}
		else{
			div.appendChild(text);
		}
		document.body.appendChild(div);
		setTimeout(() => Alert.removeEvent({target: a}), time);
	},

	removeEvent: function(event){
		Alert._closeParent(event.target);
		return false;
	},
	show: function(){
		Alert._showAlert("warningoš", "warning");
		Alert._showAlert("successoš", "success");
		Alert._showAlert("infoš", "info");
		Alert._showAlert("dangeroš", "danger");
	}
};

if(false){
	/*R*/const SHIFT_KEY	= 16;
	/*R*/const L_CTRL_KEY	= 17;
	/*R*/const L_ALT_KEY	= 18;
	/*R*/const ESCAPE_KEY	= 27;
	/*R*/const ENTER_KEY	= 13;
	/*R*/const Z_KEY		= 90;
	/*R*/const Y_KEY		= 89;
	/*R*/const DELETE_KEY	= 46;
	/*R*/const A_KEY		= 65;
	const KEY_NUM_1			= 49;
	const KEY_NUM_2			= 50;
	const KEY_NUM_3			= 51;
	const KEY_NUM_4			= 52;
	const KEY_NUM_5			= 53;
	const KEY_NUM_6			= 54;
	const KEY_NUM_7			= 55;
	const KEY_NUM_8			= 56;
	const KEY_NUM_9			= 57;

	const FPS = 60;

	const FONT_HALIGN_LEFT		= "left";
	const FONT_HALIGN_CENTER	= "center";
	const FONT_HALIGN_RIGHT		= "right";

	const FONT_VALIGN_MIDDLE	= "middle";
	const FONT_VALIGN_TOP		= "top";
	const FONT_VALIGN_ALPHA		= "alphabetic";
	const FONT_VALIGN_HANG		= "hanging";
	const FONT_VALIGN_IDEO		= "ideographic";
	const FONT_VALIGN_BOTT		= "bottom";


	const FOLDER_IMAGE	= "/img";
	const FOLDER_JSON	= "/js/json";

	const SELECTOR_SIZE			= 10;
	const SELECTOR_COLOR		= "orange";
	const SELECTOR_BORDER_COLOR	= "black";

	const LINE_CAP_BUTT		= "butt";
	const LINE_CAP_ROUND	= "round";
	const LINE_CAP_SQUARE	= "square";

	const LINE_JOIN_MITER	= "miter";
	const LINE_JOIN_ROUND	= "round";
	const LINE_JOIN_BEVEL	= "bevel";


	const OPERATION_DRAW_RECT	= 1000;
	const OPERATION_DRAW_ARC	= 1001;
	const OPERATION_DRAW_PATH	= 1002;
	const OPERATION_DRAW_LINE	= 1003;
	const OPERATION_DRAW_JOIN	= 1004;
	const OPERATION_DRAW_IMAGE	= 1005;
	const OPERATION_RUBBER		= 1006;
	const OPERATION_AREA		= 1007;

	const JOIN_LINEAR		= 2000;
	const JOIN_BAZIER		= 2001;
	const JOIN_SEQUENCAL	= 2002;

	const LINE_STYLE_NORMAL		= 2100;
	const LINE_STYLE_STRIPPED	= 2101;
	const LINE_STYLE_FILLED		= 2102;


	const LIMIT_LAYERS_COUNT = 10;
	/*
	 * NIKINE
	 * #CCC51C
	 * #FFE600
	 * #F05A28
	 * #B6006C
	 * #3A0256
	 *
	 * KIKINE
	 * #B1EB00
	 * #53BBF4
	 * #FF85CB
	 * #FF432E
	 * #FFAC00
	 */


	const DEFAULT_BACKGROUND_COLOR	= "#ffffff";
	/*R*/const DEFAULT_FONT			= "Comic Sans MS";
	const DEFAULT_FONT_SIZE			= 22;
	const DEFAULT_FONT_COLOR		= "#000000";
	const DEFAULT_SHADOW_COLOR		= "#000000";
	const DEFAULT_SHADOW_BLUR		= 20;
	const DEFAULT_SHADOW_OFFSET		= 5;
	/*D*/const DEFAUL_STROKE_COLOR	= "#000000";
	/*D*/const DEFAULT_STROKE_WIDTH	= 2;
	/*D*/const DEFAULT_COLOR		= "#000000";
	const DEFAULT_FILL_COLOR		= "#000000";
	const DEFAULT_RADIUS			= 5;
	const DEFAULT_TEXT_OFFSET		= 5;
	const DEFAULT_FONT_HALIGN		= FONT_HALIGN_LEFT;
	const DEFAULT_FONT_VALIGN		= FONT_VALIGN_TOP;
	/*D*/const DEFAULT_ROUND_VAL			= 10;
	const DEFAULT_BORDER_COLOR		= "#000000";
	const DEFAULT_BORDER_WIDTH		= 2;
	const DEFAULT_LINE_TYPE			= JOIN_LINEAR;
	const DEFAULT_LINE_STYLE		= LINE_STYLE_NORMAL;
	const DEFAULT_BRUSH_SIZE		= 20;
	const DEFAULT_BRUSH_TYPE		= "line";
	const DEFAULT_BRUSH_COLOR		= "#000000";
	const DEFAULT_LAYER_TITLE		= "default";
	const DEFAULT_USER_NAME			= "DEFAULT_NAME";

	const CONTEXT_MENU_LINE_HEIGHT		= 40;
	const CONTEXT_MENU_FONT_COLOR		= DEFAULT_FONT_COLOR;
	const CONTEXT_MENU_OFFSET 			= 10;
	const CONTEXT_MENU_WIDTH 			= 240;
	const CONTEXT_FILL_COLOR			= "#1abc9c";
	const CONTEXT_DISABLED_FILL_COLOR	= "#abd6bb";
	const CONTEXT_SELECTED_FILL_COLOR	= "red";

	const GRID_COLOR	= "Black";
	const GRID_WIDTH	= 0.1;
	const GRID_DIST		= 10;
	const GRID_NTH_BOLD	= 5;

	const TOUCH_DURATION	= 500;
	const TOUCH_VARIATION	= 5;

	const MENU_OFFSET 				= 10;//20
	const MENU_RADIUS				= 10;
	const MENU_BORDER_WIDTH 		= 2;
	const MENU_FONT_COLOR 			= "#000000";
	const MENU_BORDER_COLOR 		= "#000000";
	const MENU_WIDTH 				= 50;//60
	const MENU_HEIGHT				= 50;//60
	const MENU_POSITION				= MENU_OFFSET;
	const MENU_BACKGROUND_COLOR		= "#1abc9c";
	const MENU_DISABLED_BG_COLOR	= "#abd6bb";

	const TABLE_BORDER_WIDTH	= 1;
	const TABLE_HEADER_COLOR	= "#53cfff";
	const TABLE_BODY_COLOR		= "#5bf2ff";
	const TABLE_LINE_HEIGHT		= 40;
	const TABLE_BORDER_COLOR	= "#000000";
	const TABLE_WIDTH 			= 300;
	const TABLE_RADIUS			= 10;
	const TABLE_TEXT_OFFSET		= 5;

	const TIMELINE_HEIGHT				= 60;
	const TIMELINE_SLIDER_HEIGHT		= 5;
	const TIMELINE_SLIDER_COLOR			= "purple";
	const TIMELINE_SLIDER_OFFSET		= 30;
	const TIMELINE_BUTTON_SIZE			= 20;
	const TIMELINE_BUTTON_COLOR			= "HotPink";
	const TIMELINE_BUTTON_BORDER_COLOR	= "IndianRed";

	const ACCESS_PUBLIC		= "+";
	const ACCESS_PRIVATE	= "-";
	const ACCESS_PROTECTED	= "#";

	const ACTION_OBJECT_MOVE 		= 2310;
	const ACTION_OBJECT_CREATE		= 2311;
	const ACTION_OBJECT_CHANGE		= 2312;
	const ACTION_OBJECT_DELETE		= 2313;
	const ACTION_PAINT_CLEAN		= 2314;
	const ACTION_PAINT_ADD_POINT	= 2315;
	const ACTION_PAINT_BREAK_LINE	= 2316;
	const ACTION_PAINT_CHANGE_BRUSH	= 2317;
	const ACTION_LAYER_CREATE 		= 2318;
	const ACTION_LAYER_DELETE 		= 2319;
	const ACTION_LAYER_CLEAN 		= 2320;
	const ACTION_LAYER_VISIBLE 		= 2321;
	const ACTION_LAYER_RENAME 		= 2322;

	const PAINT_ACTION_BRUSH	= 2400;
	const PAINT_ACTION_LINE		= 2401;
	/*
		compatible: 14.9.2016
	*/
	const KEYWORD_OBJECT		= "object";
	const KEYWORD_STRING		= "string";
	const KEYWORD_NUMBER		= "number";
	const KEYWORD_BOOLEAN		= "boolean";
	const KEYWORD_FUNCTION		= "function";
	const KEYWORD_UNDEFINED		= "undefined";
	const KEYWORD_TRANSPARENT	= "transparent";
	/*R*/const PI2 = Math.PI * 2;

	/*R*/const IMAGE_FORMAT_JPG	= "image/jpeg";
	/*R*/const IMAGE_FORMAT_PNG	= "image/png";
	/*R*/const IMAGE_FORMAT_GIF	= "image/gif";
	const FORMAT_FILE_XML		= "text/xml";

	const ATTRIBUTE_FILL_COLOR		= "fillColor";
	const ATTRIBUTE_BORDER_COLOR	= "borderColor";
	const ATTRIBUTE_BORDER_WIDTH	= "borderWidth";
	const ATTRIBUTE_LINE_WIDTH		= "lineWidth";
	const ATTRIBUTE_FONT_SIZE		= "fontSize";
	const ATTRIBUTE_FONT_COLOR		= "fontColor";
	const ATTRIBUTE_LINE_TYPE		= "lineType";
	const ATTRIBUTE_LINE_STYLE		= "lineStyle";
	const ATTRIBUTE_BRUSH_SIZE		= "brushSize";
	const ATTRIBUTE_BRUSH_TYPE		= "brushType";
	const ATTRIBUTE_BRUSH_COLOR		= "brushColor";
	const ATTRIBUTE_RADIUS			= "radius";

	const INPUT_TYPE_CHECKBOX	= "checkbox";
	const INPUT_TYPE_RADIO		= "radio";

	const CHECKBOX_COLOR_TRUE	= "green";
	const CHECKBOX_COLOR_FALSE	= "red";

	const LAYERS_LINE_HEIGHT	= 50;
	const LAYERS_PANEL_WIDTH	= 180;
	const LAYERS_PANEL_OFFSET	= 40;
	const LAYERS_FONT_SIZE		= 20;
	const LAYERS_CHECKBOX_SIZE	= 30;
	const LAYERS_BUTTON_SIZE	= 40;

	const HIGHTLIGHT_CORRECT	= 2700;
	const HIGHTLIGHT_WRONG		= 2701;

	const LAYER_USER	= 2710;
	const LAYER_GUI		= 2711;
	const LAYER_TASK	= 2712;


	const STATUS_CONNECTED		= 2720;
	const STATUS_DISCONNECTED	= 2721;

	const OBJECT_ARC		= "Arc";
	const OBJECT_ARROW		= "Arrow";
	const OBJECT_CLASS		= "Class";
	const OBJECT_CONNECTOR	= "Connector";
	const OBJECT_IMAGE		= "Image";
	const OBJECT_JOIN		= "Join";
	const OBJECT_LINE		= "Line";
	const OBJECT_PAINT		= "Paint";
	const OBJECT_POLYGON	= "Polygon";
	const OBJECT_RECT		= "Rect";
	const OBJECT_TABLE		= "Table";
	const OBJECT_INPUT		= "Input";
	const OBJECT_TEXT		= "Text";
	const OBJECT_GRAPH		= "Graph";
	const OBJECT_RUBBER		= "Rubber";
	const OBJECT_AREA		= "Area";

	const CURSOR_POINTER	= "pointer";
	const CURSOR_DEFAULT	= "default";
	const CURSOR_NOT_ALLOWED	= "not-allowed";

	const OPTION_CHANGE_CURSOR		= true;
	const OPTION_MOVING_SILHOUETTE	= false;
	const OPTION_SHOW_SHADOWS		= true;
	const OPTION_CANVAS_BLUR		= false;
	const OPTION_SHOW_LAYERS_VIEWER	= true;
	const OPTION_SHOW_GRID			= true;

	const LINE_NONE				= 2210;
	const LINE_ARROW_CLASSIC	= 2211;
	const LINE_ARROW_CLOSED		= 2212;
	const LINE_ARROW_FILLED		= 2213;
	const LINE_DIAMOND_CLASSIC	= 2214;
	const LINE_DIAMOND_FILLED	= 2215;

	const ACTION_MOUSE_MOVE			= 2318;
	const ACTION_MOUSE_DOWN			= 2319;
	const ACTION_MOUSE_UP			= 2320;
	const ACTION_KEY_DOWN			= 2321;
	const ACTION_KEY_UP				= 2322;
	const ACTION_PAINT_ADD_PATH		= 2323;
	const ACTION_PAINT_REMOVE_PATH	= 2324;
	
	const LOGGER_MENU_CLICK			= 2600;
	const LOGGER_CREATOR_CHANGE		= 2601;
	const LOGGER_CONTEXT_CLICK		= 2602;
	const LOGGER_OBJECT_CREATED		= 2604;
	const LOGGER_OBJECT_ADDED		= 2605;
	const LOGGER_OBJECT_CLEANED		= 2609;
	const LOGGER_COMPONENT_CREATE	= 2606;
	const LOGGER_PAINT_HISTORY		= 2607;
	const LOGGER_PAINT_ACTION		= 2608;
	const LOGGER_MOUSE_EVENT		= 2610;
	const LOGGER_KEY_EVENT			= 2611;
	const LOGGER_DRAW				= 2612;		
	const LOGGER_CHANGE_OPTION		= 2613;	
	const LOGGER_LAYER_CHANGE		= 2603;
	const LOGGER_LAYER_CLEANED		= 2614;
	const LOGGER_LAYER_RENAMED		= 2615;
	const LOGGER_LAYER_RASTERED		= 2616;
	const LOGGER_STACK_RECIEVED		= 2617;
}

const CUT_OFF_AFTER_DISTANCE	= 100;
const CUT_OFF_PATHS_AFTER		= false;
const CUT_OFF_PATHS_BEFORE		= false;
const CUT_OFF_BEFORE_DISTANCE	= 100;

/*R*/const LEFT_BUTTON	= 0;
/*R*/const RIGHT_BUTTON	= 2;

const FONT_ALIGN_CENTER = 10;
const FONT_ALIGN_NORMAL = 11;

const COMPONENT_DRAW	= "a";
const COMPONENT_SHARE	= "b";
/*D*/const COMPONENT_WATCH	= "c";
const COMPONENT_TOOLS	= "d";
const COMPONENT_LOAD	= "e";
const COMPONENT_SCREEN	= "f";
const COMPONENT_CONTENT	= "g";
const COMPONENT_EDIT	= "h";
const COMPONENT_SAVE	= "i";
const COMPONENT_LAYERS	= "j";
const COMPONENT_TASK	= "k";


const MSG_DIVIDER = "########";

const MSG_CONN_RECONNECT				= "Spojenie zo serverom bolo uspešne znovunadviazané";
const MSG_CONN_CONFIRM					= "Spojenie bolo úspešne nadviazané";
const MSG_CONN_FAILED					= "Nepodarilo sa nadviazať spojenie zo serverom";
const MSG_CONN_ERROR					= "Spojenie zo serverom bolo prerušené";
const MSG_CONN_DISCONNECT				= "Spojenie zo serverom bolo úspešne ukončené";
const MSG_USER_CONNECT					= "Používatel " + MSG_DIVIDER + "[" + MSG_DIVIDER + "] sa pripojil";
const MSG_ANNONYM_FAILED				= "Nepodarilo sa odoslať anonymné dáta o prehliadači";
const MSG_MISS_LESS_ID					= "Nieje zadané 'less_id'";
const MSG_UNKNOW_ACTION					= "Neznáma akcia: " + MSG_DIVIDER;
const MSG_RECIEVED_UNKNOWN_ACTION		= "Bola prijatá neznáma akcia: " + MSG_DIVIDER;
const MSG_TRY_DRAW_EMPTY_POLYGON		= "Chce sa vykresliť Polygon bez pointov";
const MSG_TRY_DRAW_EMPTY_LINE			= "Chce sa vykresliť Line bez pointov";
const MSG_TRY_DRAW_ONE_POINT_LINE		= "Chce sa vykresliť Line z jedným bodom";
const MSG_LOAD_OLD_PROJECT				= "Našiel sa rozpracovaný projekt, prajete si ho obnoviť???";
const MSG_TRY_DRAW_WITHOUT_POSITION		= "Chce sa vykresliť " + MSG_DIVIDER + " bez pozície";
const MSG_TRY_DRAW_WITHOUT_SIZE			= "Chce sa vykresliť " + MSG_DIVIDER + " bez veľkosti";
const MSG_TRY_DRAW_WITH_NEG_POSITION	= "Chce sa vykresliť " + MSG_DIVIDER + " zo zápornou velkosťou";
const MSG_RECREATE_LAYER 				= "Ide sa vytvoriť vrstva ktorá už existuje: " + MSG_DIVIDER;
const MSG_MAXIMUM_LAYER					= "Bolo vytvorené maximálne množstvo vrstiev(" + MSG_DIVIDER + ")";
const MSG_INIT_MENU_ERROR				= "Nepodarila sa inicializacia Top menu";
const MSG_INIT_CREATOR_ERROR			= "Nepodarila sa inicializacia Creatora";
const MSG_LOADING_ERROR					= "Nepodaril sa loading";
const MSG_TASK_EXIST					= "Načítava sa Task keď už jeden existuje";
const MSG_TASK_CREATED 					= "Task " + MSG_DIVIDER + " bol úspešne vytvorený";
const MSG_WRONG_ATTRIBUTE				= "K objektu " + MSG_DIVIDER + " sa snaží priradiť neplatný atribút: " + MSG_DIVIDER;
const MSG_UNKNOWN_OBJECT_NAME			= "Snažíš sa vložiť objekt s neznámym menom: " + MSG_DIVIDER;
const MSG_OBJECT_SUCCESSFULLY_CREATED	= "Objekt " + MSG_DIVIDER + " bol úspešne vytvorený";
const MSG_TRY_DRAW_WRONG_JOIN			= "Ide sa kresliť join ktorý nemá potrebné udaje";
const MSG_LINE_WITH_TOO_LESS_POINTS		= "Vytvoril sa line ktory mal menej ako 2 body a tak sa maže";
const MSG_POLYGON_WITH_TOO_LESS_POINTS	= "Vytvoril sa polygon ktory mal menej ako 3 body a tak sa maže";
const MSG_TRY_REMOVE_TABLE_HEAD			= "Nemožeš vymazať hlavičku tabulky";
const MSG_FILE_SAVE_ERROR				= "Chyba pri ukladaní súboru: " + MSG_DIVIDER;
const MSG_MIN_SCREEN_WIDTH				= "Minimálna šírka obrazovky je " + MSG_DIVIDER + "px";
const MSG_BEFORE_ONLOAD_TEXT			= "Nazoaj chceš odísť s tejto stránky???!!!";
const MSG_UNKNOWN_LAYES_BUTTON 			= "Neznáme tlačítko v layerManagerovy";
const MSG_OPTION_CHANGE					= "Nastavila sa možnosť " + MSG_DIVIDER + " na hodnotu " + MSG_DIVIDER;
const MSG_TRY_DELETE_ABSENT_LAYER 		= "Ide sa vymazať vrstva ktorá neexistuje: " + MSG_DIVIDER;
const MSG_TRY_DELETE_GUI_LAYER			= "Nemože sa zmazať gui vrstva";
const MSG_ADD_OBJECT_TO_ABSENT_LAYER 	= "Ide sa vložiť objekt do  neexistujúcej vrstvy: " + MSG_DIVIDER;
const MSG_MISSING_RESULT_TEXT		 	= "Nieje zadaný žiadny text pre výsledok";
const MSG_USER_DISCONNECT				= "Používatel " + MSG_DIVIDER + "[ " + MSG_DIVIDER + "] sa odpojil";
const MSG_CREATE_PROJECT_ERROR			= "Nastala chyba pri vytváraní projectu";
const MSG_OBJECT_CREATED 				= "Bol vytvorený objekt " + MSG_DIVIDER;
const MSG_OBJECT_CLEANED 				= "Bol vyčistený objekt " + MSG_DIVIDER;

function getMessage(text){
	if(!arguments.length){
		return text;
	}


	for(var i=1 ; i<arguments.length ; i++){
		text = text.replace(MSG_DIVIDER, arguments[i]);
	}

	return text;
}

/**
 * Created by gabriel on 30.12.2016.
 * JShint 4.2.2017
 */

class Analyzer{
	constructor(url){
		this._url = url;
		this._browserData = this._analyzeWindow(this._analyzeBrowser());
		
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	get browserData(){
		return this._browserData;
	}
	get isMobile(){
		return this._browserData.mobile !== 0;
	}

	sendData(){
		this._sendAnonymousData(this._browserData);
	}

	_sendAnonymousData(data = {}){
		var sendData = c =>	$.post(this._url, {
			content: JSON.stringify(c)
		}).fail(() => Logger.error(getMessage(MSG_ANNONYM_FAILED)));

		if(navigator.geolocation){
			navigator.geolocation.watchPosition(position => {
					navigator.geolocation.getCurrentPosition(a => {
						data.accuracy = a.coords && a.coords.accuracy  || "unknown";
						data.position = {
							lat : a.coords.latitude,
							lon : a.coords.longitude
						};
						sendData(data);
					});
				},
				function (error) {
					if (error.code == error.PERMISSION_DENIED){
						sendData(data);
					}
				});
			return;
		}
		
		sendData(data);
	}

	_analyzeWindow(data){
		data.userAgent		= navigator.userAgent;
		data.language		= navigator.language;
		data.platform		= navigator.platform;
		data.vendor			= navigator.vendor;
		data.innerHeight	= window.innerHeight;
		data.innerWidth		= window.innerWidth;
		data.availHeight	= screen.availHeight;
		data.availWidth		= screen.availWidth;
		data.connectedAt	= getFormattedDate();
		return data;
	}

	_analyzeBrowser(){
		/*
		 *	browser:
		 *		ed = Microsoft Edge
		 *		ie9 = Explorer 9
		 *		ie10 = Explorer 10
		 *		ie11 = Explorer 11
		 *		ie? = Explorer 8 and below
		 *		ff = Firefox
		 *		gc = Google Chrome
		 *		sa = Safari
		 *		op = Opera
		 *	mobile - including tablets:
		 *		0 = Not a mobile or tablet device
		 *		w = Windows Phone (Nokia Lumia)
		 *		i = iOS (iPhone iPad)
		 *		a = Android
		 *		b = Blackberry
		 *		s = Undetected mobile device running Safari
		 *		1 = Undetected mobile device
		 */
		var e = navigator.userAgent;
		return {
			browser: /Edge\/\d+/.test(e) ? 'ed' : /MSIE 9/.test(e) ? 'ie9' : /MSIE 10/.test(e) ? 'ie10' : /MSIE 11/.test(e) ? 'ie11' : /MSIE\s\d/.test(e) ? 'ie?' : /rv\:11/.test(e) ? 'ie11' : /Firefox\W\d/.test(e) ? 'ff' : /Chrom(e|ium)\W\d|CriOS\W\d/.test(e) ? 'gc' : /\bSafari\W\d/.test(e) ? 'sa' : /\bOpera\W\d/.test(e) ? 'op' : /\bOPR\W\d/i.test(e) ? 'op' : typeof MSPointerEvent !== 'undefined' ? 'ie?' : '',
			os: /Windows NT 10/.test(e) ? "win10" : /Windows NT 6\.0/.test(e) ? "winvista" : /Windows NT 6\.1/.test(e) ? "win7" : /Windows NT 6\.\d/.test(e) ? "win8" : /Windows NT 5\.1/.test(e) ? "winxp" : /Windows NT [1-5]\./.test(e) ? "winnt" : /Mac/.test(e) ? "mac" : /Linux/.test(e) ? "linux" : /X11/.test(e) ? "nix" : "",
			mobile: /IEMobile|Windows Phone|Lumia/i.test(e) ? 'w' : /iPhone|iP[oa]d/.test(e) ? 'i' : /Android/.test(e) ? 'a' : /BlackBerry|PlayBook|BB10/.test(e) ? 'b' : /Mobile Safari/.test(e) ? 's' : /webOS|Mobile|Tablet|Opera Mini|\bCrMo\/|Opera Mobi/i.test(e) ? 1 : 0,
			tablet: /Tablet|iPad/i.test(e),
			touch: 'ontouchstart' in document.documentElement
		};
	}
}
/*
	compatible:  14.9.2016
*/
class objectCreator{
	constructor(){
		this._object 		= false;
		this._fillColor 	= DEFAULT_FILL_COLOR;
		this._borderColor 	= DEFAULT_BORDER_COLOR;
		this._borderWidth 	= DEFAULT_BORDER_WIDTH;
		this._operation 	= OPERATION_DRAW_PATH;//OPERATION_DRAW_RECT;
		this._lineWidth 	= DEFAULT_BORDER_WIDTH;
		this._fontSize		= DEFAULT_FONT_SIZE;
		this._fontColor		= DEFAULT_FONT_COLOR;
		this._lineType		= DEFAULT_LINE_TYPE;
		this._lineStyle		= DEFAULT_LINE_STYLE;
		this._brushSize		= DEFAULT_BRUSH_SIZE;
		this._brushType		= DEFAULT_BRUSH_TYPE;
		this._brushColor	= DEFAULT_BRUSH_COLOR;
		this._radius		= DEFAULT_RADIUS;
		this._items 		= null;
		this._controllPress	= false;
		this._allLayers		= false;
		this._view			= null;
		this._lastOperation = this._operation;
		this._visibleView	= true;
		this._allowedItems 	= ["_fillColor", "_borderColor", "_borderWidth", "_operation", 
							   "_lineWidth", "_fontSize", "_fontColor", "_lineType", "_lineStyle", 
							   "_brushSize", "_brushType", "_brushColor", "_radius"];
		
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	onMouseMove(pos, movX, movY){
		updateSelectedObjectView(this._object);
		if(isFunction(this._object.updateCreatingPosition)){
			this._object.updateCreatingPosition(pos);
		}
	}

	get view(){
		return this._view;
	}

	get controllPress(){
		return this._controllPress;
	}

	get allLAyers(){
		return this._allLayers;
	}

	set visibleView(val){this._visibleView = val;}
	/**
	 * Nastaví view pre creator
	 *
	 * @param val - view ktorý sa má priradiť
	 */
	set view(val){
		this._view = val;

		if(this._items !== null){
			this.init();
		}
	}


	/**
	 * Načíta dáta pre CreatorView
	 *
	 * @param data - objekt ktorý vznikol s parsovaním načítaneho súboru s dátami pre CreatorView
	 */
	init(data = false){
		if(this._items === null && data !== false){
			this._items = data;
		}

		if(this._view !== null){
			this._view.init();
		}
	}


	/**
	 * Vytvorí dočasný objekt ktorý sa má vytvoriť a uloží sa do Creatora
	 *
	 * @param position - pozícia kde sa má objaviť objekt
	 */
	createObject(position, target = null){
		switch(this._operation){
			case OPERATION_DRAW_RECT:
				this._object = new Rect(position, new GVector2f(), this._fillColor);
				break;
			case OPERATION_DRAW_ARC:
				this._object = new Arc(position, new GVector2f(), this._fillColor);
				break;
			case OPERATION_DRAW_LINE:
				this._object = new Line([position, position.getClone()], 
										this._lineWidth, 
										this._fillColor, 
										target);
				break;
			case OPERATION_DRAW_JOIN:
				this._object = new Join(position);
				break;
			case OPERATION_DRAW_IMAGE:
				this._object = new ImageObject(position, new GVector2f());
				break;
		}
		selectedObjects.clearAndAdd(this._object);//TODO toto nesposobuje to rýchle pohybocanie objektt???
	}


	/**
	 * Dokončí vytváranie objektu
	 */
	finishCreating(){
		if(this._object.name === OBJECT_IMAGE){
			loadImage(e => {
				this._object.image = e;
				Scene.addToScene(this._object);
				this._object = false;
			});
		}
		else{
			Scene.addToScene(this._object);
			this._object = false;
		}
	}

	toggleArea(){
		if(this._operation !== OPERATION_AREA){
			if(this._operation !== OPERATION_RUBBER){
				this._lastOperation = this._operation;
			}
			this.operation = OPERATION_AREA;
		}
		else{
			this.operation = this._lastOperation;
		}
	}

	/**
	 * Prepne medzy vymazávaním a pôvodným nástrojom
	 */
	toggleRubber(){
		if(this._operation !== OPERATION_RUBBER){
			if(this._operation !== OPERATION_AREA){
				this._lastOperation = this._operation;
			}
			this.operation = OPERATION_RUBBER;
		}
		else{
			this.operation = this._lastOperation;
		}
	}


	/**
	 * Načíta všetky dáta potrebné pre creator s jedného objektu
	 *
	 * @param content
	 */
	fromObject(content){
		each(content, function(e, i){
			if(isIn(i, this._allowedItems)){
				this.setOpt(i, e);
			}
		}, this);
	}


	/**
	 * Uloží Creator to jedného objektu
	 */
	toObject(){
		var result = {};
		each(this, (e, i) => result[i] = e);
		return result;
	}


	/**
	 * Nakreslí akuálne vytváraný objekt a takisto aj view ak existuje
	 */
	draw(){
		if(this._object){
			this._object.draw();
		}

		if(this._view !== null && this._items !== null && this._visibleView){
			this._view.draw();
		}

	}

	/**
	 * Vytvorý objekt bud s objektu alebo s JSON stringu a vloží ho do scény
	 *
	 * @param obj - objekt alebo JSON string s dátami potrebnými pre vytvorenie objektu
	 * @returns {obj} - vráci novo vytvorený objekt alebo NULL ak sa vytvorenie nepodarí
	 */
	create(obj){
		var result = Entity.create(obj, false);
		if(result){
			//console.log("pridava sa nový objekt do vrstvy ", result.layer, result, obj);
			Scene.addToScene(result, result.layer, false);
			draw();
		}
		return result;
	}


	/**
	 * Nastavý vlastnosť creatora na určitú hodnotu
	 *
	 * @param key
	 * @param val
	 */
	setOpt(key, val){
		if(isObject(key)){
			each(key, (e, i) => this.setOpt(i, e));
			return;
		}
		if(key[0] != "_"){
			key = "_" + key;
		}


		//console.log("key: ", key, " vaĺ: ", val, "normal: ", this[key]);

		if(this[key] == val){
			return false;
		}

		var redrawPaint = isIn(key, "_brushColor", "_brushSize", "_brushType") && this[key] != val;

		this[key] = val;


		if(key === "_brushType"){
			if(val === "line"){
				Paints.action = PAINT_ACTION_LINE;
			}
			else if(val === "fur"){
				Paints.action = PAINT_ACTION_FUR;
			}
			else{
				Paints.selectedImage = val;
				Paints.action = PAINT_ACTION_BRUSH;
			}
		}

		Events.creatorChange(key, val);

		/*
		 * Ak sa zmení vlastnosť štetca musí prekresliť štetec aby sa mohlo rovno malovať
		 */
		redrawPaint && Paints.rePaintImage(this.brushSize, this.brushColor);

		if(isDefined(this._view)){
			/*
			 * Ak s zmení nejaká farba musí sa prekresliť aj view zobtrazujúci aktuálnu farbu
			 */
			if(isIn(key, "_fillColor", "_borderColor", "_fontColor", "_color", "_brushColor")){
				this._view.init();
			}
			/*
			 * tak isto to platí aj pre typ štetca
			 */
			else if(isIn(key, "_brushSize", "_brushType")){
				this._view.init();
			}

		}

	}

	/**
	 * Zistí či bolo kliknuté na CreatorViewer alebo nie
	 *
	 * @param x
	 * @param y
	 * @returns {*} - vráti TRUE alebo FALSE
	 */
	clickIn(x, y, doAct = true){
		return isDefined(this._view) && this._visibleView ? this._view.clickIn(x, y, doAct) : false;
	}

	get items(){return this._items;}
	get object(){return this._object;}

	get radius(){return this._radius;}
	get color(){return this._fillColor;}
	get lineType(){return this._lineType;}
	get fontSize(){return this._fontSize;}
	get fillColor(){return this._fillColor;}
	get fontColor(){return this._fontColor;}
	get operation(){return this._operation;}
	get lineWidth(){return this._lineWidth;}
	get lineStyle(){return this._lineStyle;}
	get brushSize(){return this._brushSize;}
	get brushType(){return this._brushType;}
	get brushColor(){return this._brushColor;}
	get borderColor(){return this._borderColor;}
	get borderWidth(){return this._borderWidth;}

	set object(val){this._object = val;}
	set operation(val){this._operation = val; this._view.changeOperation();}
}
/*
	compatible: canvas, getElementByClassName, JSON parsing 14.9.2016
*/

//SHOWERS

var showPanel = function(id){
	G("#" + id).show();
	G("#modalWindow").show();
	G("canvas").addClass("blur");
}

var showOptions 			= () => showPanel("optionsForm");
var showColors				= () => showPanel("colorPalete");
var showWatcherOptions		= () => showPanel("watchForm");
var showSharingOptions		= () => showPanel("shareForm");
var showXmlSavingOptions	= () => {
	G("#idProjectTitle").val(Project.title);
	showPanel("saveXmlForm");
};

function showSavingOptions(){
	G("#idImageWidth").val(canvas.width);
	G("#idImageHeight").val(canvas.height);
	var div, el1, el2, counter = 0, parent = G("#layersSavionOptions").empty();
	each(Scene.layers, a => {
		el1 = new G("input", {attr : {
				type : "checkbox",
				class : "layerVisibility",
				id : "layer" + counter,
				checked : true,
				name: a.title
		}});

		el2 = new G("label", {
			attr : {for: "layer" + counter++},
			cont : a.title
		});
		
		parent.append(new G("div", {cont: [el1, el2]}));
	});

	G("#saveForm").show();
	G("#modalWindow").show();
	G("canvas").addClass("blur");
}

//SERIALIZATORS

function serializeSaveData(){
	var getValueIfExist = (e, val = false) => e ? (e.type == "checkbox" ? e.checked : e.value) : val;
	var result = [];
	result.width		= getValueIfExist(G.byId("idImageWidth"), canvas.width);
	result.height		= getValueIfExist(G.byId("idImageHeight"), canvas.height);
	result.name			= getValueIfExist(G.byId("idImageName"));
	result.background	= getValueIfExist(G.byId("idBackground"), KEYWORD_TRANSPARENT);

	result.format = 	G.byId("idImageFormat");
	result.format =		result.format.options &&
						result.format.selectedIndex &&
						result.format.options[result.format.selectedIndex] &&
						result.format.options[result.format.selectedIndex].value;

	var layerCheckboxes = G.byClass("layerVisibility");
	result.selectedLayers = [];
	//musí byť tento for ináč to dá viackrát to isté
	for(var i=0 ; i < layerCheckboxes.length ; i++){
		layerCheckboxes[i].checked && result.selectedLayers.push(layerCheckboxes[i].name);
	}

	processImageData(result);
}

function serializeShareData(){
	var getValueIfExists = e => e ? (e.type == "checkbox" ? e.checked : e.value) : false;
	var result = {};
	//NEW
	result.user_name	= getValueIfExists(G.byId("idUserName"));
	result.type			= getValueIfExists(G.byId("idType"));
	result.limit		= getValueIfExists(G.byId("idMaxWatchers"));
	//BOTH
	result.password		= getValueIfExists(G.byId("idSharingPassword"));

	result.shareMenu	= getValueIfExists(G.byId("idShareMenu"));
	result.sharePaints	= getValueIfExists(G.byId("idSharePaints"));
	result.shareObjects	= getValueIfExists(G.byId("idShareObjects"));
	result.shareCreator	= getValueIfExists(G.byId("idShareCreator"));
	result.shareLayers	= getValueIfExists(G.byId("idShareLayers"));
	result.shareTitle	= getValueIfExists(G.byId("idShareTitle"));

	
	//OLD
	/*
	result.realTime = getValueIfExists(G.byId("idRealtimeSharing"));
	result.maxWatchers = getValueIfExists(G.byId("idMaxWatchers"));
	result.detailMovement = getValueIfExists(G.byId("idDetailMovement"));

	result.publicShare = getValueIfExists(G.byId("idPublicShare"));
	*/

	$.post("/checkConnectionData", {content: JSON.stringify(result)}, function(response){
		if(response.result > 0){
			closeDialog();
			Project.connection.connect(result);
		}
		else{
			Logger.error(response.msg)
		}
	}, "JSON");

	//Sharer.startShare(result);
}

function serializeWatcherData(){
	var getValueIfExists = e => e ? (e.type == "checkbox" ? e.checked : e.value) : false;
	var result = {};
	//NEW
	result.user_name		= getValueIfExists(G.byId("idWatchUserName"));
	result.less_id			= getValueIfExists(G.byId("idLessonId"));
	//BOTH
	result.password			= getValueIfExists(G.byId("idWatchSharingPassword"));
	//OLD
	result.nickName			= getValueIfExists(G.byId("idNickName"));
	result.password			= getValueIfExists(G.byId("idSharingPassword"));
	result.timeLine			= getValueIfExists(G.byId("idShowTimeLine"));
	result.changeResolution	= getValueIfExists(G.byId("idChangeResolution"));
	result.showChat			= getValueIfExists(G.byId("idShowChat"));
	result.shareId			= getValueIfExists(G.byId("idShareId"));

	//result = processValues({}, "idNickName", "idSharingPassword", "idShowTimeLine", "idChangeResolution", "idShowChat", "idShareId")
	processWatchData(result);
	//Watcher = new WatcherManager(result);
}

function serializeSaveXmlData(){
	var processValues = (result, el, ...args) => {
		var process = item => {if(item) result[item.name] = item.type == "checkbox" ? item.checked : item.value};
		process(G.byId(el));
		each(args, e => process(G.byId(e)));
		return result;
	};
	saveSceneAsFile(processValues({}, "idProjectTitle", "idSaveCreator", "idSavePaint", "idSaveTask", "idTaskHint", "idTaskTimeLimit", "idSaveHistory", "idStoreStatistics"));
}

//PROCESSORS

function processWatchData(data){
	var checkData = {
		shareId: data.shareId,
		nickName: data.nickName,
		password: data.password
	};
	var form = G.createElement("form"), createInput = (name, value) => {
			return createElement({name: "input", attr: {value: value, name: name}});
	};
	data.innerWidth = window.innerWidth;
	data.innerHeight = window.innerHeight;
	data.type = "watch";
	$.post("/checkConnectionData", {content: JSON.stringify(data)}, function(response){
		if(response.result > 0){
			closeDialog();
			data.type = response.type;
			if(data.type === "exercise"){ //pri exercise chceme aby to čo sa má zdielať nastavoval zakladatel
				data.sharePaints	= response.sharePaints;
				data.shareInput		= response.shareInput;
				data.shareCreator	= response.shareCreator;
				data.shareLayers	= response.shareLayers;
				data.shareObjects	= response.shareObjects;
			}
			Project.connection.connect(data);
		}
		else{
			Logger.error(Alert.danger(response.msg));
		}
	}, "JSON");
}

function processImageData(data){
	data.name			= isString(data.name)	|| "desktopScreen";
	data.format			= isString(data.format)	|| IMAGE_FORMAT_PNG;
	data.width			= data.width			|| canvas.width;
	data.height			= data.height			|| canvas.height;
	data.selectedLayers	= data.selectedLayers	|| [];


	/*
	 * velký canvas kde sa všetko nakreslí
	 */
	var ca = G("canvas", {attr: {width: canvas.width, height: canvas.height}}).first();
	var resContext = ca.getContext("2d");

	/*
	 * prekreslí pozadie ak je nastavene a nieje priesvitné
	 */
	if(isString(data.background) && data.background !== KEYWORD_TRANSPARENT){
		doRect({
			x: 0,
			y: 0,
			width: ca.width,
			height: ca.height,
			fillColor: data.background,
			ctx: resContext
		});
	}
	/*
	 * Vykreslí vrstvy určené na vykresleni
	 */
	for(var i in data.selectedLayers){
		if(data.selectedLayers.hasOwnProperty(i)){
			Scene.getLayer(data.selectedLayers[i]).draw(resContext);
		}
	}


	/*
	 * malý canvas kde sa prekreslí velký canvas
	 */
	var resCanvas = G.createElement("canvas", {width: data.width, height: data.height});

	resContext = resCanvas.getContext("2d");
	resContext.drawImage(ca, 0, 0, resCanvas.width, resCanvas.height);


	/*
	 * uloženie súboru
	 */
	Project.files.saveImage(data.name, resCanvas.toDataURL(data.format));
	closeDialog();
}

//UTILS

var processValues = (result, el, ...args) => {
	var process = item => {
		if(item){
			result[item.name] = item.type == "checkbox" ? item.checked : item.value
		}
	};
	process(G.byId(el));
	each(args, e => process(G.byId(e)));
	return result;
}

function shareALl(el){
	Options.setOpt("grid", el.checked);
	G.byId("idShareMenu").checked = el.checked;
	G.byId("idSharePaints").checked = el.checked;
	G.byId("idShareObjects").checked = el.checked;
	G.byId("idShareCreator").checked = el.checked;
	G.byId("idShareLayers").checked = el.checked;
}

class GuiManager{
	constructor(){
		this._topMenu = new MenuManager();
		this._actContextMenu = null;
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	get menu(){
		return this._topMenu;
	}
	get contextMenu(){
		return this._actContextMenu;
	}

	showOptionsByComponents(){
		var setDisabledIfExist = (id, value) =>{
			var el = G.byId(id);
			if(el){
				el.parentElement.style.display = value ? "block" : "none";
			}
		}

		setDisabledIfExist("idAllowedSnapping", Components.edit());
		setDisabledIfExist("idShadows", Components.edit());
		setDisabledIfExist("idShowLayersViewer", Components.layers());
		setDisabledIfExist("idMovingSilhouette", Components.edit());

	}
}
/*
	compatible: 14.9.2016
*/
function pickUpColor(func, thisArg){
	var T;
	if (arguments.length > 1){
		T = thisArg;
	}
	$("#colorPalete").delegate(".colorPatern", "click", function(){
		G("#colorPalete .selected").removeClass("selected")
		func.call(T, G(this).addClass("selected").css("backgroundColor"));
		closeDialog();
		draw();
	});
	showColors();
}

function shadeColor1(color, percent) {  // deprecated. See below.
	var num = parseInt(color.slice(1), 16),
		amt = Math.round(2.55 * percent), 
		R = (num >> 16) + amt, 
		G = (num >> 8 & 0x00FF) + amt,
		B = (num & 0x0000FF) + amt;
	return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + 
							  (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + 
							  (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
}

glob.hexToRGBA = function(color) {
	var num = parseInt(color.slice(1), 16);
	return [num >> 16, num >> 8 & 0x00FF, num & 0x0000FF];
};

/*
	compatible:	14.9.2016
*/

var GVector2fCounter = 0;
var GVector2fCounterClone = 0;

class GVector2f{
	constructor(){
		GVector2fCounter++;
		if(arguments.length === 0){
			this._x = 0;
			this._y = 0;
		}
		else if(arguments.length === 1){
			if(isNaN(arguments[0])){
				this._x = arguments[0].x;
				this._y = arguments[0].y;
			}
			else{
				this._x = this._y = arguments[0];
			}
		}
		else if(arguments.length === 2){
			this._x = arguments[0];
			this._y = arguments[1];
		}
	}

	get x(){return this._x;}
	get y(){return this._y;}

	set x(val){this._x = val;}
	set y(val){this._y = val;}

	getClone(){
		GVector2fCounterClone++;
		return new GVector2f(this._x, this._y);
	}

	toArray(){
		return [this._x, this._y];
	}

	equal(vec){
		return vec._x == this._x && vec._y == this._y;
	}

	getLength(){
		return Math.sqrt(this._x * this._x + this._y * this._y);
	}

	normalize(){
		return this.div(this.getLength());
	}

	_process(){
		if(arguments[0].length == 1){
			if(isNaN(arguments[0][0])){
				this._x = arguments[1](this._x, arguments[0][0].x);
				this._y = arguments[1](this._y, arguments[0][0].y);
			}
			else{
				this._x = arguments[1](this._x, arguments[0][0]);
				this._y = arguments[1](this._y, arguments[0][0]);
			}
		}
		else if(arguments[0].length == 2){
			this._x = arguments[1](this._x, arguments[0][0]);
			this._y = arguments[1](this._y, arguments[0][1]);
		}
		return this;
	}
	round(){
		this._x = Math.round(this._x);
		this._y = Math.round(this._y);
		return this;
	}

	static angle(v1, v2){
		var v1Len = v1.length();
		var v2Len = v2.length();
		var dotProduct = (v1.x / v1Len) * (v2.x / v2Len) + 
						 (v1.y / v1Len) * (v2.y / v2Len);
		return Math.acos(dotProduct) * (180 / Math.PI);
	}

	

	br(){return this._process(arguments, (a, b) => a >> b);}
	bl(){return this._process(arguments, (a, b) => a << b);}
	add(){return this._process(arguments, (a, b) => a + b);}
	div(){return this._process(arguments, (a, b) => a / b);}
	sub(){return this._process(arguments, (a, b) => a - b);}
	mul(){return this._process(arguments, (a, b) => a * b);}
	set(){return this._process(arguments, (a, b) => b);}
	
	length(){
		return Math.sqrt(this._x * this._x + this._y * this._y);
	}

	dist(){
		if(arguments.length == 1){
			return Math.sqrt(Math.pow(this._x - arguments[0].x, 2) + Math.pow(this._y - arguments[0].y, 2));
		}
		else if(arguments.length == 2){
			return Math.sqrt(Math.pow(this._x - arguments[0], 2) + Math.pow(this._y - arguments[1], 2));
		}
	}

}
/*
	compatible:	strictMode, Array.isArray 14.9.2016
*/

glob.testCompatibility = function(){
	var ca = document.createElement("canvas");
	var co = ca.getContext("2d");

	var isUndefined = function(object, key){
		if(typeof object[key] === "undefined"){
			alert("objekt " + object + " neobsahuje atribut " + key);
		}
	};
	isUndefined(co, "canvas");
	isUndefined(co, "currentTransform");//
	isUndefined(co, "direction");//
	isUndefined(co, "fillStyle");
	isUndefined(co, "filter");//
	isUndefined(co, "font");
	isUndefined(co, "globalAlpha");
	isUndefined(co, "globalCompositeOperation");
	isUndefined(co, "imageSmoothingEnabled");//
	isUndefined(co, "imageSmoothingQuality");//
	isUndefined(co, "lineCap");
	isUndefined(co, "lineDashOffset");//
	isUndefined(co, "lineJoin");
	isUndefined(co, "lineWidth");
	isUndefined(co, "miterLimit");
	isUndefined(co, "shadowBlur");
	isUndefined(co, "shadowColor");
	isUndefined(co, "shadowOffsetX");
	isUndefined(co, "shadowOffsetY");
	isUndefined(co, "strokeStyle");
	isUndefined(co, "textAlign");
	isUndefined(co, "textBaseline");

	isUndefined(co, "addHitRegion");//
	isUndefined(co, "arc");
	isUndefined(co, "arcTo");
	isUndefined(co, "asyncDrawXULElement");//
	isUndefined(co, "beginPath");
	isUndefined(co, "bezierCurveTo");
	isUndefined(co, "clearHitRegions");//
	isUndefined(co, "clearRect");
	isUndefined(co, "clip");
	isUndefined(co, "closePath");
	isUndefined(co, "createImageData");
	isUndefined(co, "createLinearGradient");
	isUndefined(co, "createPattern");
	isUndefined(co, "createRadialGradient");
	isUndefined(co, "drawFocusIfNeeded");//
	isUndefined(co, "drawImage");
	isUndefined(co, "drawWidgetAsOnScreen");//
	isUndefined(co, "drawWindow");//
	isUndefined(co, "ellipse");//
	isUndefined(co, "fill");
	isUndefined(co, "fillRect");
	isUndefined(co, "fillText");
	isUndefined(co, "getImageData");
	isUndefined(co, "getLineDash");//
	isUndefined(co, "isPointInPath");
	isUndefined(co, "isPointInStroke");//
	isUndefined(co, "lineTo");
	isUndefined(co, "measureText");
	isUndefined(co, "moveTo");
	isUndefined(co, "putImageData");
	isUndefined(co, "quadraticCurveTo");
	isUndefined(co, "rect");
	isUndefined(co, "removeHitRegion");//
	isUndefined(co, "resetTransform");//
	isUndefined(co, "restore");
	isUndefined(co, "rotate");
	isUndefined(co, "save");
	isUndefined(co, "scale");
	isUndefined(co, "scrollPathIntoView");//
	isUndefined(co, "setLineDash");//
	isUndefined(co, "setTransform");
	isUndefined(co, "stroke");
	isUndefined(co, "strokeRect");
	isUndefined(co, "strokeText");
	isUndefined(co, "transform");
	isUndefined(co, "translate");
	
	isUndefined(window, "performance");
};

glob.showKey = function(key){
	if(Options.showKeys){
		var char = "";

		switch(key){
			case KEY_DELETE :
				char = "DEL";
				break;
			case KEY_L_CTRL :
				char = "CTRL";
				break;
			case KEY_L_ALT :
				char = "ALT";
				break;
			case KEY_SHIFT :
				char = "SHIFT";
				break;
			case KEY_ARROW_UP :
				char = "▲";
				break;
			case KEY_ARROW_LEFT :
				char = "◀";
				break;
			case KEY_ARROW_DOWN :
				char = "▼";
				break;
			case KEY_ARROW_RIGHT :
				char = "▶";
				break;
			case KEY_ENTER :
				char = 	"⏎";
				break;
			case KEY_TABULATOR :
				char = 	"TAB";
				break;
			case KEY_ESCAPE :
				char = 	"ESC";
				break;
			default: 
				char = String.fromCharCode(key);
		}

		var element = G.createElement("div", {}, char);
		setTimeout(() => element.remove(), 2000);
		G("#keysViewerHolder").append(element);
	}
}

class Animation{
	static init(loop){
		Animation._running = false;
		Animation._loop = loop;
		Animation._counter = 0;
	}

	static _mainLoop(timestamp){
		Animation._loop(timestamp);
		
		if(Animation._running){
			requestAnimationFrame(Animation._mainLoop);
		}
	}

	static stop(){
		Animation._running = false;
	
	}
	static start(){
		Animation._running = true;

		var test = (time) => {
			Animation._mainLoop(time);
		};
		requestAnimationFrame(test);
	}
}

function isIn(obj, data){
	//return arguments.some((e, i) => i && e === obj);
	var i;
	if(isArray(data)){
		for(i=0 ; i<data.length ; i++){
			if(data[i] == obj){
				return true;
			}
		}
	}
	else{
		for(i=1 ; i<arguments.length ; i++){
			if(arguments[i] === obj){
				return true;
			}
		}
	}

	return false;
}

glob.roughSizeOfObject = function(object) {
	var objectList = [];
	var stack = [object];
	var bytes = 0;

	while (stack.length) {
		var value = stack.pop();
		if(isBoolean(value)){
			bytes += 4;
		}
		else if(isString(value)){
			bytes += value.length << 1;
		}
		else if(isNumber(value)){
			bytes += 8;
		}
		else if(isObject(value) && objectList.indexOf( value ) === -1){
			objectList.push(value);
			for(var i in value){
				if(value.hasOwnProperty(i)){
					stack.push(value[i]);
				}
			}
		}
	}
	return bytes;
};

var isUndefined 	= e => typeof e === KEYWORD_UNDEFINED,
	isDefined 		= e => typeof e !== KEYWORD_UNDEFINED,
	isFunction 		= e => typeof e === KEYWORD_FUNCTION,
	isNumber		= e => typeof e === KEYWORD_NUMBER,
	isString		= e => typeof e === KEYWORD_STRING,
	isObject		= e => typeof e === KEYWORD_OBJECT,
	isBoolean		= e => typeof e === KEYWORD_BOOLEAN,
	isArray			= e => Array.isArray(e),
	isNull			= e => e === null,
	isEmptyObject   = e => e && Object.keys(e).length === 0 && e.constructor === Object,
	isEmptyArray    = e => isArray(e) && e.length === 0,
	getLength		= function(obj){var counter = 0; each(obj, e => counter++); return counter;},
	isSharing		= () => typeof Sharer !== "undefined" && Sharer.isSharing,
	isInt 			= e => Number(e) === e && e % 1 === 0,
	isFloat 		= e => Number(e) === e && e % 1 !== 0,
	callIfFunc 		= e => isFunction(e) ? e() : false,
	angleBetween 	= (a, b) => Math.atan2(b.y, b.x) - Math.atan2(a.y, a.x),
	getClassOf 		= Function.prototype.call.bind(Object.prototype.toString),
	nvl				= (obj1, obj2) => obj1 ? obj1 : obj2,
	getLastElement	= (el) => isArray(el) && el.length ? el[el.length - 1] : false,
	round 			= (num, val = DEFAULT_ROUND_VAL) => val === 1 ? num : Math.floor(num / val) * val;


glob.toHHMMSS = function(time, decimals = 0) {
    var sec_num = parseInt(time, 10) / 1000;
    var hours   = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    var seconds = sec_num - (hours * 3600) - (minutes * 60);

    if (hours   < 10){ hours   = "0" + hours;}
    if (minutes < 10){ minutes = "0" + minutes;}
    if (seconds < 10){
    	seconds = "0" + seconds.toFixed(decimals);
    }
    else {
    	seconds = seconds.toFixed(decimals);
    }
    return hours + ':' + minutes + ':' + seconds;
};

function each(obj, func, thisArg = false){
	var i;
	if(Array.isArray(obj)){
		if(thisArg){
			for(i=0 ; i<obj.length ; i++){
				func.call(thisArg, obj[i], i, obj);
			}
		}
		else{
			for(i=0 ; i<obj.length ; i++){
				func(obj[i], i, obj);
			}
		}
	}
	else{
		if(thisArg){
			for(i in obj){
				if(obj.hasOwnProperty(i)){
					func.call(thisArg, obj[i], i, obj);
				}
			}
		}
		else{
			for(i in obj){
				if(obj.hasOwnProperty(i)){
					func(obj[i], i, obj);
				}
			}
		}
	}
}

glob.loadPage = function(url){
	var tag = document.createElement('script');

	tag.src = url;
	var firstScriptTag = document.getElementsByTagName('script')[0];
	firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
};

glob.eachFiltered = function(obj, func1, func2, thisArg = false){
	each(obj, (e, i, arr) => func1(e, i, arr) && func2(e, i, arr), thisArg);
};

/*
function extendObject(){
	for(var i=1; i<arguments.length; i++)
		for(var key in arguments[i])
			if(arguments[i].hasOwnProperty(key))
				arguments[0][key] = arguments[i][key];
	return arguments[0];
}
*/

var Movement = {
	move: function(o, x, y, moveChildrens = true){
		if(isDefined(o.locked) && o.locked){
			return;
		}


		if(isDefined(o.selectedConnector) && Creator.operation == OPERATION_DRAW_JOIN && o.selectedConnector){

		}
		else if(o.name === OBJECT_AREA){
			o.move(x, y);
		}
		else if(isDefined(o.moveType)){
			if(Creator.operation == OPERATION_DRAW_LINE && Menu.isToolActive()){

			}
			else{
				var oldPos = o.position.getClone();
				var oldSize = o.size.getClone();
				switch(o.moveType){
					case 0:
						o.position.y += y;
						o.size.y -= y;
						break;
					case 1:
						o.size.x += x;
						break;
					case 2:
						o.size.y += y;
						break;
					case 3:
						o.position.x += x;
						o.size.x -= x;
						break;
					case 4:
						o.position.add(x, y);
						if(moveChildrens){
							o.eachChildren(e => {
								e.moveType = 4;
								Movement.move(e, x, y, false);
								e.moveType = -1;
							});
						}
						break;
					case 5:
						if(!o.minSize || o.size.x + x >= o.minSize.x){
							o.size.x += x;
						}
						if(!o.minSize || o.size.y + y >= o.minSize.y){
							o.size.y += y;
						}
						break;
				}
			}
		}
		else if(isDefined(o.movingPoint)){
			var intVal = 0;
			if(o.movingPoint < 0){//ak sa hýbe celým objektom
				o.points.forEach(a => a.add(x, y));
			}
			else if(isInt(o.movingPoint)){//ak sa kliklo na bod zlomu tak sa bodom hýbe
				if(o.movingPoint === 0){
					o.targetA = "";
				}
				else if(o.movingPoint === o.points.length - 1){
					o.targetB = "";
				}
				o.points[o.movingPoint].add(x, y);
			}
			else{//ináč sa vytvára nový bod
				intVal = parseInt(o.movingPoint) + 1;
				o.points.splice(intVal, 0, o.points[intVal - 1].getClone().add(o.points[(intVal % o.points.length)]).br(1));
				o.movingPoint = intVal;
			}
			Entity.findMinAndMax(o.points, o.position, o.size);
		}
		else{
			o.position.add(x, y);
			if(moveChildrens){
				o.eachChildren(e => e.position.add(x, y));
			}
		}

		Events.objectMove(o);
	}
};

function setCursor(val){
	canvas.style.cursor = val;
}

function closeDialog(){
	//$("#modalWindow > div").each((e) => $(e).hide());

	$("#modalWindow > div").each(function(){
		$(this).hide();
	});
	$("#colorPalete").undelegate();
	$("#modalWindow").hide();
	$("canvas").removeClass("blur");
}

function getText(text, position, size, func, thisArg){
	var T, x = $(document.createElement("INPUT"));

	if (arguments.length > 1){
		T = thisArg;
	}

	x.attr({
		type: "text",
		value: text,
		id: "staticInput"
	}).css({
		left: position.x + 'px',
		top: position.y + 'px',
		width: size.x,
		height: size.y,
		fontSize: size.y * 0.6
	}).blur(function(){
		func.call(T, x.val());
		x.remove();
		draw();
	}).keyup(function(e){
		if(e.keyCode == KEY_ENTER){
			x.onblur = false;
			func.call(T, x.val());
			x.remove();
			draw();
		}
	}).appendTo("body");
	x.select().focus();
}

function getFormattedDate(ms = Date.now()) {
	var date = new Date(ms);
	return date.getDate() + "." + (date.getMonth() + 1) + "." + date.getFullYear() + " " +  date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds() + " " + date.getMilliseconds();
}

glob.setCookie = function(cname, cvalue, exdays) {
	var d = new Date();
	d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
	document.cookie = cname + "=" + cvalue + ";expires="+ d.toUTCString();
};

glob.getCookie = function(cname) {
	var name = cname + "=",
		ca = document.cookie.split(';'),
		i, c;
	for(i = 0; i <ca.length; i++) {
		c = ca[i];
		while (c.charAt(0) == ' '){
			c = c.substring(1);
		}
		if (c.indexOf(name) === 0){
			return c.substring(name.length,c.length);
		}
	}
	return "";
};

function drawBorder(ctx, o, selectors = {tc: 1, bc: 1, cl: 1, cr: 1, br: 1}){
	if(!o.selected && o.name != "Paint"){
		return;
	}
	doRect({
		position: o.position,
		size: o.size,
		borderWidth: DEFAULT_BORDER_WIDTH << 1,
		lineDash:  [15, 5],
		ctx: ctx
	});

	if(selectors.hasOwnProperty("tc")){
		drawSelectArc(ctx, o.position.x + (o.size.x >> 1), o.position.y);
	}
	if(selectors.hasOwnProperty("cl")){
		drawSelectArc(ctx, o.position.x, o.position.y + (o.size.y >> 1));
	}
	if(selectors.hasOwnProperty("bc")){
		drawSelectArc(ctx, o.position.x + (o.size.x >> 1), o.position.y + o.size.y);
	}
	if(selectors.hasOwnProperty("cr")){
		drawSelectArc(ctx, o.position.x + o.size.x, o.position.y + (o.size.y >> 1));
	}

	if(selectors.hasOwnProperty("br")){
		drawSelectArc(ctx, o.position.x + o.size.x, o.position.y + o.size.y);
	}
}

glob.rectRectCollision = function(minA, sizeA, minB, sizeB){
	var ax = minA.x;
	var ay = minA.y;
	var bx = minB.x;
	var by = minB.y;
	var aw = sizeA.x;
	var ah = sizeA.y;
	var bw = sizeB.x;
	var bh = sizeB.y;

	return (bx + bw > ax) && (by + bh > ay) && (bx < ax + aw) && (by < ay + ah);
};

function objectToArray(obj){
	var result = [];
	each(obj, e => result.push(e));
	return result;
}

function updateSelectedObjectView(object){
	/*
	 var container = $("#cont_select_obj");
	 container.find("#posX").text(object.position.x);
	 container.find("#posY").text(object.position.y);
	 container.find("#sizeX").text(object.size.x);
	 container.find("#sizeY").text(object.size.y);
	 container.find("#color").css("backgroundColor", object.color).text(object.color);
	 */
}

function drawConnector(vec, obj, ctx){
	vec = vec.getClone().mul(obj.size);
	doArc({
		x: obj.position.x + vec.x,
		y: obj.position.y + vec.y,
		fillColor: "brown",
		center: true,
		width: 10,
		height: 10,
		ctx: ctx
	});
}

function drawSelectArc(ctx, x, y, color = SELECTOR_COLOR, size = SELECTOR_SIZE << 1 	, dots = true){
	doArc({
		x: x,
		y: y,
		center: true,
		width: size,
		height: size,
		fillColor: color,
		borderWidth: DEFAULT_BORDER_WIDTH << 1,
		lineDash:  dots ? [15, 5] : [],
		borderColor: SELECTOR_BORDER_COLOR,
		ctx: ctx
	});
}

glob.showObject = function(obj){
	if(!isObject(obj)){
		console.log("parameter nieje objekt");
		return;
	}
	var type;
	for(var i in obj){
		if(obj.hasOwnProperty(i)){
			var postfix = "";
			type = typeof obj[i];
			type = type === "object" && isArray(obj[i]) ? "array" : type;

			if(type === "array"){
				postfix = " -> " + obj[i].length;
			}
			else if(type === "string" || type === "number" || type === "boolean"){
				postfix = " -> " + obj[i];
			}
			console.log(i + ": [" + type + "]" + postfix);
		}
	}
};

glob.getMousePos = function(canvasDom, mouseEvent) {
	var rect = canvasDom.getBoundingClientRect();
	return {
		x: mouseEvent["touches"][0].clientX - rect.left,
		y: mouseEvent["touches"][0].clientY - rect.top
	};
};

class EventTimer{
	constructor(event, time){
		this._event = event;
		this._time = time;
		this._timeOut = false;
		this._lastTime = Date.now();
	}

	_callEvent(inst = this){
		inst._event();
		if(inst._timeOut){
			clearTimeout(inst._timeOut);
			inst._timeOut = false;
		}
		inst._lastTime = Date.now();
	}

	_setTimeOut(diff){
		if(this._timeOut){
			return;
		}
		this._timeOut = setTimeout(() => this._callEvent(this) , this._time - diff);
	}

	callIfCan(){
		var diff = Date.now() - this._lastTime;
		diff > this._time ? this._callEvent() : this._setTimeOut(diff);
	}
}

/*
function setConstants(data){
	var constants = {};
	var setConstant = (key, val) => {
		key = key.toUpperCase();
		constants[key] = val;
		Object.defineProperty(window, key, { value : val, writable: false });
	};
	each(data, (e, i) => {
		if(typeof e === "object"){
			each(e, (ee, ii) => {
				if(typeof ee === "object"){
					each(ee, (eee, iii) => {
						if(typeof eee === "object"){
							each(eee, (eeee, iiii) => {
								setConstant(i + "_" + ii + "_" + iii + "_" + iiii, eeee);
							});
						}
						else{
							setConstant(i + "_" + ii + "_" + iii, eee);
						}
					});
				}
				else{
					setConstant(i + "_" + ii, ee);
				}
			});
		}
		else{
			setConstant(i, e);
		}
	});
	return constants;
}
*/

/**************************************************************************************
POLYFILLS
**************************************************************************************/

/*****************
MOJE
*****************/
if(!String.prototype.startsWith){
	String.prototype.startsWith = function(char){
		var s = String(this);
		if(s.length === 0){
			return false;
		}
		return s.charAt(0) === char;
	};
}
/*****************
DEFAULTNE
*****************/

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function(callback, thisArg) {

    var T, k;

    if (this === null) {
      throw new TypeError(' this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== "function") {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.14
// Reference: http://es5.github.io/#x15.4.4.14
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(searchElement, fromIndex) {

    var k;

    // 1. Let o be the result of calling ToObject passing
    //    the this value as the argument.
    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    var o = Object(this);

    // 2. Let lenValue be the result of calling the Get
    //    internal method of o with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = o.length >>> 0;

    // 4. If len is 0, return -1.
    if (len === 0) {
      return -1;
    }

    // 5. If argument fromIndex was passed let n be
    //    ToInteger(fromIndex); else let n be 0.
    var n = +fromIndex || 0;

    if (Math.abs(n) === Infinity) {
      n = 0;
    }

    // 6. If n >= len, return -1.
    if (n >= len) {
      return -1;
    }

    // 7. If n >= 0, then Let k be n.
    // 8. Else, n<0, Let k be len - abs(n).
    //    If k is less than 0, then let k be 0.
    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

    // 9. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the
      //    HasProperty internal method of o with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      //    i.  Let elementK be the result of calling the Get
      //        internal method of o with the argument ToString(k).
      //   ii.  Let same be the result of applying the
      //        Strict Equality Comparison Algorithm to
      //        searchElement and elementK.
      //  iii.  If same is true, return k.
      if (k in o && o[k] === searchElement) {
        return k;
      }
      k++;
    }
    return -1;
  };
}

if (!Date.now) {
  Date.now = function now() {
    return new Date().getTime();
  };
}

if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          return fToBind.apply(this instanceof fNOP ? this : oThis,
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype; 
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = (function() {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function(obj) {
      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}

if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}

/*
	compatible: forEach, canvas, JSON parsing 14.9.2016
*/
class MenuManager{
	constructor(position = new GVector2f(), size = new GVector2f(MENU_WIDTH, MENU_HEIGHT), key = "mainMenu", parent = null){
		if(parent != null)
			this._items = parent._allItems[key];

		this._key 						= key;
		this._parent 					= parent;
		this._toolActive 				= false;
		this._fontColor 				= MENU_FONT_COLOR;
		//this._backgroundColor 		= "rgb(153, 217, 234)";
		this._backgroundColor 			= MENU_FILL_COLOR;
		this._disabledBackgroundColor 	= MENU_DISABLED_FILL_COLOR;
		this._position 					= position.add(MENU_OFFSET);
		this._offset 					= MENU_OFFSET;
		this._size 						= size;
		this._vertical 					= parent != null;
		this._visibleElements			= 0;
		this._canvas 					= parent == null ? document.createElement("canvas") : parent._canvas;
		this._context					= null;
		this._tmpDrawArray				= [];
		this._visible 					= true;
		this._visibleSubMenu 			= false;
		this._subMenus					= {};
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	};

	get position(){return this._position;}
	get size(){return this._size;}
	get visible(){return this._visible;}
	set visible(val){
		this._visible = val;
		if(Creator.view){
			if(this._visible)
				Creator.view.position.x = this.position.x + (this.size.x + MENU_OFFSET) * this.visibleElements - MENU_OFFSET;
			else
				Creator.view.position.x = MENU_OFFSET;
			draw();
		}
	}

	hover(x, y){
		if(!this._visible)
			return false;

		var posY = this._position.y,
			posX = this._position.x,
			result = false;

		if(this._visibleSubMenu)
			result = this._subMenus[this._visibleSubMenu].hover(x, y);


		if(!result)
			//this._items.forEach(function(e) {
			each(this._items, function(e) {
				if (!e["visible"] || result)
					return false;

				if(x > posX && x < posX + this._size.x && y > posY && y < posY + this._size.y )
					result = e;

				if(this._vertical)
					posY += this._size.y + this._offset;
				else
					posX += this._size.x + this._offset;
			}, this);
		if(result){
			if(result.disabled)
				setCursor(CURSOR_NOT_ALLOWED);
			else
				setCursor(CURSOR_POINTER);
		}
		else
			setCursor(CURSOR_DEFAULT);

		return result !== false;
	}

	static _changeDataByComponents(data){
		if(!Components.tools() && Components.draw()) //ak je kreslenie a nie nastroje musí sa nastaviť kreslenie
			Creator.operation = OPERATION_DRAW_PATH;
		
		data["tools"]["draw"]["visible"] = data["tools"]["draw"]["visible"] && Components.draw();
		//TODO undo a redo zmeniť lebo ho bude treba aj pri tool componente
		data["mainMenu"]["undo"]["visible"] = data["mainMenu"]["undo"]["visible"] && Components.draw();
		data["mainMenu"]["redo"]["visible"] = data["mainMenu"]["redo"]["visible"] && Components.draw();

		data["mainMenu"]["tools"]["visible"] = data["mainMenu"]["tools"]["visible"] && Components.tools();
		data["mainMenu"]["content"]["visible"] = data["mainMenu"]["content"]["visible"] && Components.content();
		data["mainMenu"]["sharing"]["visible"] = data["mainMenu"]["sharing"]["visible"] && Components.share();
		data["tools"]["image"]["visible"] = data["tools"]["image"]["visible"] && Components.load();

		if(!Components.load() && !Components.save() && !Components.screen() && !Components.task())
			data["mainMenu"]["file"]["visible"] = data["mainMenu"]["file"]["visible"] && false;
		else{
			data["file"]["loadXML"]["visible"] = data["file"]["loadXML"]["visible"] && Components.load();
			data["file"]["saveXML"]["visible"] = data["file"]["saveXML"]["visible"] && Components.save();
			data["file"]["saveImg"]["visible"] = data["file"]["saveImg"]["visible"] && Components.screen();
			data["file"]["saveTask"]["visible"] = data["file"]["saveTask"]["visible"] && Components.task();
		}


		return data;
	}
	/*
	setVisibility(menu, subMenu, value){
		data[menu][subMenu]["visible"] = value;
	}
	*/
	init(data){
		if(!MenuManager.dataBackup)
			MenuManager.dataBackup = JSON.stringify(data);

		data = MenuManager._changeDataByComponents(data);
		var array = [],
			counter = new GVector2f(),
			w = this._size.x + MENU_OFFSET,
			h = this._size.y + MENU_OFFSET,
			num = 0,
			store = {},
			tmp;

		this._visibleElements = 0;
		each(data, function(eee, ii){
			array[ii] = [];
			each(data[ii], function(e, i){
				if(isDefined(e["values"])){
					//e.values.forEach(function(ee){
					each(e.values, function(ee){
						tmp = {};
						tmp["visible"] = e["visible"];
						tmp["disabled"] = e["disabled"];
						tmp["key"] = i.replace("XYZ ", "");

						tmp["posX"] = counter.x;
						tmp["posY"] = counter.y;
						counter.x++;
						tmp["value"] = ee;
						this._tmpDrawArray.push({
							x: counter.x,
							y: counter.y,
							value:  ee,
							key: i
						});
						array[ii].push(tmp);
					}, this);
					return;
				}

				e["key"] = i;

				if(ii === "mainMenu" && e.visible){
					this._visibleElements++;
				}
				
				e["posX"] = counter.x;
				e["posY"] = counter.y;
				this._tmpDrawArray.push({
					x: counter.x,
					y: counter.y,
					key: i
				});
				counter.x++;

				array[ii].push(e);
			}, this);

			if(isIn(ii, "tools", "file", "content", "sharing")){
				store[ii] = num;
			}
			if(ii !== "mainMenu" && data["mainMenu"][ii]["visible"]){
				num++;
			}
		}, this);
		this._canvas.width 	= this._tmpDrawArray[this._tmpDrawArray.length - 1].x * this._size.x + this._size.x;
		this._canvas.height	= this._tmpDrawArray[this._tmpDrawArray.length - 1].y * this._size.y + this._size.y;
		this._context 		= this._canvas.getContext('2d');

		this._redraw();


		this._items 	= array["mainMenu"];
		this._allItems 	= array;

		each(store, (e, i) => {
			this._subMenus[i] = new MenuManager(new GVector2f(e * w, h), new GVector2f(this._size.x, this._size.y), i, this);
		}, this);

		if(Creator.view){
			if(this._visible)
				Creator.view.position.x = this.position.x + (this.size.x + MENU_OFFSET) * this.visibleElements - MENU_OFFSET;
			else
				Creator.view.position.x = MENU_OFFSET;
		}
		draw();
	}

	get visibleElements(){
		return this._visibleElements;
	}

	isToolActive(){
		var tmp = this._toolActive;
		this._toolActive = false;
		return tmp;
	};

	/*
	 * CLICK
	 */

	clickIn(x, y) {
		if(!this._visible)
			return false;

		var posY = this._position.y,
			posX = this._position.x,
			result = false;

		if(this._visibleSubMenu)
			result = this._subMenus[this._visibleSubMenu].clickIn(x, y);

		this._visibleSubMenu = false;

		if(result)
			return result;

		//this._items.forEach(function(e) {
		each(this._items, function(e) {
			if (!e["visible"] || result)
				return false;

			if(x > posX && x < posX + this._size.x && y > posY && y < posY + this._size.y ){
				result = e;
				this._doClickAct(e);
			}

			if(this._vertical)
				posY += this._size.y + this._offset;
			else
				posX += this._size.x + this._offset;
		}, this);

		if(result)
			return result;
	};

	disabled(menu, button, value){
		var check = (e, i, arr) => {
			if(e.key === button)
					arr[i].disabled = typeof value === KEYWORD_UNDEFINED ? !e.disabled : value;
		};
		if(this._key == menu)
			each(this._items, check);
		else if(isDefined(this._subMenus[menu]))
			each(this._subMenus[menu]._items, check);
	}

	_doClickAct(val){
		var key = val.key;

		if(val.disabled){
			Logger.log("Klikol v menu na disablovanu položku " + key, LOGGER_MENU_CLICK);
			return;
		}

		Logger.log("Klikol v menu na položku " + key, LOGGER_MENU_CLICK);
		if(isIn(key, "file", "content", "sharing")){
			this._visibleSubMenu = key;
			return;
		}
		switch(key){
			case "tools":
				this._toolActive = "tools";
				if(Creator.operation === OPERATION_DRAW_PATH){
					Logger.write("pre výber nástrojov podržne stlačené tlačidlo myši na možnosti TOOLS")
				}
				break;
			case "color":
				pickUpColor(color => Creator.setOpt(ATTRIBUTE_FILL_COLOR, color));
				break;
			case "options":
				showOptions();
				break;
			case "draw":
				Creator.operation = OPERATION_DRAW_PATH;
				break;
			case "area":
				Creator.toggleArea();
				break;
			case "rect":
				Creator.operation = OPERATION_DRAW_RECT;
				break;
			case "image":
				Creator.operation = OPERATION_DRAW_IMAGE;
				break;
			case "line":
				Creator.operation = OPERATION_DRAW_LINE;
				break;
			case "startShare":
				showSharingOptions();
				break;
			case "loadLocalImage":
				Project.content.setContentImage();
				break;
			case "loadLocalHTML":
				Project.content.setContentHTML();
				break;
			case "undo":
				Paints.undo();
				break;
			case "copyUrl":
				Sharer.copyUrl();
				break;
			case "redo":
				Paints.redo();
				break;
			case "saveImg":
				showSavingOptions();
				break;
			case "watch":
				showWatcherOptions();
				break;
			case "saveTask":
				saveSceneAsTask();
				break;
			case "stopShare":
				//Sharer.stopShare();
				Project.connection.disconnect();
				break;
			case "saveXML":
				showXmlSavingOptions();
				break;
			case "loadXML":
				loadSceneFromFile();
				break;
			case "rubber":
				Creator.toggleRubber();
				break;
			case "arc":
				Creator.operation = OPERATION_DRAW_ARC;
				break;
			case "defaultBrushes":
				Paints.setImage(val.value);
				break;
			case "defaultWidth":
				Creator.setOpt(ATTRIBUTE_LINE_WIDTH, val.value);
				this._parent._redraw();
				break;
			case "join":
				Creator.operation = OPERATION_DRAW_JOIN;
				break;
			case "lineWidth":
				this._visibleSubMenu = key;
				break;
		}
	}

	/*
	 * PRESS
	 */

	_doPressAct(index, pos){
		if(!index)
			return false;
		switch(index){
			case "tools":
				this._visibleSubMenu = index;
				break;
			case "file":
				actContextMenu = new ContextMenuManager(pos, [], false, "file");
				break;
		}
		return index;
	};

	pressIn(x, y){
		if(!this._visible)
			return false;
		var posY = this._position.y,
			posX = this._position.x,
			result = false;

		if(this._visibleSubMenu)
			result = this._subMenus[this._visibleSubMenu].clickIn(x, y);

		if(result)
			return result;

		//this._items.forEach(function(e) {
		each(this._items, function(e) {
			if (!e["visible"] || result)
				return false;

			if(x > posX && x < posX + this._size.x && y > posY && y < posY + this._size.y ){
				result = e;
				this._doPressAct(e.key, new GVector2f(x, y));
			}

			if(this._vertical)
				posY += this._size.y + this._offset;
			else
				posX += this._size.x + this._offset;

		}, this);
		if(result)
			return result;
	};

	/*
	 * DRAW
	 */

	draw(){
		if(!this._items || !this._visible)
			return;
		var posY = this._position.y,
			posX = this._position.x;


		context.lineWidth = MENU_BORDER_WIDTH;
		context.strokeStyle = MENU_BORDER_COLOR;
		context.fillStyle = this._backgroundColor;

		//this._items.forEach(function(e){
		each(this._items, function(e){
			if(!e["visible"])
				return;
			var bgColor = e["disabled"] ? this._disabledBackgroundColor : this._backgroundColor;
			if(e["key"] == "color" )
				bgColor = Creator.color;

			var shadow = e["key"] === "rubber" && Creator.operation === OPERATION_RUBBER || 
						 e["key"] === "area" && Creator.operation === OPERATION_AREA || 
						 e["key"] === this._visibleSubMenu;
			doRect({
				position: [posX, posY],
				size: this._size,
				radius: MENU_RADIUS,
				fillColor: bgColor,
				borderWidth: MENU_BORDER_WIDTH,
				borderColor: MENU_BORDER_COLOR,
				shadow: shadow
			});

			context.drawImage(this._canvas, e["posX"] * this._size.x, e["posY"] * this._size.y, this._size.x, this._size.y, posX, posY, this._size.x, this._size.y);

			if(this._vertical)
				posY += this._size.y + this._offset;
			else
				posX += this._size.x + this._offset;
		}, this);


		if(this._visibleSubMenu)
			this._subMenus[this._visibleSubMenu].draw();
	};

	_redraw(){
		this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
		//this._tmpDrawArray.forEach(function(e){
		each(this._tmpDrawArray, function(e){			
			this._drawIcon(e, e.x * this._size.x, e.y * this._size.y, 5, this._size.x, this._size.y, this._fontColor);
		}, this);

		Logger.log("prekresluje sa " + this.constructor.name, LOGGER_DRAW);
	}

	_drawIcon(type, x, y, offset = 5, width = this._size.x, height = this._size.y, strokeColor = DEFAUL_STROKE_COLOR, strokeWidth = DEFAULT_BORDER_WIDTH){
		var img;
		switch(type.key){
			case "arc":
				doArc({
					position: [x + offset, y + offset],
					size: [width - (offset << 1), height - (offset << 1)],
					borderColor: strokeColor,
					borderWidth: strokeWidth,
					ctx: this._context
				});
				break;
			case "rect":
				doRect({
					position: [x + offset, y + offset],
					size: [width - (offset << 1), height - (offset << 1)],
					borderWidth: strokeWidth,
					borderColor: strokeColor,
					ctx: this._context
				});
				break;
			case "line":
				doLine({
					points: [new GVector2f(x + offset, y + offset),
							 new GVector2f(x + width - (offset << 1), y + (height >> 1)),
							 new GVector2f(x + offset, y +  height - (offset << 1)),
							 new GVector2f(x + width - (offset << 1), y + offset)],
					borderWidth: strokeWidth,
					borderColor: strokeColor,
					ctx: this._context
				});
				break;
			case "text":
				fillText("TEXT", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "ctrl":
				fillText("CTRL", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "file":
				fillText("FILE", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "content":
				fillText("CONT", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "undo":
				fillText("UNDO", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "redo":
				fillText("REDO", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "watch":
				fillText("JOIN", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "copyUrl":
				fillText("LINK", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "shareOptions":
				fillText("OPT", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "rubber":
				fillText("RUBB", x + (width >> 1), y + (height >> 1), height / 5, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "area":
				fillText("AREA", x + (width >> 1), y + (height >> 1), height / 5, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "stopShare":
				fillText("STOP", x + (width >> 1), y + (height >> 1), height  >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "startShare":
				fillText("START", x + (width >> 1), y + (height >> 1), height  >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "sharing":
				fillText("CONN", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "loadLocalImage":
				fillText("locImg", x + (width >> 1), y + (height >> 1), height / 6, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "loadLocalHTML":
				fillText("locHTML", x + (width >> 1), y + (height >> 1), height / 6, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "loadExternalImage":
				fillText("extImg", x + (width >> 1), y + (height >> 1), height / 6, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "loadExternalHTML":
				fillText("extHTML", x + (width >> 1), y + (height >> 1), height / 6, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "saveImg":
				fillText("SAVE IMG", x + (width >> 1), y + (height >> 1), height >> 3, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "saveXML":
				fillText("SAVE XML", x + (width >> 1), y + (height >> 1), height >> 3, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "saveTask":
				fillText("SAVE TASK", x + (width >> 1), y + (height >> 1), height >> 3, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "loadXML":
				fillText("LOAD XML", x + (width >> 1), y + (height >> 1), height >> 3, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "options":
				fillText("OPT", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "table":
				var lines = 4;
				var line = (height - (offset << 1)) / lines;
				var points = [[x + (width >> 1), y + offset, x + (width >> 1), y - offset + height]];
				for(var i=1, data = line ; i<lines ; i++, data += line)
					points.push([x + offset, y + offset + data, x - offset + width, y + offset + data]);

				doRect({
					position: [x + offset, y + offset],
					size: [width - (offset << 1), height - (offset << 1)],
					borderWidth: strokeWidth,
					borderColor: strokeColor,
					ctx: this._context
				});
				
				doLine({
					points: points,
					borderWidth: strokeWidth,
					borderColor: strokeColor,
					ctx: this._context
				});
				//fillText("TAB", x + (width >> 1), y + (height >> 1), height >> 2, this._fontColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "class":
				fillText("CLASS", x + (width >> 1), y + (height >> 1), height / 5, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "image":
				fillText("IMG", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "tools":
				fillText("TOOLS", x + (width >> 1), y + (height >> 1), height / 5, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "polygon":
				fillText("POLY", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;

			case "help":
				fillText("HELP", x + (width >> 1), y + (height >> 1), height >> 2, strokeColor, 0, FONT_ALIGN_CENTER, this._context);
				break;
			case "defaultWidth":
				doLine({
					points: [x + offset, y + (height >> 1), x + width - offset, y + (height >> 1)],
					borderWidth: type.value,
					borderColor: strokeColor,
					ctx: this._context
				});
				break;
			case "brushes":
				img = Paints.selectedImg;
				if(img == null)
					return;
				this._context.drawImage(img, 0, 0, img.width, img.height, x , y, width, height);
				break;
			case "lineWidth":
				doLine({
					points: [x + offset, y + (height >> 1), x + width - offset, y + (height >> 1)],
					borderWidth: Creator.lineWidth,
					borderColor: this._fontColor,
					ctx: this._context
				});

				break;
			case "defaultBrushes":
				Paints.addBrush(type.value);
				img = Paints.getBrush(type.value);
				this._context.drawImage(img, 0, 0, img.width, img.height, x , y, width, height);
				break;
			case "draw":
				drawQuadraticCurve({
					points : [
						new GVector2f(x + offset, y + offset),[
							new GVector2f(x + offset, y +  height - (offset << 1)), 
							new GVector2f(x + width - (offset << 1), y + (height >> 1))
						],[
							new GVector2f(x + offset, y + offset), 
							new GVector2f(x + offset, y +  height - (offset << 1))
						],[
							new GVector2f(x + width - (offset << 1), y + (height >> 1)), 
							new GVector2f(x + width - (offset << 1), y + offset)
						],[
							new GVector2f(x + offset, y +  height - (offset << 1)), 
							new GVector2f(x + offset, y + offset)
					]],
					borderWidth : strokeWidth,
					borderColor : strokeColor,
					ctx : this._context
				});
				break;
			case "join":
				fillText("JOIN", 
						 x + (width >> 1), 
						 y + (height >> 1), 
						 height >> 2, 
						 strokeColor, 
						 0, 
						 FONT_ALIGN_CENTER, 
						 this._context);
				break;
		}
	}
}
/*
	compatible: forEach, Object.keys 14.9.2016
*/
class ContextMenuManager{
	constructor(position, titles = [], parent = false, key = "undefined"){
		this._position 			= position;
		this._subMenu 			= false;
		this._parent 			= parent;
		this._key 				= key;
		this._textColor 		= CONTEXT_MENU_FONT_COLOR;
		this._fillColor			= CONTEXT_MENU_FILL_COLOR;
		this._selectedObject 	= parent ? parent._selectedObject : selectedObjects.movedObject;
		this._titles 			= titles;

		//TODO toto prerobiť do JSON suboru
		if(this._titles.length == 0){
			if(selectedObjects.movedObject){
				if(isIn(selectedObjects.movedObject.name, OBJECT_RECT, OBJECT_POLYGON, OBJECT_ARC, OBJECT_LINE, OBJECT_TABLE, OBJECT_IMAGE, OBJECT_TEXT))
					this._addFields("delete", "locked", "makeCopy", "changeLayer", "changeOpacity");

				if(isIn(selectedObjects.movedObject.name, OBJECT_RECT, OBJECT_POLYGON, OBJECT_TEXT, OBJECT_ARC))
					this._addFields("changeFillColor", "changeBorderColor");

				if(isIn(selectedObjects.movedObject.name, OBJECT_RECT, OBJECT_POLYGON, OBJECT_TEXT, OBJECT_LINE))
					this._addFields("radius");

				if(selectedObjects.movedObject.name == OBJECT_LINE)
					this._addFields("joinType", "lineCap", "lineStyle", "lineType", "lineWidth", "arrowEndType", "arrowStartType");
				else if(selectedObjects.movedObject.name == OBJECT_TABLE)
					this._addFields("editTable");
				else if(selectedObjects.movedObject.name == OBJECT_TEXT)
					this._addFields("verticalTextAlign", "horizontalTextAlign", "taskResult");
				else if(selectedObjects.movedObject.name == OBJECT_IMAGE)
					this._addFields("changeImage");
				else if(selectedObjects.movedObject.name == "LayerViewer"){
					this._addFields("visible", "lockLayer", "showPaint", "animatePaint", "clearPaint");
					if(!selectedObjects.movedObject.locked)
						this._addFields("deleteLayer", "renameLayer", "clearLayer");
				}
			}
			else if(!parent){
				this._addFields("clearWorkspace");
			}
		}
		context.font = (30 - CONTEXT_MENU_OFFSET) + "pt " + DEFAULT_FONT_FAMILY;

		var hasExtension = false;

		if(this._titles.length){
			//titles.forEach(function(e, i, arr){
			each(titles, function(e, i ,arr){
				if(e["type"] == INPUT_TYPE_RADIO){
					hasExtension = true;
					arr[i]["value"] = this._selectedObject["_" + this._key] == e["name"];
				}

				if(e.type == INPUT_TYPE_CHECKBOX){
					hasExtension = true;
					if(e.key == "locked")
						arr[i].value = selectedObjects.movedObject.locked;
					else if(e.key == "visible")
						arr[i].value = selectedObjects.movedObject.visible;
					else if(e.key == "showPaint")
						arr[i].value = selectedObjects.movedObject.showPaint;
					else if(e.key == "taskResult")
						arr[i].value = selectedObjects.movedObject.taskResult;
				}
			}, this);
		}
		this._menuWidth = glob.getMaxWidth(this._titles.map(e => e.label)) + (CONTEXT_MENU_OFFSET << 1);

		if(hasExtension)
			this._menuWidth += 30;

		this._size = new GVector2f(this._menuWidth, this._titles.length * CONTEXT_MENU_LINE_HEIGHT);
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	};

	get position(){
		return this._position;
	};

	static disabled(val, ... args){
		var res = ContextMenuManager.items[args[0]];

		if(args[1])
			res.fields[args[1]].disabled = val;
		else
			res.disabled = val;
	}

	static visibility(val, ... args){
		var res = ContextMenuManager.items[args[0]];

		if(args[1])
			res.fields[args[1]].visible = val;
		else
			res.visible = val;
	}

	_addFields(){
		var res;

		//objectToArray(arguments).forEach(function(e){
		each(objectToArray(arguments), e => {
			res = ContextMenuManager.items[e];
			if(res && res.visible){
				res.key = e;
				this._titles[this._titles.length] = res;
			}
		}, this);
	};

	clickInBoundingBox(x, y){
		return x + SELECTOR_SIZE > this._position.x && x - SELECTOR_SIZE < this._position.x + this._menuWidth &&
			   y + SELECTOR_SIZE > this._position.y && y - SELECTOR_SIZE < this._position.y + this._titles.length * CONTEXT_MENU_LINE_HEIGHT;
	};

	draw(){
		if(this._position.x + this._menuWidth > canvas.width)
			this._position.x = canvas.width - this._menuWidth;

		if(this._position.y + this._titles.length * CONTEXT_MENU_LINE_HEIGHT >canvas.height)
			this._position.y = canvas.height - this._titles.length * CONTEXT_MENU_LINE_HEIGHT;

		var count 		= 0,
			pX 			= this._position.x,
			pY 			= this._position.y,
			menuWidth 	= this._menuWidth,
			posY 		= pY,
			checkSize 	= 20,
			offset 		= (CONTEXT_MENU_LINE_HEIGHT - checkSize) >> 1;

		doRect({
			position:[pX, pY],
			width: this._menuWidth,
			height: Object.keys(this._titles).length * CONTEXT_MENU_LINE_HEIGHT,
			radius: MENU_RADIUS,
			borderColor: this._borderColor,
			borderWidth: this._borderWidth,
			fillColor: this._fillColor,
			shadow: true,
			draw: true
		});
		each(this._titles, function(e){
			context.fillStyle = DEFAULT_FONT_COLOR;
			posY = pY + count * CONTEXT_MENU_LINE_HEIGHT;
			if(count++)
				doLine({points: [pX, posY, pX + menuWidth, posY], draw: true});

			//STARA SA O ROZBALANE ALEBO DISABLOVANE POZADIE
			if(e.disabled || this._subMenu && e.key == this._subMenu._key){
				var firstRadius = this._titles[0] === e ? MENU_RADIUS : 0;
				var lastRadius = getLastElement(this._titles) === e ? MENU_RADIUS : 0;

				doRect({
					position:[pX, posY],
					width: this._menuWidth,
					height: CONTEXT_MENU_LINE_HEIGHT,
					radius: {tr: firstRadius, tl: firstRadius, br: lastRadius, bl: lastRadius},
					borderColor: this.borderColor,
					borderWidth: this.borderWidth,
					fillColor: e.disabled ? CONTEXT_MENU_DISABLED_FILL_COLOR : CONTEXT_MENU_SELECTED_FILL_COLOR,
					draw: true
				});
			}

			fillText(e.label, pX, posY,  30 - CONTEXT_MENU_OFFSET, this._textColor, [CONTEXT_MENU_OFFSET, 0]);


			if(e.type == INPUT_TYPE_CHECKBOX)
				doRect({
					x: pX + menuWidth - offset - checkSize,
					y: posY + offset,
					size: checkSize,
					radius: 5,
					borderColor: this.borderColor,
					borderWidth: this.borderWidth,
					fillColor: e.value ? CHECKBOX_COLOR_TRUE : CHECKBOX_COLOR_FALSE,
					draw: true
				});
			else if(e.type == INPUT_TYPE_RADIO)
				doArc({
					x: pX + menuWidth - offset - checkSize,
					y: posY + offset,
					size: checkSize,
					borderColor: DEFAULT_FONT_COLOR,
					fillColor: DEFAULT_FONT_COLOR,
					draw: !e.value,
					fill: e.value
				});
			else if(e.type == "widthValue")
				doLine({
					points: [pX + menuWidth - (checkSize << 2), posY + (CONTEXT_MENU_LINE_HEIGHT >> 1),
							 pX + menuWidth - offset, posY + (CONTEXT_MENU_LINE_HEIGHT >> 1)],
					borderWidth: e.name
				});
		}, this);
	
		if(this._subMenu)
			this._subMenu.draw();
	};

	_doClickAct(opt) {
		var act = opt.key;
		if(opt.disabled)
			return false;

		Logger.log("Klikol v contextMenu na položku " + act, LOGGER_CONTEXT_CLICK);
		switch (act) {
			case "changeLayer" : 

				break;
			case "changeFillColor":
				pickUpColor(color => Entity.changeAttr(this._selectedObject, ATTRIBUTE_FILL_COLOR, color), this);
				actContextMenu = false;
				break;
			case "changeBorderColor":
				pickUpColor(color => Entity.changeAttr(this._selectedObject, ATTRIBUTE_BORDER_COLOR, color), this);
				actContextMenu = false;
				break;
			case "delete":
				if (this._selectedObject)
					Scene.remove(this._selectedObject);
				actContextMenu = false;
				break;
			case "locked":
				this._selectedObject.locked = !this._selectedObject.locked;
				ContextMenuManager.items.locked.value = this._selectedObject.locked;
				actContextMenu = false;
				break;
			case "clearWorkspace":
				Scene.cleanUp();
				actContextMenu = false;
				break;
			case "taskResult":
				this._selectedObject.taskResult = !this._selectedObject.taskResult;
				actContextMenu = false;
				break;
			case "removeRow":
				this._selectedObject.removeRow(this._parent.position.y);
				actContextMenu = false;
				break;
			case "removeColumn":
				this._selectedObject.removeColumn(this._parent.position.x);
				actContextMenu = false;
				break;
			case "addRowBelow":
				this._selectedObject.addRow(this._parent.position.y, "below");
				actContextMenu = false;
				break;
			case "addRowAbove":
				this._selectedObject.addRow(this._parent.position.y, "above");
				actContextMenu = false;
				break;
			case "addColumnToRight":
				this._selectedObject.addColumn(this._parent.position.x, "right");
				actContextMenu = false;
				break;
			case "addColumnToLeft":
				this._selectedObject.addColumn(this._parent.position.x, "left");
				actContextMenu = false;
				break;
			case "clearRow":
				this._selectedObject.clear(this._parent.position.y, "row");
				actContextMenu = false;
				break;
			case "clearColumn":
				this._selectedObject.clear(this._parent.position.x, "column");
				actContextMenu = false;
				break;
			case "clearTable":
				this._selectedObject.clear(null, "table");
				actContextMenu = false;
				break;
			case "showPaint":
				this._selectedObject.toggleVisibilityOfPaint(this._position.y);
				actContextMenu = false;
				break;
			case "clearPaint":
				this._selectedObject.clearPaint(this._position.y);
				actContextMenu = false;
				break;
			case "visible":
				this._selectedObject.toggleVisibilityOfLayer(this._position.y);
				actContextMenu = false;
				break;
			case "clearLayer":
				this._selectedObject.clearLayer(this.position.y);
				actContextMenu = false;
				break;
			case "animatePaint":
				this._selectedObject.animateLayer(this.position.y);
				actContextMenu = false;
				break;
			case "renameLayer":
				this._selectedObject.renameLayer(this.position.y);
				actContextMenu = false;
				break;
			case "makeCopy":
				var obj = Entity.create(this._selectedObject);
				obj.position.add(this._selectedObject.size);
				Scene.addToScene(obj);
				actContextMenu = false;
				break;
			default:
				if(opt.group == "roundRadius"){
					Entity.changeAttr(this._selectedObject, ATTRIBUTE_RADIUS, opt.name);
					actContextMenu = false;
				}
				else if(opt.group == "lineCapValue"){
					this._selectedObject.lineCap = opt.name;
					actContextMenu = false;
				}
				else if(opt.group == "joinTypeValue"){
					this._selectedObject.joinType = opt.name;
					actContextMenu = false;
				}
				else if(opt.group == "lineStyleValue"){
					this._selectedObject.lineStyle = opt.name;
					actContextMenu = false;
				}
				else if(opt.group == "widthValue"){
					Entity.changeAttr(this._selectedObject, ATTRIBUTE_BORDER_WIDTH, opt.name);
					//this._selectedObject.borderWidth = opt.name;
					actContextMenu = false;
				}
				else if(opt.group == "arrowEndType"){
					this._selectedObject.arrowEndType = opt.name;
					actContextMenu = false;
				}
				else if(opt.group == "arrowStartType"){
					this._selectedObject.arrowStartType = opt.name;
					actContextMenu = false;
				}
				else if(opt.group == "valignValue"){
					this._selectedObject.verticalTextAlign = opt.name;
					actContextMenu = false;
				}
				else if(opt.group == "halignValue"){
					this._selectedObject.horizontalTextAlign = opt.name;
					actContextMenu = false;
				}
				else if(opt.group === "layerValue"){
					Project.scene.changeLayer(this._selectedObject, opt.name);
					actContextMenu = false;
					draw();
				}

		}
	}


	clickIn(x, y){
		if(!this.clickInBoundingBox(x, y))
			return this._subMenu ? this._subMenu.clickIn(x, y) : false;

		var i = parseInt((y - this._position.y) / CONTEXT_MENU_LINE_HEIGHT);

		if(isDefined(this._titles[i]) && this._titles[i].hasOwnProperty("fields")){
			var pos = this._position.getClone().add(this._menuWidth, i * CONTEXT_MENU_LINE_HEIGHT);
			if(pos.x + this._menuWidth > canvas.width)
				pos.x -= this._menuWidth << 1;
			if(this._titles[i].key === "changeLayer"){
				this._titles[i].fields = [];
				each(Scene.layers, e => {
					this._titles[i].fields.push({
						group : "layerValue",
						name : e.title,
						label : e.title
					});
				})
			}
			this._subMenu = new ContextMenuManager(pos, objectToArray(this._titles[i].fields), this, this._titles[i]["key"]);
		}
		else
			this._subMenu = false;

		this._doClickAct(this._titles[i]);

		return true;
	};

}
/*
	compatible: blob constructing, File API, FileReader API, JSON parsing 14.9.2016
*/
class FileManager{
	constructor(){
		this._input = document.createElement("input");
		this._input.setAttribute("type", "file");
		this._input.setAttribute("value", "files");
		this._input.setAttribute("class", "hide");

		this._link = document.createElement("a");
		this._link.setAttribute("class", "hide");
		this._link.setAttribute("href", "");
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	saveFile(name, text, type = "text/plain"){
		this._link.href = URL.createObjectURL(new Blob([text], {type: type}));
		this._link.download = name;
		this._link.click();
	}

	saveImage(name, image){
		this._link.href = typeof image === "string" ? image : image.src;
		this._link.download = name;
		this._link.click();
	}

	loadImage(func){
		this._input.onchange = function(e){
			var reader = new FileReader();
			reader.onload = function(){
				var image = new Image();
				image.src = reader.result;
				func(image);
			};
			reader.readAsDataURL(e.target.files[0]);
		};
		this._input.click();
	}

	loadFile(func){
		this._input.onchange = function(e){
			var reader = new FileReader();
			reader.onload = () => func(reader.result);
			reader.readAsText(e.target.files[0]);
		};
		this._input.click();
	}


}

function saveFile(name, text, type){
	if(typeof type === "undefined"){
		type = "text/plain";
	}
	var file = new Blob([text], {type: type}),
		a   = document.getElementById("fileLink");

	a.href = URL.createObjectURL(file);
	a.download = name;
	a.click();
}

function saveImage(name, image){
	var a = document.getElementById("fileLink");
	a.href = image;
	a.download = name;
	a.click();
}

function loadImage(func){
	var el = document.getElementById("fileInput");
	el.onchange = function(e){
		var reader = new FileReader();
		reader.onload = function(){
			var image = new Image();
			image.src = reader.result;
			func(image);
		};
		reader.readAsDataURL(e.target.files[0]);
	};
	el.click();
}

function loadFile(func){
	//var el = document.getElementById("fileInput");
	var el = document.createElement("input");
	el.setAttribute("id", "fileInput");
	el.setAttribute("type", "file");
	el.setAttribute("value", "files");
	el.setAttribute("class", "hide");

	el.onchange = function(e){
		var reader = new FileReader();
		reader.onload = () => func(reader.result);
		reader.readAsText(e.target.files[0]);
	};
	el.click();
}


function saveSceneAsFile(params = {projectTitle: "scene_backup"}){
	var data = {
		scene: Scene.toObject(),
		creator: Creator.toObject(),
		paints: Paints.toObject(),
		type: 2500
	};

	saveFile(params.projectTitle, JSON.stringify(data));
}

function saveSceneAsTask(fileName = "default_task"){
	var result = {};

	if(Scene.getTaskObject(result)){
		var data = {
			scene: result.content,
			results:  result.results,
			title: fileName,
			type: 2501
		};
		saveFile(fileName, JSON.stringify(data));
	}
	else{
		Logger.error(getMessage(MSG_FILE_SAVE_ERROR, result.error));
	}
}

function loadTask(scene, results, title){
	if(Task){
		return Logger.error(getMessage(MSG_TASK_EXIST));
	}

	var layer = Scene.createLayer(title, "task");
	each(scene, e => {
		e.layer = layer.title;
		Creator.create(e);
	});
	Task = new TaskManager(results, title, layer);
	Logger.write(getMessage(MSG_TASK_CREATED, title));
}

function loadSceneFromFile(){
	loadFile(function(content){
		//try{
		var data = JSON.parse(content);
		if(data.type && data.type === 2501){
			loadTask(data.scene, data.results, data.title);
		}
		else{
			Scene.fromObject(data.scene);
			Creator.fromObject(data.creator);
			Paints.fromObject(data.paints);
		}
		draw();
		/*
		 }
		 catch(err){
		 Logger.error("nepodarilo sa načítať súbor s dôvodu: ", err);
		 }
		 */
	});
}
/*
	compatible: 14.9.2016
*/
class OptionsManager{
	constructor(){
		this._options = {
			snapping: {
				id: "idAllowedSnapping",
				attr: "value",
				val: 0 //0, 30, 45, 90
			},
			grid: {
				id: "idShowGrid",
				attr: "checked",
				val: OPTION_SHOW_GRID
			},
			showLayersViewer: {
				id: "idShowLayersViewer",
				attr: "checked",
				val: OPTION_SHOW_LAYERS_VIEWER
			},
			shadows: {
				id: "idShadows",
				attr: "checked",
				val: OPTION_SHOW_SHADOWS
			},
			movingSilhouette: {
				id: "idMovingSilhouette",
				attr: "checked",
				val: OPTION_MOVING_SILHOUETTE
			},
			changeCursor: {
				id: "idChangeCursor",
				attr: "checked",
				val: OPTION_CHANGE_CURSOR
			},
			canvasBlur: {
				id: "idCanvasBlur",
				attr: "checked",
				val: OPTION_CANVAS_BLUR
			}
		};
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}
	_processAndSetValueIfExistById(id, val, attr, value){
		var e = document.getElementById(id);
		if(e){
			e[attr] = value;
			e.onchange = ee => this.setOpt(val, ee.target[attr], false);
		}
	}

	init(){
		each(this._options, (e, i) => this._processAndSetValueIfExistById(e.id, i, e.attr, e.val));
	}

	get showKeys(){return OPTION_SHOW_KEYS;}
	get showClicks(){return OPTION_SHOW_CLICKS;}
	get grid(){return this._options.grid.val;}
	get shadows(){return this._options.shadows.val;}
	get snapping(){return this._options.snapping.val;}
	get canvasBlur(){return this._options.canvasBlur.val;}
	get changeCursor(){return this._options.changeCursor.val;}
	get showLayersViewer(){return this._options.showLayersViewer.val;}
	get movingSilhouette(){return this._options.movingSilhouette.val;}


	setOpt(key, val, setElement = true){
		var obj = this._options[key];
		if(setElement){
			var e = document.getElementById(obj.id);
			if(e){
				e[obj.attr] = val;
			}
		}

		if(key === "showLayersViewer"){
			Entity.setAttr(Layers, "visible", val);
		}
		
		Logger.log(getMessage(MSG_OPTION_CHANGE, key, val), LOGGER_CHANGE_OPTION);
		obj.val = val;
		draw();
	}
}
/*
	compatible: bind, eventTarget, hashChange, touchEvents 14.9.2016
*/

class InputManager{
	constructor(){
		this._hist			= {};
		this._keys			= [];
		this._timer			= false;
		this._buttons		= [];
		this._mousePos		= new GVector2f();
		this._lastTouch		= false;
		this._pressPosition = new GVector2f();
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	get mousePos(){return this._mousePos;}

	_onResize(){
		//initCanvasSize();
		if(window.innerWidth < LIMIT_MIN_SCREEN_WIDTH){
			Logger.error(getMessage(MSG_MIN_SCREEN_WIDTH, LIMIT_MIN_SCREEN_WIDTH));
			return;
		}
		Project.content.onResize();
		
		Project.canvasManager.onResize();
		Scene.onScreenResize();

		if(isDefined(timeLine)){
			timeLine.onScreenResize();
		}

		if(isDefined(Layers)){
			Layers.onScreenResize();
		}

		draw();
	}

	_initWindowListeners(){
		window.onresize = this._onResize;
		if(STORE_DATA_ONUNLOAD){
			window.onunload = function(event){
				if(Scene.isEmpty()){
					localStorage.removeItem(RESTORE_KEY);
					return;
				}
				var result = {
					scene: Scene.toObject(),
					creator: Creator.toObject(),
					paint: Paints.toObject()
				};
				localStorage.setItem(RESTORE_KEY, JSON.stringify(result));
			};
		}
		window.orientationchange = this._onResize;
		if(ASK_BEFORE_UNLOAD){
			window.onbeforeunload= function(event){
				event.returnValue = getMessage(MSG_BEFORE_ONLOAD_TEXT);
			};
		}
		window.onhashchange = Project.listeners.hashChange;
		
		window.onkeydown = e => {
			this._keyDown(e.keyCode);

			if(!e.target.onkeyup){
				e.target.onkeyup = e => {
					this._keyUp(e.keyCode);
					e.target.onkeyup = false;
				};
			}
		};

		//window.addEventListener('orientationchange', initCanvasSize, false)
	}

	initListeners(target){
		this._initWindowListeners();

		target.onclick = function(){draw();};
		target.onmouseleave = e => {
			this._allButtonsUp();
			Project.listeners.mouseLeave(new GVector2f(e.offsetX, e.offsetY));
		};
		target.onmousepress = function(e){
			return Project.listeners.mousePress(e.position.getClone(), e.button);
		};

		target.ondblclick = function(e){
			Project.listeners.mouseDoubleClick(new GVector2f(e.offsetX, e.offsetY), e.button);
		};

		target.onmousedown = e => {
			this._buttonDown(e);
			Project.listeners.mouseDown(new GVector2f(e.offsetX, e.offsetY), e.button);

			e.target.onmouseup = ee => {

				if(!this.isButtonDown(ee.button)){
					return  false;
				}
				this._buttonUp(ee);

				if(!Options.changeCursor){
					ee.target.onmousemove = false;
				}
				ee.target.onmouseup = false;

				Project.listeners.mouseUp(new GVector2f(ee.offsetX, ee.offsetY), ee.button);
			};
			e.target.onmousemove = ee => {
				this._mouseMove(ee);
				Project.listeners.mouseMove(new GVector2f(ee.offsetX, ee.offsetY), 
											ee.movementX, 
											ee.movementY);
			};
		};

		target.oncontextmenu = () => false;


		target.addEventListener("touchstart", e => {
			e.preventDefault();
			this._lastTouch = glob.getMousePos(target, e);
			Input._buttonDown({button: LEFT_BUTTON, offsetX: this._lastTouch.x, offsetY: this._lastTouch.y});

			Project.listeners.mouseDown(new GVector2f(this._lastTouch.x, this._lastTouch.y), LEFT_BUTTON);
			
			e.target.addEventListener("touchmove", ee => {
				ee.preventDefault();
				Input._mouseMove({offsetX: this._lastTouch.x, offsetY: this._lastTouch.y});
				var mov = glob.getMousePos(target, ee);
				mov.x -=  this._lastTouch.x;
				mov.y -=  this._lastTouch.y;
				this._lastTouch = glob.getMousePos(target, ee);
				Project.listeners.mouseMove(new GVector2f(this._lastTouch.x, this._lastTouch.y), 
											mov.x, 
											mov.y);
				draw();
			}, false);


			e.target.addEventListener("touchend", (ee) => {
				ee.preventDefault();
				if(!Input.isButtonDown(LEFT_BUTTON)){
					return false;
				}
				Input._buttonUp({
					button: LEFT_BUTTON, 
					offsetX: this._lastTouch.x, 
					offsetY: this._lastTouch.y
				});
				Project.listeners.mouseUp(new GVector2f(this._lastTouch.x, this._lastTouch.y), LEFT_BUTTON);
				draw();
			}, false);

			e.target.addEventListener("touchcancel", (ee) => {
				ee.preventDefault();
				if(!Input.isButtonDown(LEFT_BUTTON)){
					return false;
				}
				Input._buttonUp({
					button: LEFT_BUTTON, 
					offsetX: this._lastTouch.x, 
					offsetY: this._lastTouch.y
				});
				Project.listeners.mouseUp(new GVector2f(this._lastTouch.x, this._lastTouch.y), LEFT_BUTTON);
				draw();
			}, false);
		}, false);
	}

	_keyDown(val){
		this._keys[val] = true;
		Events.keyDown(val);
		Project.listeners.keyDown(val, this.isKeyDown(KEY_L_CTRL));
	}

	_keyUp(val){
		this._keys[val] = false;
		Events.keyUp(val);
		Project.listeners.keyUp(val, this.isKeyDown(KEY_L_CTRL));

		if(!this._hist[val]){
			this._hist[val] = 0;
		}

		this._hist[val]++;
	}

	isKeyDown(val){
		return this._keys[val];
	}

	_checkPress(button){
		if(SelectedText){
			return;
		}
		this._buttons[button] = false;
		canvas.onmousepress({
			position: this._pressPosition,
			button: button
		});
		Logger.log("podržané tlačítko myši ::" + button + "::" + this._pressPosition.x + "::"+ this._pressPosition.y, LOGGER_MOUSE_EVENT);

		if(this._timer){//TODO čo je toto?? :D
			this._clearTimer();
		}
	}

	_clearTimer(){
		clearTimeout(this._timer);
		this._timer = false;
	}

	_mouseMove(val){
		this._mousePos.set(val.offsetX, val.offsetY);
		Events.mouseMove(val.offsetX, val.offsetY);

		if(this._timer){
			if(this._pressPosition.dist(val.offsetX, val.offsetY) > TOUCH_VARIATION){
				this._clearTimer();
			}
		}
	}

	_allButtonsUp(){
		for(var i in this._buttons){
			this._buttons[i] = false;
		}
	}


	_buttonDown(val){
		this._buttons[val.button] = true;
		Events.mouseDown(val.button, val.offsetX, val.offsetY);

		if (this._timer){
			this._clearTimer();
		}
		this._timer = setTimeout(() => this._checkPress(val.button), TOUCH_DURATION);
		this._pressPosition.set(val.offsetX, val.offsetY);
	}

	_buttonUp(val){
		if (this._timer){
			this._clearTimer();
		}
		this._buttons[val.button] = false;
		Events.mouseUp(val.button, val.offsetX, val.offsetY);
	}

	isButtonDown(val){
		return this._buttons[val];
	}
}

/**
 * Created by gabriel on 27.12.2016.
 */

const POINTER_CANVAS    = "pointerCanvas";
const CANVAS_PREFIX     = "canvas";
const MAIN_CANVAS       = "mainCanvas";

class CanvasManager{
    constructor(sizeX, sizeY){

        this._sizeX = sizeX;
        this._sizeY = sizeY;
        this._canvases = {};
        this._canvases[MAIN_CANVAS] = new CanvasHandler("myCanvas", sizeX, sizeY);
        this._canvasCounter = 1;

        this._canvases[POINTER_CANVAS] = new CanvasHandler("pointerCanvas", sizeX, sizeY);
        this._canvasCounter++;
        
        Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
    }

    onResize(){
        this._canvases[MAIN_CANVAS].setCanvasSize();
        if(this._canvases[POINTER_CANVAS]){
            this._canvases[POINTER_CANVAS].setCanvasSize();
        }
    }

    get canvas(){
        return this._canvases[MAIN_CANVAS];
    }

    get pCanvas(){
        return this._canvases[POINTER_CANVAS];
    }

    createCanvas(sizeX, sizeY, title){
        title = title || CANVAS_PREFIX + this._canvasCounter;
        this._canvases[title] = new CanvasHandler(sizeX, sizeY);
        this._canvasCounter++;
        return this._canvases[title];
    }

    getCanvas(title){
       return this._canvases[title];
    }

    removeCanvas(title){
        if(this._canvases[title]){
            delete this._canvases[title];
        }
    }
}


glob.drawGrid = function(width = GRID_WIDTH, dist = GRID_DIST, nthBold = GRID_NTH_BOLD, c = GRID_COLOR){
    var pointsNormal = [],
        pointsBold = [],
        boldCounter = 0,
        i;

    //vertikálne čiary
    for(i=0 ; i<canvas.width ; i+=dist){
        if(boldCounter++ % nthBold){
            pointsNormal[pointsNormal.length] = [i, 0, i, canvas.height];
        }
        else{
            pointsBold[pointsBold.length] = [i, 0, i, canvas.height];
        }
    }
    boldCounter = 0;
    //horizontálne čiary
    for(i=0 ; i<canvas.height ; i+=dist){
        if(boldCounter++ % nthBold){
            pointsNormal[pointsNormal.length] = [0, i, canvas.width, i];
        }
        else{
            pointsBold[pointsBold.length] = [0, i, canvas.width, i];
        }
    }

    //vykreslenie normálnych čiar
    doLine({
        points: pointsNormal,
        borderWidth: width,
        borderColor: c
    });

    //vykreslenie tučných čiar
    doLine({
        points: pointsBold,
        borderWidth: width * 3,
        borderColor: c
    });
};

function doPolygon(obj){
    if(isUndefined(obj.points)){
        Logger.error(getMessage(MSG_TRY_DRAW_EMPTY_POLYGON));
    }

    var res = G.extend(glob._initDef(obj), obj),
        offX = obj.offset ? obj.offset.x : 0,
        offY = obj.offset ? obj.offset.y : 0;


    res.ctx.beginPath();

    var drawLines = function(points){
        var size = points.length;

        if(res.radius === 0 || isNaN(res.radius)){
            each(points, (e, i) => {
                if(i){
                    res.ctx.lineTo(e.x + offX, e.y + offY);
                }
                else{
                    res.ctx.moveTo(e.x + offX, e.y + offY);
                }
            });
        }
        else{
            each(points, (e, i) => {
                var v1, l1,
                    v2 = e.getClone().sub(points[size - 1]),
                    l2 = v2.getLength();
                v2.div(l2);

                if (i === 0) {
                    v1 = points[i + 1].getClone().sub(e);
                    l1 = v1.getLength();

                    v1.div(l1);
                    if(isNumber(res.radius)){
                        l1 >>= 1;
                        l2 >>= 1;
                    }
                    else{
                        res.radius.replace("px", "");
                        l1 = l2 = 1;
                        res.radius = parseInt(res.radius);
                    }
                    res.ctx.moveTo(points[size - 1].x + v2.x * l2 * res.radius + offX, 
                                   points[size - 1].y + v2.y * l2 * res.radius + offY);
                    res.ctx.quadraticCurveTo(e.x + offX, 
                                             e.y + offY, 
                                             e.x + v1.x * l1 * res.radius + offX, 
                                             e.y + v1.y * l1 * res.radius + offY);
                }
                else{
                    v1 = points[(i + 1) % size].getClone().sub(e);
                    l1 = v1.getLength();
                    v1.div(l1);
                    if(isNumber(res.radius)){
                        l1 >>= 1;
                        l2 >>= 1;
                    }
                    else{
                        res.radius.replace("px", "");
                        l1 = l2 = 1;
                    }
                    res.ctx.lineTo(e.x - v2.x * l2 * res.radius + offX, 
                                   e.y - v2.y * l2 * res.radius + offY);
                    res.ctx.quadraticCurveTo(e.x + offX, 
                                             e.y + offY, 
                                             e.x + v1.x * l1 * res.radius + offX, 
                                             e.y + v1.y * l1 * res.radius + offY);
                }
            });
            res.ctx.closePath();
        }
    };
    
    isArray(res.points[0]) ? each(res.points, drawLines) : drawLines(res.points);

    _process(res);
}

function doArc(obj){
    var res = glob._remakePosAndSize(glob._checkPosAndSize(obj, "Arc"), obj);

    res.ctx.beginPath();
    if(typeof res.ctx.ellipse === "function"){
        res.ctx.ellipse(res.x + (res.width >> 1), 
                        res.y + (res.height >> 1), 
                        res.width >> 1, 
                        res.height >> 1, 
                        0, 
                        0, 
                        PI2);
    }
    else{
        res.ctx.rect(res.x + (res.width >> 1), 
                     res.y + (res.height >> 1), 
                     res.width >> 1, 
                     res.height >> 1);
    }

    _process(res);
}


function doRect(obj){
    var def = glob._checkPosAndSize(obj, OBJECT_RECT);

    if(isDefined(obj[ATTRIBUTE_RADIUS])){
        if(isNumber(obj[ATTRIBUTE_RADIUS])){
            obj[ATTRIBUTE_RADIUS] = {
                tl: obj[ATTRIBUTE_RADIUS],
                tr: obj[ATTRIBUTE_RADIUS],
                br: obj[ATTRIBUTE_RADIUS],
                bl: obj[ATTRIBUTE_RADIUS]};
        }
        else{
            each(def[ATTRIBUTE_RADIUS], (e, i) => obj[ATTRIBUTE_RADIUS][i] = obj[ATTRIBUTE_RADIUS][i] || def[ATTRIBUTE_RADIUS][i]);
        }
    }

    var res = glob._remakePosAndSize(def, obj);

    res.ctx.beginPath();
    res.ctx.moveTo(res.x + res[ATTRIBUTE_RADIUS].tl, 
                   res.y);
    res.ctx.lineTo(res.x + res.width - res[ATTRIBUTE_RADIUS].tr, 
                   res.y);
    res.ctx.quadraticCurveTo(res.x + res.width, 
                             res.y, 
                             res.x + res.width, 
                             res.y + res[ATTRIBUTE_RADIUS].tr);
    res.ctx.lineTo(res.x + res.width, 
                   res.y + res.height - res[ATTRIBUTE_RADIUS].br);
    res.ctx.quadraticCurveTo(res.x + res.width, 
                             res.y + res.height, 
                             res.x + res.width - res[ATTRIBUTE_RADIUS].br, 
                             res.y + res.height);
    res.ctx.lineTo(res.x + res[ATTRIBUTE_RADIUS].bl, 
                   res.y + res.height);
    res.ctx.quadraticCurveTo(res.x, 
                             res.y + res.height, 
                             res.x, 
                             res.y + res.height - res[ATTRIBUTE_RADIUS].bl);
    res.ctx.lineTo(res.x, 
                   res.y + res[ATTRIBUTE_RADIUS].tl);
    res.ctx.quadraticCurveTo(res.x, 
                             res.y, 
                             res.x + res[ATTRIBUTE_RADIUS].tl, 
                             res.y);
    res.ctx.closePath();

    _process(res);
}

function doLine(obj){
    if(isUndefined(obj.points)){
        Logger.error(getMessage(MSG_TRY_DRAW_EMPTY_LINE));
    }

    if(!isArray(obj.points[0]) && obj.points.length < 2){
        Logger.error(getMessage(MSG_TRY_DRAW_ONE_POINT_LINE));
    }

    var res = G.extend(glob._initDef(obj), obj),
        offX = obj.offset ? obj.offset.x : 0,
        offY = obj.offset ? obj.offset.y : 0,
        v1, v2, l1, l2;
    res.ctx.beginPath();


    var drawLines = function(points){
        if(isNaN(points[0])){
            if(res.radius === 0 || isNaN(res.radius)){
                each(points, (e, i) => {
                    if(i > 0){
                        res.ctx.lineTo(e.x + offX, e.y + offY);
                    }
                    else{
                        res.ctx.moveTo(e.x + offX, e.y + offY);
                    }
                });
            }
            else{
                each(points, (e, i) => {
                    if(i === 0){
                        res.ctx.moveTo(e.x, e.y);
                    }
                    else if(i + 1 < points.length){
                        v1 = points[i + 1].getClone().sub(e);
                        v2 = e.getClone().sub(points[i - 1]);
                        l1 = v1.getLength();
                        l2 = v2.getLength();
                        v2.div(l2);
                        v1.div(l1);
                        if(isNumber(res.radius)){
                            l1 >>= 1;
                            l2 >>= 1;
                        }
                        else{
                            res.radius.replace("px", "");
                            l1 = l2 = 1;
                        }
                        res.ctx.lineTo(e.x - v2.x * l2 * res.radius + offX, 
                                       e.y - v2.y * l2 * res.radius + offY);
                        res.ctx.quadraticCurveTo(e.x + offX, 
                                                 e.y + offY, 
                                                 e.x + v1.x * l1 * res.radius + offX, 
                                                 e.y + v1.y * l1 * res.radius + offY);
                    }
                    else{
                        res.ctx.lineTo(e.x + offX, e.y + offY);
                    }
                });
            }
        }
        else{
            res.ctx.moveTo(points[0] + offX, points[1] + offY);
            res.ctx.lineTo(points[2] + offX, points[3] + offY);
        }
    };
    isArray(res.points[0]) ? each(res.points, drawLines) : drawLines(res.points);

    res.fill = false;
    _process(res);
}
function drawQuadraticCurve(param){
    var points = param.points,
        borderWidth = param.borderWidth || DEFAULT_BORDER_WIDTH,
        borderColor = param.borderColor || DEFAUL_BORDER_COLOR,
        ctx = param.ctx || Project.context;
    if(points.length < 2){
        return;
    }

    ctx.lineWidth = borderWidth;
    ctx.strokeStyle = borderColor;
    ctx.beginPath();
    //points.forEach((e, i) => i === 0 ? ctx.moveTo(e.x, e.y) : ctx.quadraticCurveTo(e[0].x, e[0].y, e[1].x, e[1].y));
    each(points, (e, i) => {
        if(i === 0){
            ctx.moveTo(e.x, e.y);
        }
        else{
            ctx.quadraticCurveTo(e[0].x, e[0].y, e[1].x, e[1].y);
        }
    });
    ctx.stroke();
}

function fillText(text, x, y, size = DEFAULT_FONT_SIZE, color = DEFAULT_FONT_COLOR, offset = 0, align = FONT_ALIGN_NORMAL, ctx = context){
    ctx.font = size + "pt " + DEFAULT_FONT_FAMILY;
    ctx.fillStyle = color;

    if(align === FONT_ALIGN_NORMAL){
        ctx.textAlign = FONT_HALIGN_LEFT;
        ctx.textBaseline = FONT_VALIGN_TOP;
        if(isArray(offset)){
            ctx.fillText(text, x + offset[0], y + offset[1]);
        }
        else{
            ctx.fillText(text, x + offset, y + offset);
        }
    }
    else if(align === FONT_ALIGN_CENTER){
        ctx.textAlign = FONT_HALIGN_CENTER;
        ctx.textBaseline = FONT_VALIGN_MIDDLE;
        ctx.fillText(text, x, y);
    }
}

/*
 * UTILS
 */

glob.getMaxWidth = function(val, max = 0){
    if(isArray(val)){
        each(val, e => {
            if(isArray(e)){
                each(e, a => max = Math.max(calcTextWidth(a), max));
            }
            else{
                max = Math.max(calcTextWidth(e), max);
            }
        });
    }
    else{
        return calcTextWidth(val);
    }
    return max;
};

function setShadow(variable){
    if(variable){
        CanvasHandler.setShadow(context, 
                                DEFAULT_SHADOW_OFFSET, 
                                DEFAULT_SHADOW_OFFSET, 
                                "black", 
                                DEFAULT_SHADOW_BLUR);
    }
    else{
        CanvasHandler.setShadow(context, 0, 0, "black", 0);
    }
}


function setLineDash(variable){
    if(variable){
        CanvasHandler.setLineDash(context, 15, 5);
    }
    else{
        CanvasHandler.setLineDash(context, 1);
    }
}

/*
function canvasToImage(canvas) {
    return CanvasHandler.canvasToImage(canvas);
}
*/

/*
function imageToCanvas(image) {
    return CanvasHandler.imageToCanvas(image);
}
*/

function calcTextWidth(value, font = false){
    return CanvasHandler.calcTextWidth(context, value, font);
}

/*
 * PRIVATE
 */

glob._initDef = function(obj){
    var def = {
        borderWidth : DEFAULT_BORDER_WIDTH,
        borderColor : DEFAULT_BORDER_WIDTH,
        ctx : context,
        fillColor : DEFAULT_FILL_COLOR,
        radius : {tl: 0, tr: 0, br: 0, bl: 0},
        shadow: false,
        lineCap: LINE_CAP_BUTT,
        center: false,
        offset: null,
        joinType: LINE_JOIN_MITER,
        lineStyle: LINE_STYLE_NORMAL,
        lineType: JOIN_LINEAR,
        lineDash: [],
        bgImage: false
    };
    def.draw = isDefined(obj.borderColor) || isDefined(obj.borderWidth);
    def.fill = isDefined(obj.fillColor);

    return def;
};

glob._checkPosAndSize = function(obj, name){

    if((isUndefined(obj.x) || isUndefined(obj.y)) && isUndefined(obj.position)){
        Logger.error(getMessage(MSG_TRY_DRAW_WITHOUT_POSITION, name));
    }

    if((isUndefined(obj.width) || isUndefined(obj.height)) && isUndefined(obj.size)){
        Logger.error(getMessage(MSG_TRY_DRAW_WITHOUT_SIZE, name));
    }

    if(obj.width <= 0 || obj.height <= 0){
        Logger.error(getMessage(MSG_TRY_DRAW_WITH_NEG_POSITION, name));
    }

    return glob._initDef(obj);
};

glob._remakePosAndSize = function(def, obj){
    var res = G.extend(def, obj);

    if(isDefined(res.size)){
        if(isNumber(res.size)){
            res.width = res.size;
            res.height = res.size;
        }
        else if(isArray(res.size)){
            res.width = res.size[0];
            res.height = res.size[1];
        }
        else{
            res.width = res.size.x;
            res.height = res.size.y;
        }
    }

    if(isDefined(res.position)){
        if(isNumber(res.position)){
            res.x = res.position;
            res.y = res.position;
        }
        else if(isArray(res.position)){
            res.x = res.position[0];
            res.y = res.position[1];
        }
        else{
            res.x = res.position.x;
            res.y = res.position.y;
        }
    }

    if(res.center){
        res.x -= res.width >> 1;
        res.y -= res.height >> 1;
    }
    return res;
};

function _process(res){
    if(res.shadow && Options.shadows){
        setShadow(res.shadow);
    }

    if(res.bgImage){
        res.ctx.save();
        res.ctx.clip();
        if(res.bgImage instanceof HTMLImageElement){
            res.ctx.drawImage(res.bgImage, res.x, res.y, res.width, res.height);
        }
        else{
            res.ctx.drawImage(res.bgImage.img, 
                              res.bgImage.x, 
                              res.bgImage.y, 
                              res.bgImage.w, 
                              res.bgImage.h, 
                              res.x, 
                              res.y, 
                              res.width, 
                              res.height);
        }
        res.ctx.restore();
    }
    else if (res.fill){
        res.ctx.fillStyle = res.fillColor;
        res.ctx.fill();
    }

    if(res.shadow){
        setShadow(false);
    }

    res.ctx.lineCap = res.lineCap;
    res.ctx.lineJoin = res.joinType;
    if(typeof res.ctx.setLineDash === "function"){
        res.ctx.setLineDash(res.lineDash);
    }

    if (res.draw){
        res.ctx.lineWidth = res.borderWidth;
        res.ctx.strokeStyle = res.borderColor;
        res.ctx.stroke();
    }
}

/*
	compatible:	forEach, canvas, canvasText 14.9.2016
*/
class CanvasHandler{
	constructor(arg1, arg2, arg3){
		if(typeof arg1 === "string"){
			this._canvas = document.getElementById(arg1);
			if(arg2 && arg3){
				CanvasHandler.setCanvasSize(this._canvas, arg2, arg3);
			}
		}
		else if(arg1 instanceof HTMLImageElement){//ARGUMENT JE OBRAZOK
			this._canvas = CanvasHandler.imageToCanvas(arg1);
			CanvasHandler.setCanvasSize(this._canvas, arg1.width, arg1.height);	
		}
		else{
			this._canvas = document.createElement("canvas");

			if(arg1 && arg2){//ARGUMENTY SU VELKOST
				this.setCanvasSize(arg1, arg2);
			}
		}
		this._context = this._canvas.getContext("2d");
	}

	get canvas(){return this._canvas;}
	get context(){return this._context;}
	getImage(){return CanvasHandler.canvasToImage(this._canvas);}

	setShadow(x, y, color, blur){
		CanvasHandler.setShadow(this._context, x, y, color, blur);
	}

	show(format = "image/png"){
		window.open(this._canvas.toDataURL(format), '_blank');
	}

	clearCanvas(){
		CanvasHandler.clearCanvas(this._context);
	}

	setLineDash(... args){
		CanvasHandler.setLineDash(this._context, args);
	}

	setCanvasSize(width = window.innerWidth, height = window.innerHeight){
		CanvasHandler.setCanvasSize(this._canvas, width, height);
	}

	appendTo(element){
		element.appendChild(this._canvas);
	}

	static clearCanvas(ctx){
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	}

	static setCanvasSize(c, width, height){
		c.width = width;
		c.height = height;
	}

	static setShadow(ctx, x, y, color, blur){
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;
      ctx.shadowOffsetX = x;
      ctx.shadowOffsetY = y;
	}

	static imageToCanvas(image){
		var canvas = document.createElement("canvas");
		canvas.width = image.width;
		canvas.height = image.height;
		canvas.getContext("2d").drawImage(image, 0, 0);
		return canvas;
	}

	static setLineDash(ctx, ...args){
		//TODO otestovať;
		if(typeof ctx.setLineDash === "function"){
			ctx.setLineDash(args);
		}
	}

	static calcTextWidth(ctx, value, font = false){
		if(font){
			ctx.font = font;
		}
		return ctx.measureText(value).width;
	}

	static canvasToImage(canvas, format = "image/png"){
		var image = new Image();
		image.src = canvas.toDataURL(format);
		image.width = canvas.width;
		image.height = canvas.height;
		return image;
	}
}
/*
	compatible: classList 14.9.2016
*/
class ContentManager{
	constructor(){
		this._contentImage = null;
		this._contentHTML  = null;
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	onResize(){
		if(this._contentImage === null){
			return;
		}
		this._contentImage.width = window.innerWidth;
		this._contentImage.height = window.innerHeight;
	}

	setContentImage(src = false){
		if(this._contentImage === null){
			this._contentImage = document.getElementById("contentImage");
			this.onResize();
		}

		if(src){
			this._contentImage.src = src;
		}
		else{
			this._contentImage.src = "#";
			loadImage(img => this._contentImage.src = img.src);
		}

		this._contentImage.classList.remove("hide");
	}

	setContentHTML(){
		if(this._contentHTML === null){
			this._contentHTML = document.getElementById("contentHTML");
		}
		this._contentHTML.classList.remove("hide");
		loadFile(html => this._contentHTML.innerHTML = html);
	}

	hideContent(){
		if(this._contentImage !== null){
			this._contentImage.classList.add("hide");
		}
		if(this._contentHTML !== null){
			this._contentHTML.classList.add("hide");
		}
	}
}
/*
	compatible:	forEach 14.9.2016
*/
class ObjectsManager{
	constructor(){
		this._movedObject = false;
		this._objects = [];
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	get firstObject(){
		return this._objects[0];
	}

	size(){
		return this._objects.length;
	}

	get movedObject(){
		return this._movedObject;
	}

	set movedObject(val){
		this._movedObject = val;
	}

	onMouseMove(pos, movX, movY){
		selectedObjects.forEach(e => Movement.move(e, movX, movY));

		//ak objekt s ktorým sa hýbe nieje označený(už sa sním pohlo) tak sa sním tiež pohne
		if(!this._movedObject.selected){
			Movement.move(this._movedObject, movX, movY);
		}

		//ak sú nejaké objekty označené tak sa aktualizuje prehlad posledného označeného ináč iba hýbaného
		if(selectedObjects.size()){
			updateSelectedObjectView(selectedObjects.getLast());
		}
		else if(this._movedObject){
			updateSelectedObjectView(this._movedObject);
		}
	}

	deleteAll(){
		each(this._objects, Scene.remove);
	}

	selectAll(){
		Scene.forEach(this.add);
	}

	add(o){
		if((isDefined(o.locked) && o.locked) || !o || this._objects.indexOf(o) >= 0){
			return;
		}
		this._objects[this._objects.length] = o;

		o.selected = true;

		updateSelectedObjectView(o);
	}

	get(i){
		return this._objects.hasOwnProperty(i) ? this._objects[i] : false;
	}

	getLast(){
		return this._objects[this.size() - 1];
	}

	clear(){
		//this._objects.forEach(function(e){
		each(this._objects, e => {
			if(isDefined(e.moveType)){
				e.moveType = -1;
			}
			e.selected = false;
		});
		this._objects = [];
	}

	clearAndAdd(o){
		this.clear();
		this.add(o);
	}

	forEach(e){
		each(this._objects, e);
	}
}
/*
	compatible: 14.9.2016
*/

class Layer{
	constructor(title, layerType = ""){
		this._objects 	= {};
		this._visible 	= true;
		this._title 	= title;
		this._paint 	= null;
		this._locked 	= false;
		this._drawPaint	= true;
		this._opacity	= 1;
		this._raster	= false;
		this._canvas	= null;
		this._forRemove = [];
		this._layerType = layerType;
	}

	setForRemove(el){
		this._forRemove[this._forRemove.length] = el;
	}

	removeElements(){
		each(this._forRemove, e => Project.scene.remove(e));
		this._forRemove = [];
	}
	
	get locked(){return this._locked /*&& this._layerType === ""*/;}
	get taskLayer(){return this._layerType === LAYER_TASK;}
	get guiLayer(){return this._layerType === LAYER_GUI;}
	get userLayer(){return this._layerType === LAYER_USER;}
	get drawPaint(){return this._drawPaint;}
	get layerType(){return this._layerType;}
	get visible(){return this._visible;}
	get objects(){return this._objects;}
	get raster(){return this._raster;}
	get title(){return this._title;}
	get paint(){
		if(isNull(this._paint)){
			this._paint = new Paint();
		}
		return this._paint;
	}

	isEmpty(){
		if(this._paint && !this._paint.isEmpty()){
			return false;
		}
		for(var i in this._objects){
			if(this._objects.hasOwnProperty(i)){
				return false;
			}
		}
		return true;
	}

	set drawPaint(val){this._drawPaint = val;}
	set visible(val){this._visible = val;}
	set objects(val){this._objects = val;}
	set title(val){this._title = val;}
	set locked(val){
		this._locked = val === true ? true : false;
	}

	cleanUp(){
		this.forEach(e => callIfFunc(e.cleanUp));
		this._objects = {};
		Paints.cleanUp(this._title);
		Events.layerCleanUp(this._title);
		Logger.log(getMessage(MSG_OBJECT_CLEANED, this.constructor.name), LOGGER_OBJECT_CLEANED);
	}

	rename(title){
		Events.layerRename(this._title, title);
		this._title = title;
	}

	makeRaster(){
		this._raster = true;
		//TODO pri rastrovaní vrstvy nakresliť všetko do canvasu
	}
	


	getObject(id){
		return this._objects[id];
	}

	draw(ctx = context){
		if(!this.visible){
			return;
		}

		this.forEach(e => e.visible && e.draw(ctx));

		if(this._drawPaint){
			this.paint.draw(ctx);
		}
	}

	add(element){
		this._objects[element.id] = element;
	}

	remove(element){
		delete this._objects[element.id];
	}

	forEach(func){
		each(this._objects, func);
	}
}
/*
	compatible:	forEach, JSON parsing 14.9.2016
*/	
class SceneManager{
	constructor(){
		this._clickViewers 	= [];
		this._layers 		= {};
		this._secondCanvas 	= null;
		this._layersCount 	= 0;
		this._creator 		= new objectCreator();
		this._objectManager = new ObjectsManager();

		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	isEmpty(){
		for(var i in this._layers){
			if(this._layers.hasOwnProperty(i) && !this._layers[i].isEmpty()){
				return false;
			}
		}
		return true;
	}

	mouseUp(x, y){
		var counter = 0;
		var viewer = new Arc(new GVector2f(x, y), new GVector2f());
		Entity.changeAttr(viewer, {
			"fill" : false,
			"borderColor" : CLICK_COLOR
		});
		this._clickViewers[this._clickViewers.length] = viewer;
		var interval = setInterval(() => {
			viewer.position.sub(CLICK_SPEED);
			viewer.size.add(CLICK_SPEED * 2);
			if(++counter == CLICK_LIMIT){
				this._clickViewers.splice(this._clickViewers.indexOf(viewer), 1);
				clearInterval(interval);
				pdraw();
			}
			pdraw();
		}, 1000 / FPS);
	}
	mouseDown(x, y){
		var counter = 0;
		var viewer = new Arc(new GVector2f(x, y).sub(CLICK_SPEED*CLICK_LIMIT), 
							 new GVector2f(CLICK_SPEED * 2 * CLICK_LIMIT));
		Entity.changeAttr(viewer, {
			"fill" : false,
			"borderColor" : CLICK_COLOR
		});
		this._clickViewers[this._clickViewers.length] = viewer;
		var interval = setInterval(() => {
			viewer.position.add(CLICK_SPEED);
			viewer.size.sub(CLICK_SPEED * 2);
			if(++counter == CLICK_LIMIT){
				this._clickViewers.splice(this._clickViewers.indexOf(viewer), 1);
				clearInterval(interval);
				pdraw();
			}
			pdraw();
		}, 1000 / FPS);
	}

	initSecondCanvas(){
		this._secondCanvas = new CanvasHandler();
	}

	get creator(){return this._creator;}
	get objectManager(){return this._objectManager;}

	forEach(func){
		each(this._layers, e => e.visible && e.forEach(func));
	}

	cleanUp(){
		each(this._layers, e => {
			e.cleanUp();
			if(e.title !== PROJECT_LAYER_TITLE){
				this.deleteLayer(e.title);
			}
		});

		Events.sceneCleanUp();
		Logger.log(getMessage(MSG_OBJECT_CLEANED, this.constructor.name), LOGGER_OBJECT_CLEANED);
		
	}

	onScreenResize(){
		each(this._layers, e => e.paint.onScreenResize());
	}

	createLayer(title = PROJECT_LAYER_TITLE, layerType = ""){
		if(this._layers.hasOwnProperty(title)){
			Logger.error(getMessage(MSG_RECREATE_LAYER, title));
			return null;
		}
		if(this.layersNumber == LIMIT_MAXIMUM_LAYERS){
			Logger.error(getMessage(MSG_MAXIMUM_LAYER, LIMIT_MAXIMUM_LAYERS));
			return null;
		}
		this._layers[title] = new Layer(title, layerType);
		this._layersCount++;


		if(isDefined(Layers)){
			Layers.createLayer(this._layers[title]);
		}

		Events.layerCreate(title, layerType);
		return this._layers[title];
	}

	getLayer(layer){
		return this._layers[layer];
	}

	renameLayer(oldTitle, newTitle){
		if(this._layers[oldTitle] && !this._layers[newTitle]){
			this._layers[newTitle] = this._layers[oldTitle];
			delete this._layers[oldTitle];
			this._layers[newTitle].rename(newTitle);
		}
		
	}

	deleteLayer(title){
		if(!this._layers.hasOwnProperty(title)){
			Logger.error(getMessage(MSG_TRY_DELETE_ABSENT_LAYER, title));
		}

		if(this._layers[title].guiLayer){
			Logger.write(getMessage(MSG_TRY_DELETE_GUI_LAYER));
			return false;
		}

		this._layers[title].cleanUp();
		delete this._layers[title];

		this._layersCount--;

		if(isDefined(Layers)){
			Layers.deleteLayer(title);
		}

		Events.layerDelete(title);
	}

	changeLayer(object, newLayer){
		var layer = Project.scene.getLayer(newLayer);
		if(layer){
			var oldLayer = object.layer;
			layer.add(object);
			Entity.changeAttr(object, "layer", newLayer);
			Project.scene.getLayer(oldLayer).remove(object);
		}
	}

	getTaskObject(data){
		//var findAssignment = false;

		data.error = data.error === "" ? data.error : "";
		data.results = isEmptyObject(data.results) ? data.results : {};
		data.content = isEmptyArray(data.content) ? data.content : [];

		each(this.layers, function(e, i){
			if(e.visible){
				e.forEach(function(e){
					if(e === Layers){
						return;
					}
					if(e.visible){
						if(e.name === OBJECT_TEXT){
							if(e.text === ""){
								return;
							}
							if(e.taskResult){
								data.results[e.id] = e.text;
								e.text = "";
								for(var i in data.results[e.id]){
									e.text += " ";
								}
							}
						}
						data.content[data.content.length] = e;
					}
				});
			}
		});

		//TODO treba nejako posielať zadanie
		var findAssignment = true;

		//preloopuje vrstvy
			//preskočí neviditelne
			//preloopuje objekty
				//preskočí neviditelne

				//ak je textInput
					//ak je prazdny tak vymaže

					//ak nie tak podla do resultov pridá podla idečtka texfieldu spravny vysledok
					//vymaže obsah
				
				//pridá to scene
		if(isEmptyObject(data.results)){
			data.error += getMessage(MSG_MISSING_RESULT_TEXT);
		}

		return data.error === "" && findAssignment;
	}

	addToScene(object, layer = Layers.activeLayerName, resend = true){
		if(!this._layers.hasOwnProperty(layer)){
			Logger.error(getMessage(MSG_ADD_OBJECT_TO_ABSENT_LAYER, layer));
		}

		object.layer = layer;
		this._layers[layer].add(object);

		Events.objectAdded(resend, object);

		if(!resend){
			object.selected = false;
		}

		draw();
	}

	findObjectsForRemove(x, y, radius){
		//TODO bud aktualna ale všetky vrstvy, podla Creator.allLayers
		each(Project.scene.layers, function(layer){
			layer.forEach(object => {
				if(isFunction(object.isIn)){
					if(object.isIn(x, y, radius)){
						layer.setForRemove(object);
					}
				}
			});
			layer.removeElements();
		});
	}

	get layers(){return this._layers;}
	get paint(){return Layers.activeLayer.paint;}
	get layersNumber(){return this._layersCount;}
	get secondCanvas(){return this._secondCanvas;}

	getObject(layer, id){
		return this._layers[layer].getObject(id);
	}

	pdraw(ctx){
		for(var i=0 ; i<this._clickViewers.length ; i++){
			this._clickViewers[i].draw(ctx);
		}
	}

	draw(){
		each(this._layers, e => e.draw());
		/*
		for(var i=0 ; i<this._clickViewers.length ; i++){
			this._clickViewers[i].draw();
		}
		*/
	}


	remove(obj, layer = obj.layer, resend = true){
		this._layers[layer].remove(obj);
		Events.objectDeleted(resend, obj);

	}


	toString(){
		return JSON.stringify(this.toObject());
	}

	fromObject(content){
		each(content, Creator.create);
	}

	fromObjectToSingleLayer(layer, content){
		each(content, e => {
			e._layer = layer;
			Creator.create(e);
		});
	}

	toObject(){
		var result = [];
		each(this._layers, e => e.forEach(function(ee){//pre každu vrstvu prejde všetkými objektami
			if(ee.name != "LayerViewer"){
				result[result.length] = ee;
			}
		}));
		return result;
	}
}
/*
	compatible:  14.9.2016
*/
class EventManager{
	constructor(){
		this._history = [];
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	paintAddPoint(position, activeLayerName){//PaintManager.addPoint
		if(Project.connection){
			Project.connection.paint.addPoint(position, activeLayerName);
		}
	}
	paintAddPath(activeLayerName, path){//PaintManager.breakLine
		//if(Project.connection && path)
		//	Project.connection.paint.addPath(activeLayerName, path);
	}

	paintBreakLine(activeLayerName){//PaintManager.breakLine
		if(Project.connection){
			Project.connection.paint.breakLine(activeLayerName);
		}

		Logger.log("bola ukončená čiara vo vrstve " + activeLayerName, LOGGER_PAINT_ACTION);
	}

	paintCleanUp(activeLayerName){//PaintManager.cleanUp
		if(Project.connection){
			Project.connection.paint.clean(activeLayerName);
		}

		Logger.log("Bol vyčistený objekt " + this.constructor.name, LOGGER_OBJECT_CLEANED);
	}

	paintBrushChange(size, color, imageTitle){//PaintManager
		Logger.log("Bol prekreslený štetec " + size + ", " + color + ", " + imageTitle, LOGGER_PAINT_HISTORY);
	}

	paintUndo(layer){//PaintManager
		Logger.log("bolo zavolane undo na vrstvu " + layer, LOGGER_PAINT_HISTORY);
	}

	paintRedo(layer){//PaintManager
		Logger.log("bolo zavolane redo na vrstvu " + layer, LOGGER_PAINT_HISTORY);
	}

	layerCreate(title, type){//Scene.createLayer
		if(Project.connection){
			Project.connection.layer.create(title, type);
		}
		Logger.log("Vytvorila sa vrstva: " + title + "typu: " + type, LOGGER_LAYER_CHANGE);
	}

	layerDelete(title){//Scene
		if(Project.connection){
			Project.connection.layer.delete(title);
		}
		Logger.log("Vymazala sa vrstva: " + title, LOGGER_LAYER_CHANGE);
	}

	layerRaster(title){//Scene.makeRaster
		Logger.log("vrstva " + title + " bola rastrovaná", LOGGER_LAYER_RASTERED);
	}

	layerCleanUp(title){//Layer.cleanUp
		if(Project.connection){
			Project.connection.layer.clean(title);
		}
		Logger.log("Bola vyčistená vrstva: " + title, LOGGER_LAYER_CLEANED);
	}
	layerRename(oldTitle, newTitle){//Layer.rename
		if(Project.connection){
			Project.connection.layer.rename(oldTitle, newTitle);
		}
		Logger.log("Bola premenovaná vrstva: " + oldTitle + " na " + newTitle, LOGGER_LAYER_RENAMED);
	}

	creatorChange(key, val){//Creator.setOpt
		if(Project.connection){
			Project.connection.creatorChange(key, val);
		}

		Logger.log("Creatorovi sa nastavuje " + key + " na " + val, LOGGER_CREATOR_CHANGE);
	}

	objectAdded(resend, object){//Scene.addToScene
		if(resend && Project.connection){
			Project.connection.object.create(object);
		}
		Logger.log("Vytvára sa objekt ", LOGGER_OBJECT_CREATED);
	}

	objectChange(object, attribute){//Entity.setAttr
		if(Project.connection){
			Project.connection.object.change(object, attribute);
		}
	}

	objectDeleted(resend, object){//Scene.remove
		if(resend && Project.connection){
			Project.connection.object.delete(object);
		}
	}

	objectMove(object){//Utils.Movement.move

		if(Project.connection){
			Project.connection.object.move(object);
		}
	}

	sceneCleanUp(){//Scene.cleanUp

	}

	loadScene(){//Scene

	}

	keyDown(key){
		if(Project.connection){
			Project.connection.input.keyDown(key);
		}
		Logger.log("stlačené klavesa " + key, LOGGER_KEY_EVENT);
	}
	keyUp(key){
		if(Project.connection){
			Project.connection.input.keyUp(key);
		}
		Logger.log("pustená klavesa " + key, LOGGER_KEY_EVENT);
	}

	mouseMove(x, y){//Input._mouseMove
		if(isSharing()){
			Sharer.mouseChange(x, y);
		}
	}
	mouseDown(key, x, y){//Input._buttonDown
		Logger.log("stlačené tlačítko myši ::" + key + "::" + x + "::"+ y, LOGGER_MOUSE_EVENT);

		if(isSharing()){
			Sharer.mouseChange(key);
		}
	}
	mouseUp(key, x, y){//Input._buttonUp
		Logger.log("pustené tlačítko myši ::" + key + "::" + x + "::"+ y, LOGGER_MOUSE_EVENT);
		if(isSharing()){
			Sharer.mouseChange(key);
		}
	}
}
/**
 * Created by Gabriel on 29. 10. 2016.
 */

class ConnectionManager{
	constructor(){
		this._socket 			= false;
		this._user_id 			= false;
		this._user_name 		= PROJECT_AUTHOR;
		this._connectedUsers 	= {};
		this._sharing 			= false;
		this._sender 			= new EventTimer(e => this._sendStack(), CONNECTION_LOOP_TIME);
		this._buffer 			= [];

		this.paint = {
			addPoint 	: (pos, layer)	=> this._paintAction(ACTION_PAINT_ADD_POINT, pos, layer),
			breakLine 	: (layer)		=> this._paintAction(ACTION_PAINT_BREAK_LINE, layer),
			clean 		: (layer)		=> this._paintAction(ACTION_PAINT_CLEAN, layer),
			addPath 	: (layer, path) => this._paintAction(ACTION_PAINT_ADD_PATH, layer, path)
		};
		this.object = {
			move 		: (obj)			=> this._objectAction(ACTION_OBJECT_MOVE, obj),
			change 		: (obj, keys)	=> this._objectAction(ACTION_OBJECT_CHANGE, obj, keys),
			delete 		: (obj)			=> this._objectAction(ACTION_OBJECT_DELETE, obj),
			create 		: (obj)			=> this._objectAction(ACTION_OBJECT_CREATE, obj)
		};
		this.input = {
			mouseMove 	: (dir, pos) 	=> this._inputAction(ACTION_MOUSE_MOVE, dir, pos),
			mouseDown 	: (key, pos) 	=> this._inputAction(ACTION_MOUSE_DOWN, key, pos),
			mouseUp 	: (key, pos)	=> this._inputAction(ACTION_MOUSE_UP, key, pos),
			keyDown 	: (key) 		=> this._inputAction(ACTION_KEY_DOWN, key),
			keyUp 		: (key) 		=> this._inputAction(ACTION_KEY_UP, key)
		};
		this.layer = {
			create 		: (title, type) => this._layerAction(ACTION_LAYER_CREATE, title, type),
			delete 		: (title) 		=> this._layerAction(ACTION_LAYER_DELETE, title),
			clean 		: (title) 		=> this._layerAction(ACTION_LAYER_CLEAN, title),
			visible 	: (title, val) 	=> this._layerAction(ACTION_LAYER_VISIBLE, val),
			rename 		: (title, val) 	=> this._layerAction(ACTION_LAYER_RENAME, val)
		};

		$.post("/create", {content: JSON.stringify({meno:PROJECT_AUTHOR})}, data => {
			this._user_id = data.cookies[CONN_KEY_USER_ID];
		}, "json");

		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	/*********************
	 * INITIALIZATIONS
	 ********************/
	startShare(data){
		data[CONN_KEY_TYPE] = CONN_KEY_SHARE;
		this.connect(data);
	}

	startTeach(data){
		data[CONN_KEY_TYPE] = CONN_KEY_TEACH;
		this.connect(data);
	}

	startWatch(data){
		data[CONN_KEY_TYPE] = CONN_KEY_WATCH;

		if(isUndefined(data[CONN_KEY_LESS_ID])){
			Logger.error(getMessage(MSG_MISS_LESS_ID));
			return false;
		}

		this.connect(data);
	}

	startExercise(data){
		data[CONN_KEY_TYPE] = CONN_KEY_EXERCISE;

		if(isUndefined(data[CONN_KEY_LESS_ID])){
			Logger.error(getMessage(MSG_MISS_LESS_ID));
			return false;
		}

		this.connect(data);
	}

	connect(data){
		this._socket = io(URL_CHAT);
		this._startTime = Date.now();
		this._type = data[CONN_KEY_TYPE];
		this._user_name = data[CONN_KEY_USER_NAME] || this._user_name;
		data.resolution = window.innerWidth + "_" + window.innerHeight;
		//var inst = this;
		this.resetLives();

		this._sharePaints		= data.sharePaints;
		this._shareInput		= data.shareInput;
		this._shareCreator		= data.shareCreator;
		this._shareLayers		= data.shareLayers;
		this._shareObjects		= data.shareObjects;
		this._maximalWatchers	= data.maxWatchers;

		this._socket.on("connect_failed", function(){
			Logger.error(getMessage(MSG_CONN_FAILED));
		});

		this._socket.on("connect_error", () => {
			this._lives === CONNECTION_TRIES && Logger.error(getMessage(MSG_CONN_ERROR));
			this._lives--;
			if(this._lives === 0){
				this.disconnect();
			}
		});

		this._socket.on("reconnect", () => {
			this.resetLives();
			Logger.write(getMessage(MSG_CONN_RECONNECT));
		});


		this._socket.on('confirmConnection', response => {
			this._less_id = response[CONN_KEY_DATA][CONN_KEY_LESS_ID];
			this._connectTime = Date.now();
			this._messageTime = Date.now();
			if(this._type === CONN_KEY_WATCH || this._type === CONN_KEY_TEACH){
				if(this._type === CONN_KEY_WATCH){
					Scene.initSecondCanvas();
				}
				//this._sendMessage("requireAllData", {target: this._user_id});
				this._watching = true;
			}
			else{
				this._sharing = true;
			}


			//upraví menu a dá vedieť používatelovi
			Logger.write(getMessage(MSG_CONN_CONFIRM));
			if(isFunction(Menu.disabled)) {
				Menu.disabled("sharing", "watch");
				Menu.disabled("sharing", "stopShare");
				Menu.disabled("sharing", "shareOptions");
				Menu.disabled("sharing", "copyUrl");
				Menu.disabled("sharing", "startShare");
			}
		});

		this._socket.on('receivedBuffer', this._processStack);

		this._socket.on('errorLog', response => Logger.error(response.msg));

		this._socket.on("notifLog", response => Logger.write(response.msg));

		this._socket.emit("initConnection", data);
	}

	pdraw(ctx){
		if(this._mousePosition){
			doArc({
				x: this._mousePosition.posX,
				y: this._mousePosition.posY,
				fillColor: "rgba(255,0,0,0.1)",
				width: 40,
				height: 40,
				center: true,
				ctx: ctx
			});
		}
	}

	disconnect(){
		if(isFunction(Menu.disabled)){
			Menu.disabled("sharing", CONN_KEY_WATCH);
			Menu.disabled("sharing", "stopShare");
			Menu.disabled("sharing", "shareOptions");
			Menu.disabled("sharing", "copyUrl");
			Menu.disabled("sharing", "startShare");
		}
		this._socket.disconnect();
		this._user_id	= false;
		this._socket	= false;
		this._sharing	= false;
		this._watching	= false;
		Logger.write(getMessage(MSG_CONN_DISCONNECT));
		if(Project.panel){
			Project.panel.stopShare();
		}
	}

	/*********************
	 * MESSAGES
	 ********************/
	 _processInputAction(data){
	 	if(data.type === ACTION_MOUSE_MOVE){
	 		this._mousePosition = data.position;
	 	}
	 	else if(data.type === ACTION_KEY_DOWN){
	 		glob.showKey(data.key);
	 	}
	 }
	 
	_processStack(data){
		Logger.log("prijaty buffer po: " + (Date.now() - this._messageTime), LOGGER_STACK_RECIEVED);
		this._messageTime = Date.now();
	 	each(data.buffer, e => {
			//console.log("prijata akcia:" + e.action);
			switch(e.action){
				case "requireAllData" :
					Handler.processRequireAllData(this, e[CONN_KEY_DATA]);
					break;
				case "sendAllData" :
					Handler.processSendAllData(this, e[CONN_KEY_DATA]);
					break;
				case "userDisconnect" :
					Handler.processUserDisconnect(this, e[CONN_KEY_DATA]);
					break;
				case "userConnect" :
					Handler.processUserConnect(this, e[CONN_KEY_DATA]);
					break;
				case "paintAction" :
					Handler.processPaintAction(e[CONN_KEY_DATA], this._type);
					break;
				case "layerAction" :
					Handler.processLayerAction(e[CONN_KEY_DATA]);
					break;
				case "inputAction" :
					this._processInputAction(e[CONN_KEY_DATA]);
					break;
				case "creatorAction" :
					Creator.setOpt(e[CONN_KEY_DATA].key, e[CONN_KEY_DATA][CONN_KEY_VALUE]);
					draw();
					break;
				case "objectAction" :
					Handler.processObjectAction(e[CONN_KEY_DATA], this._type);
					break;
				default:
					Logger.error(getMessage(MSG_UNKNOW_ACTION, e.action));
			}
	 	});
	}

	_sendStack(){
		if(!this._socket || this._socket.disconnected){
			return;
		}
		if(this._buffer.length === 0){
			return false;
		}
		var result = {
			buffer: this._buffer, 
			user_id: this._user_id
		};
		if(this._less_id){
			result[CONN_KEY_LESS_ID] = this._less_id;
		}
		this._socket.emit("sendBuffer", result);
		this._buffer = [];
	}

	_sendMessage(action, data){
		this._buffer[this._buffer.length] = {action: action, time: Date.now(), data: data};
		this._sender.callIfCan();
	}

	/*********************
	 * UTILS
	 ********************/
	/*
	_draw(){
		var canvas = Scene.getSecondCanvas();
		if(!canvas)
			return;

		this._mouseData = data;
		this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
		doArc({
			x: this._mouseData.posX,
			y: this._mouseData.posY,
			fillColor: "rgba(255,0,0,0.1)",
			width: 40,
			height: 40,
			center: true,
			ctx: this._context
		})
	}
	*/
	/*********************
	 * ACTIONS
	 ********************/

	resetLives(){
		this._lives = CONNECTION_TRIES;
	}

	creatorChange(key, value){
		if(!this._socket || !this._shareCreator || this.watching){
			return;
		}

		var data = {
			key: key,
			value: value
		};
		this._sendMessage('creatorAction', data);
	}

	_layerAction(type, arg1, arg2){
		if(!this._socket || !this._shareLayers || this.watching){
			return;
		}
		var data = {
			action: type
		};

		switch(type){
			case ACTION_LAYER_CREATE :
				data[CONN_KEY_TITLE] = arg1;
				data[CONN_KEY_TYPE]	= arg2;
				break;
			case ACTION_LAYER_DELETE :
				data[CONN_KEY_TITLE] = arg1;
				break;
			case ACTION_LAYER_CLEAN :
				data[CONN_KEY_TITLE] = arg1;
				break;
			case ACTION_LAYER_VISIBLE :
				data[CONN_KEY_TITLE] = arg1;
				data[CONN_KEY_VALUE] = arg2;
				break;
			case ACTION_LAYER_RENAME :
				data[CONN_KEY_TITLE] = arg1;
				data[CONN_KEY_VALUE] = arg2;
				break;
		}

		this._sendMessage('layerAction', data);
	}

	_objectAction(type, object, keys){
		if(!this._socket || !this._shareObjects || this.watching){
			return;
		}
		var data = {
			action: type,
			user_name : this._user_name
		};
		switch(type){
			case ACTION_OBJECT_MOVE:
				data.oId	= object.id;
				data.oL	= object.layer;
				data.oX	= object.position.x;
				data.oY	= object.position.y;
				data.oW	= object.size.x;
				data.oH	= object.size.y;
				break;
			case ACTION_OBJECT_CHANGE:
				data.oId		= object.id;
				data.oL		= object.layer;
				data.keys	= {};
				each(keys, (e, i) => data.keys.i = object[i]);
				break;
			case ACTION_OBJECT_DELETE:
				data.oId	= object.id;
				data.oL	= object.layer;
				break;
			case ACTION_OBJECT_CREATE:
				data.o = object;
				break;
			default:
				Logger.error(type, 2);
				return;
		}
		this._sendMessage('objectAction', data);
	}

	/**
	 * @param type
	 * @param param1 key, direction
	 * @param param2 position
	 * @private
	 */
	_inputAction(type, param1, param2){
		if(!this._socket || !this._shareInput || this.watching){
			return false;
		}

		var data = {
			type: type
		};

		switch(type){
			case ACTION_KEY_DOWN :
				data.key = param1;
				break;
			case ACTION_KEY_UP :
				data.key = param1;
				break;
			case ACTION_MOUSE_DOWN :
				data.key = param1;
				data.position = param2;
				break;
			case ACTION_MOUSE_UP :
				data.key = param1;
				data.position = param2;
				break;
			case ACTION_MOUSE_MOVE :
				data.direction = param1;
				data.position = param2;
				break;
			default :
				Logger.error(type, 1);
		}
		this._sendMessage('inputAction', data);
	}

	_paintAction(type, arg1, arg2){
		if(!this._socket || !this._sharePaints || this.watching){
			return false;
		}

		var data = {
			action: type,
			user_name : this._user_name
		};
		switch(type){
			case ACTION_PAINT_ADD_POINT :
				data.pX = arg1.x;
				data.pY = arg1.y;
				data[CONN_KEY_LAYER] = arg2;
				break;
			case ACTION_PAINT_BREAK_LINE :
				data[CONN_KEY_LAYER] = arg1;
				break;
			case ACTION_PAINT_CLEAN :
				data[CONN_KEY_LAYER] = arg1;
				break;
			case ACTION_PAINT_ADD_PATH :
				data[CONN_KEY_LAYER] = arg1;
				data.path = arg2;
				break;
			case ACTION_PAINT_REMOVE_PATH :
				data[CONN_KEY_LAYER] = arg1;
				break;
			default:
				Logger.error(type, 3);
				return;
		}
		this._sendMessage('paintAction', data);
	}

	/*********************
	 * GETTERS
	 ********************/

	get userId(){
		return this._user_id;
	}

	get sharing(){
		return this._sharing;
	}
	get watching(){
		return this._watching;
	}
}

class Handler{
	static processUserDisconnect(inst, data){
		Logger.write(getMessage(MSG_USER_DISCONNECT, data[CONN_KEY_USER_NAME], data[CONN_KEY_USER_ID]));
		
		var user = inst._connectedUsers[data[CONN_KEY_USER_ID]];
		if(user){
			user.status = STATUS_DISCONNECTED;
			lastConnectionTime = Date.now();
		}
	}

	static processUserConnect(inst, data){
		inst._connectedUsers[data[CONN_KEY_USER_ID]] = {
			user_name : data[CONN_KEY_USER_NAME],
			status : STATUS_CONNECTED,
			connectTime : Date.now()
		};
		if(inst._type === CONN_KEY_TEACH){
			//Scene.createLayer(data[CONN_KEY_USER_NAME]);
			//inst._sendMessage("requireAllData", {target: inst._user_id, from: data[CONN_KEY_USER_ID]});
		}
		//Logger.write("používatel" + data[CONN_KEY_USER_NAME] + ". +ata[CONN_KEY_USER_ID] + "] sa pripojil");
		Logger.write(getMessage(MSG_USER_CONNECT, data[CONN_KEY_USER_NAME], data[CONN_KEY_USER_ID]));

		//draw();
	}

	static processRequireAllData(inst, data){
		//console.log("prijal som žiadosť o všetky udaje pre " + data[CONN_KEY_TARGET]);
		var result = {};
		if(inst._type === CONN_KEY_SHARE){
			result = {
				msg: {
					scene: Scene.toObject(),
					creator: Creator.toObject(),
					paint: Paints.toObject(),
					user_name : inst._user_name
				},
				target: data[CONN_KEY_TARGET]
			};
			//Project.panel.addWatcher(recData.nickName);
			inst._sendMessage('sendAllData',result);
		}
		else if(inst._type === CONN_KEY_EXERCISE){
			result = {
				msg: {
					scene: Scene.toObject(),
					paint: Paints.toObject(),
					user_name : inst._user_name
				},
				target: data[CONN_KEY_TARGET]
			};
			inst._sendMessage('sendAllData',result);
		}
	}

	static processSendAllData(inst, data){
		//console.log("prijal som všetky udaje ");
		if(inst._type == CONN_KEY_WATCH){//chce udaje všetko dostupné o 1 používatelovi
			var shareOptions = data.shareOptions;
			var watchOptions = data.watchOptions;

			if(shareOptions.share.objects){
				Scene.fromObject(data.scene);
			}
			if(shareOptions.share.creator){
				Creator.fromObject(data.creator);
			}
			if(shareOptions.share.paints){
				Paints.fromObject(data.paint);
			}


			if(watchOptions.show.chat){
				/*
				 chatViewer = new ChatViewer(Project.title + "'s chat", watchOptions.nickName, sendMessage);
				 chatViewer.show();
				 */
				if(Project.panel){
					Project.panel.startWatch(sendMessage);
				}
			}

			if(watchOptions.show.timeLine){
				timeLine = new TimeLine();
			}

			Project.autor = watchOptions.nickName;

			//console.log("nastavuje sa", data);
			Menu.visible = shareOptions.share.menu;
			Creator.visibleView = shareOptions.share.menu;
			Options.setOpt("showLayersViewer", shareOptions.share.layers);
		}
		else if(inst._type == CONN_KEY_TEACH){//volá sa pre každého pripojeného študenta
			if(Scene.getLayer(data[CONN_KEY_USER_NAME])){
				Scene.deleteLayer(data[CONN_KEY_USER_NAME]);
			}
			Scene.createLayer(data[CONN_KEY_USER_NAME], LAYER_USER);
			Scene.fromObjectToSingleLayer(data[CONN_KEY_USER_NAME], data.scene);
			Paints.fromObjectToSingleLayer(data[CONN_KEY_USER_NAME], data.paint);
			//TODO načíta všetky kresby
		}
		draw();
	}

	static processObjectAction(data, type){
		var obj, layer = type === "teach" ? data.user_name : data.oL;
		switch(data.action){
			case ACTION_OBJECT_MOVE:
				obj = Scene.getObject(layer, data.oId);
				obj.position.set(data.oX, data.oY);
				obj.size.set(data.oW, data.oH);
				break;
			case ACTION_OBJECT_DELETE:
				Scene.remove(Scene.getObject(layer, data.oId), data.oL, false);
				break;
			case ACTION_OBJECT_CHANGE:
				obj = Scene.getObject(layer, data.oId);
				each(data.keys, (e, i) => obj[i] = e);
				break;
			case ACTION_OBJECT_CREATE:
				data.o._layer = layer;
				Creator.create(data.o);
				break;
			default :
				Logger.error(getMessage(MSG_RECIEVED_UNKNOWN_ACTION, data.action));
		}
		draw();
	}

	static processLayerAction(data){
		var layer = Project.scene.getLayer(data[CONN_KEY_TITLE]);
		switch(data.action){
			case ACTION_LAYER_CREATE :
				if(!layer){
					Project.scene.createLayer(data[CONN_KEY_TITLE], data[CONN_KEY_TYPE]);
				}
				break;
			case ACTION_LAYER_DELETE :
				if(layer){
					Project.scene.deleteLayer(data[CONN_KEY_TITLE]);
				}
				break;
			case ACTION_LAYER_CLEAN :
				if(layer){
					layer.cleanUp();
				}
				break;
			case ACTION_LAYER_VISIBLE :
				if(layer){
					layer.visible = data[CONN_KEY_VALUE];
				}
				break;
			case ACTION_LAYER_RENAME :
				if(layer){
					layer.rename(data[CONN_KEY_VALUE]);
				}
				break;
		}
	}

	static processPaintAction(data, type){
		var layer = data[CONN_KEY_LAYER];
		if(type === CONN_KEY_TEACH){
			layer = data[CONN_KEY_USER_NAME];
		}

		switch(data.action){
			case ACTION_PAINT_ADD_POINT :
				Paints.addPoint(new GVector2f(data.pX, data.pY), layer);
				break;
			case ACTION_PAINT_BREAK_LINE :
				Paints.breakLine(layer);
				break;
			case ACTION_PAINT_CLEAN :
				Paints.cleanUp(layer);
				break;
			case ACTION_PAINT_ADD_PATH :
				Paints.addPath(layer, data.path);
				break;
			default :
				Logger.error(getMessage(MSG_RECIEVED_UNKNOWN_ACTION, data.action));
		}
		draw();
	}
}
/*
glob.testExercise = function(lessId, name){
	Project.connection.startExercise({
		user_name : name,
		less_id: lessId
	});
};

glob.testTeach = function(name = "teacherName"){
	Project.connection.startTeach({
		user_name : name,
		user_id: name
	});
};

glob.testWatch = function(lessId, name = "watcherName"){
	Project.connection.startWatch({
		user_name : name,
		less_id: lessId
	});
};

glob.testShare = function (name = "SharerName", watchers = 100){
	Project.connection.startShare({
		user_name : name,
		sharePaints: true,
		shareCreator: true,
		shareObjects: true,
		shareLayers: true,
		maxWatchers: watchers});
};
*/

/*
	compatible:	Date.now, geolocation, JSON parsing 14.9.2016
	JShint 4.2.2017
*/
class ProjectManager{
	constructor(author, title = PROJECT_NAME){
		this._createdAt 	= Date.now();
		this._title 		= title;
		this._autor			= author;
		this._scene 		= new SceneManager();
		this._options 		= new OptionsManager();
		this._input 		= new InputManager();
		this._gui 			= new GuiManager();
		this._files 		= new FileManager();
		this._content 		= new ContentManager();
		this._listeners 	= new ListenersManager();
		this._analyzer 		= new Analyzer(URL_ANONYM_DATA);
		this._canvasManager = null;
		this._connection 	= null;
		this._drawCounter 	= 0;
		this._idCounter 	= 0;

		try{
			if(isFunction(ConnectionManager)){
				this._connection = new ConnectionManager();
			}
		}
		catch(e){
			Logger.exception(getMessage(MSG_CREATE_PROJECT_ERROR), e);
		}

		//PAINT_MANAGER
		//CREATOR
		//TYPE 
		//ALLOWED_COMPONENTS
		
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);

		this._analyzer.sendData();

		if(glob.getCookie("send_data") === ""){
	        glob.setCookie("send_data", 1);
	    }
	}

	initCanvas(){
		this._canvasManager = new CanvasManager(window.innerWidth, window.innerHeight);
	}

	setForm(data){
		this._form = new FormManager(data);
	}

	generateId(){
		var s = "000000000" + (this._idCounter++);
		return (this._connection ? this._connection.userId : "") + s.substr(s.length - 6);
	}

	get autor(){return this._autor;}
	get canvas(){return this._canvasManager && this._canvasManager.canvas.canvas;}
	get canvasManager(){return this._canvasManager;}
	get connection(){return this._connection;}
	get content(){return this._content;}
	get context(){return this._canvasManager && this._canvasManager.canvas.context;}
	get creator(){return this._scene.creator;}
	get drawCounter(){return this._drawCounter;}
	get files(){return this._files;}
	get form(){return this._form;}
	get gui(){return this._gui;}
	get input(){return this._input;}
	get isMobile(){return this._analyzer.isMobile;}
	get listeners(){return this._listeners;}
	get options(){return this._options;}
	get panel(){return null;}
	get runOnMobile(){return this._browserData.mobile > 0;}
	get scene(){return this._scene;}
	get time(){return Date.now() - this._createdAt; }
	get title(){return this._title;}
	get topMenu(){return this._gui.menu;}

	increaseDrawCounter(){
		this._drawCounter++;
	}

	set autor(val){this._autor = val;}
}
/*
	compatible:	canvas 14.9.2016
*/
class PaintManager{
	constructor(){
		this._brushes			= [];
		this._selectedImage		= null;
		this._selectedImageName	= null;
		this._selectedBrush		= null;
		this._action			= PAINT_ACTION_LINE;
		this._paintHistory		= [];
		this._undoHistory		= [];

		//this.paintEvents = [];
		//this.history = [];
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	static getId(){
		if(!PaintManager._idCounter){
			PaintManager._idCounter = 1;
		}

		return PaintManager._idCounter++;
	}


	/**
	 * Pridá nový bod na danú vrstvu
	 *
	 * @param position - súradnica nového body
	 * @param activeLayerName - názov vrstvy kde sa má bod pridať
	 */
	addPoint(position, activeLayerName = Layers.activeLayerName){
		Events.paintAddPoint(position, activeLayerName);
		var layer = Scene.getLayer(activeLayerName);
		if(layer){
			layer.paint.addPoint(position);
		}
	}

	findPathsForRemove(position, radius, activeLayerName = Layers.activeLayerName){
		//TODO bud aktualna ale všetky vrstvy, podla Creator.allLayers
		Scene.getLayer(activeLayerName).paint.findPathsForRemove(position, radius);
	}

	removeSelectedPaths(activeLayerName = Layers.activeLayerName){
		//TODO bud aktualna ale všetky vrstvy, podla Creator.allLayers
		Scene.getLayer(activeLayerName).paint.removeSelectedPaths();
	}

	/**
	 * Vyčistí vrstvu danú ako parameter alebo vyčistí aktualnu vrstvu
	 *
	 * @param activeLayerName - nazov vrstvy ktorá sa má vyčistiť
	 */
	cleanUp(activeLayerName = Layers.activeLayerName){
		Events.paintCleanUp(activeLayerName);
		Scene.getLayer(activeLayerName).paint.cleanUp();
		Logger.log(getMessage(MSG_OBJECT_CLEANED, this.constructor.name), LOGGER_OBJECT_CLEANED);
	}


	/**
	 * Načíta všetky malby na základe vstupného objektu
	 *
	 * @param content - objekt obsahujúci všetky malby
	 */
	fromObject(content){
		each(content, (e, i) =>	{
			var layer = Scene.getLayer(i);
			if(!layer){
				layer = Scene.createLayer(i);
			}
			layer.paint.fromObject(e);
		});
	}


	fromObjectToSingleLayer(title, content){
		var layer = Scene.getLayer(title);
		each(content, e => layer.paint.fromObject(e, true));
	}

	/**
	 * Uloží všetky malby do jedného objektu
	 *
	 * @returns {{}} - objekt obsahujúci všetky malby
	 */
	toObject(){
		var result = {};

		each(Scene.layers, e => result[e.title] = e.paint.toObject());
		return result;
	}

	/**
	 * Pridá novú čiaru
	 * @param layer
	 * @param path
	 */
	addPath(layer, path){
		Scene.getLayer(layer).paint.addLine(path);
	}

	/**
	 * Preruší ťah štetcom
	 *
	 * @param activeLayerName - vrstva na ktorej sa má ťah prerušiť
	 */
	breakLine(activeLayerName = Layers.activeLayerName){
		this._paintHistory[this._paintHistory.length] = activeLayerName;
		this._undoHistory = [];
		var newPath = Scene.getLayer(activeLayerName).paint.breakLine();
		Events.paintBreakLine(activeLayerName);
		//Events.paintAddPath(activeLayerName, newPath);

		this._setButtons();
	}

	/**
	 * Pridá štetec do zoznamu možných štetcov
	 *
	 * @param title - názov súboru s štetcom
	 */
	addBrush(title){
		var img = new Image();
		img.src = FOLDER_IMAGE + "/" + title;
		this._brushes[title] = img;

		if(isNull(this._selectedImage)){
			this.selectedImage = title;
		}

		Logger.log("pridal sa nový štetec: " + title, LOGGER_PAINT_ACTION);
	}

	/**
	 * Prefarbí aktualny štetec na základa farby a velkosti štetca pri zmene Creatora
	 *
	 * @param size - velkosť štetca
	 * @param col - farba štetca
	 */
	rePaintImage(size, col){
		var c = document.createElement('canvas'),
			ctx, imgData, data, color, i;
		c.width = size;
		c.height = size;
		ctx = c.getContext('2d');
		ctx.drawImage(this._selectedImage, 0, 0, size, size);
		imgData = ctx.getImageData(0, 0, size, size);
		data = imgData.data;
		color = col.replace("rgb(", "")
				   .replace("rgba(", "")
				   .replace(")", "")
				   .split(", ")
				   .map(parseInt);
		for(i=3 ; i<data.length ; i+=4){
			if(data[i] === 0){
				continue;
			}
			data[i - 3] = color[0];
			data[i - 2] = color[1];
			data[i - 1] = color[2];
		}
		ctx.putImageData(imgData, 0, 0);
		this._selectedBrush = c;

		Events.paintBrushChange(size, col, this._selectedImageName);
	}

	//drawLine(ctx, pointA, pointB, brushSize, brushColor, action, brushType){
	drawLine(param){
		var ctx 		= param.ctx || Project.context,
			pointA 		= param.pointA,
			pointB 		= param.pointB,
			points 		= param.points,
			action 		= param.action 		|| Paints.action,
			brushSize 	= param.brushSize	|| Creator.brushSize,
			brushType 	= param.brushType	|| Creator.brushType,
			brushColor 	= param.brushColor	|| Creator.brushColor;

		if(action === PAINT_ACTION_LINE){
			ctx.lineCap 		= LINE_CAP_ROUND;
			ctx.lineWidth 		= brushSize;
			ctx.strokeStyle		= brushColor;
			ctx.beginPath();
			ctx.moveTo(pointA.x, pointA.y);
			ctx.lineTo(pointB.x, pointB.y);
			ctx.stroke();
		}
		else if(action === PAINT_ACTION_BRUSH){
			var dist 	= pointA.dist(pointB),
				angle 	= Math.atan2(pointA.x - pointB.x, pointA.y - pointB.y);

			Creator.setOpt("brushColor", brushColor);
			Creator.setOpt("brushSize",	brushSize);
			Creator.setOpt("brushType", brushType);

			for (var i = 0; i < dist; i++){
				ctx.drawImage(Paints.selectedBrush,
					pointB.x + (Math.sin(angle) * i) - (brushSize >> 1),
					pointB.y + (Math.cos(angle) * i) - (brushSize >> 1),
					brushSize,
					brushSize);
			}
		}
		else if(action === PAINT_ACTION_FUR){
			var limit = 2000,
				offset = 0.5;
			ctx.strokeStyle = brushColor;
			ctx.lineWidth 	= 1;
			ctx.beginPath();

			ctx.moveTo(pointB.x, pointB.y);
			ctx.lineTo(pointA.x, pointA.y);

			for (var i = 0; i < points.length; i++) {
				var dx = points[i].x - pointB.x;
				var dy = points[i].y - pointB.y;
				var d = dx * dx + dy * dy;

				if (d < limit && Math.random() > d / limit) {
					ctx.moveTo(pointB.x + (dx * offset), pointB.y + (dy * offset));
					ctx.lineTo(pointB.x - (dx * offset), pointB.y - (dy * offset));
				}
			}

			ctx.stroke();
		}
		else if(action === PAINT_ACTION_NEIGHBOR){
			var limit = 1000,
				offset = 0.2;
			ctx.strokeStyle = brushColor;
			ctx.lineWidth 	= 1;
			ctx.beginPath();

			ctx.moveTo(pointB.x, pointB.y);
			ctx.lineTo(pointA.x, pointA.y);

			for (var i = 0, len = points.length; i < len; i++) {
				var dx = points[i].x - pointB.x;
				var dy = points[i].y - pointB.y;
				var d = dx * dx + dy * dy;

				if (d < limit) {
					ctx.moveTo( pointB.x + (dx * offset), pointB.y + (dy * offset));
					ctx.lineTo( points[i].x - (dx * offset), points[i].y - (dy * offset));
				}
			}
			ctx.stroke();
		}
	}

	undo(){
		if(this._paintHistory.length === 0){
			return false;
		}
		var layer = this._paintHistory.pop();

		Scene.getLayer(layer).paint.undo();
		this._undoHistory[this._undoHistory.length] = layer;

		Events.paintUndo(layer);
		console.log(this._paintHistory.length, this._undoHistory.length);
		this._setButtons();
		draw();
	}

	redo(){
		if(this._undoHistory.length === 0){
			return false;
		}

		var layer = this._undoHistory.pop();
		Scene.getLayer(layer).paint.redo();
		this._paintHistory[this._paintHistory.length] = layer;

		Events.paintRedo(layer);
		this._setButtons();
		draw();
	}

	_setButtons(){
		Menu.disabled("mainMenu", "undo", this._paintHistory.length === 0);
		Menu.disabled("mainMenu", "redo", this._undoHistory.length === 0);
	}

	//GETTERS

	get selectedImage(){return this._selectedImage;}
	get selectedBrush(){return this._selectedBrush;}
	get action(){return this._action;}


	getBrush(title){
		return this._brushes[title];
	}

	//SETTERS
	/**
	 * zmení aktualne zvolený typ štetca a prekreslí menú aby bol vybraný spravný štetec
	 *
	 * @param title
	 */
	set selectedImage(title){
		this._selectedImage = this._brushes[title];
		this._selectedImageName = title;
		Menu._redraw();
	}

	set action(val){this._action = val;}
}
/*
	compatible:	forEach, getComputedStyle, JSON parsing 14.9.2016
*/

class ListenersManager{
	constructor(){
		//console.log("strict: " + (function() { return !this; })());
		this._movedObject = null;
		this._clickedOnObject = false;
	}
	mouseDown(position, button){
		if(Options.showClicks){
			Project.scene.mouseDown(position.x, position.y);
		}
		this._clickedOnObject = false;

		if($(canvas).hasClass("blur")){
			closeDialog();
			this._clickedOnObject = true;
			return false;
		}
		/*
		 * SKONTROLUJE SA KLIKNUTIE NA ČASOVÚ OS
		 */
		if(isDefined(timeLine) && timeLine.clickIn(position.x, position.y)){
			this._movedObject = timeLine;
			this._clickedOnObject = true;
			return false;
		}

		/*
		 * SKONTROLUJE SA KLIKNUTIE NA AREU, BUĎ SA ZAČNE PRESÚVAŤ ALEBO VYTVÁRAŤ
		 */
		if(!this._clickedOnObject && !actContextMenu && Creator.operation == OPERATION_AREA && area){
			if(area.isReady && area.clickIn(position.x, position.y)){ //ak sa kliklo na už vytvorene tak sa bude posuvať
				selectedObjects.movedObject = area;
				area.moving = true;
				this._movedObject = selectedObjects;
			}
			else {//ináč sa začne vytvárať nová
				area.startCreate(position);
			}
			this._clickedOnObject = true;
		}

		/*
		 * AK JE OZNAČENÝ TEXT TAK SA ULOŽÍ DO NEHO AKTUÁLNA HODNOTA INPUT A TEN SA SCHOVÁ
		 */
		if(SelectedText){
			var textArea = new G("#selectedEditor");
			if(!textArea.isEmpty()){
				console.log("res: " + parseInt(window.getComputedStyle(textArea).fontSize, 10));
				SelectedText.text = textArea.text();
				textArea.delete();
			}
		}


		/*
		if(actContextMenu && actContextMenu.clickIn(position.x, position.y))
			return;
		*/


		/*
		 * SKONTROLUE SA ČI SA MÁ VYTVÁRAŤ NOVÝ OBJEKT 
		 */
		if(!Creator.clickIn(position.x, position.y, false) && (Menu.isToolActive() || Creator.controllPress) && !Creator.object){
			Creator.createObject(position);
			this._movedObject = Creator;
			this._clickedOnObject = true;
			return false;
		}

		/*
		 * SKONTROLUJÚ SA NA KLIKNUTIE VŠETKY OBJEKTY V SCÉNE 
		 */
		if(!this._clickedOnObject && button == LEFT_BUTTON && !actContextMenu){
			Scene.forEach((o) => {
				if(o.visible && !o.layer.userLayer && o.clickIn(position.x, position.y, button)){
					if(Creator.operation === OPERATION_DRAW_LINE && Input.isKeyDown(KEY_L_CTRL) && o.selectedConnector){
						Creator.createObject(position, o);
						this._movedObject = Creator;
					}
					else{
						o.moving = true;
						selectedObjects.movedObject = o;
						this._movedObject = selectedObjects;
					}
					this._clickedOnObject = true;
					return true;
				}
			});
		}
		draw();
	}

	mouseLeave(position){
		this.mouseUp(position, false);
		draw();
	}

	hashChange(){
		glob.setUpComponents();

		if(MenuManager.dataBackup){
			Menu.init(JSON.parse(MenuManager.dataBackup));
		}

		if(Layers){
			//Entity.setAttr(Layers, "visible", Components.layers());
			Layers.visible = Components.layers();
		}

		Project.gui.showOptionsByComponents();
		draw();
	}

	keyDown(key, isCtrlDown){
		if(KEY_DELETE === key){
			if(area.isReady){
				area.removeSelected(isCtrlDown);//ak je aj ALT dole tak revertne mazanie
			}
		}
		glob.showKey(key);
		draw();
	}

	keyUp(key, isCtrlDown){
		if(isCtrlDown){
			switch(key){
				case KEY_Z:
					Paints.undo();
					break;
				case KEY_Y:
					Paints.redo();
					break;
				case KEY_A:
					selectedObjects.selectAll();
					draw();
					break;
			}
		}
		else{
			switch(key){
				case KEY_DELETE:
					selectedObjects.deleteAll();
					draw();
					break;
				case KEY_ESCAPE:
					closeDialog();
					break;
				case KEY_NUM_1:
					Creator.operation = OPERATION_DRAW_PATH;
					draw();
					break;
				case KEY_NUM_2:
					Creator.operation = OPERATION_DRAW_RECT;
					draw();
					break;
				case KEY_NUM_3:
					Creator.operation = OPERATION_DRAW_LINE;
					draw();
					break;
				case KEY_NUM_4:
					Creator.operation = OPERATION_DRAW_ARC;
					draw();
					break;
				case KEY_NUM_5:
					Creator.operation = OPERATION_DRAW_IMAGE;
					draw();
					break;
			}
		}
	}

	mousePress(position){
		/*
		 * SKONTROLUJE SA HORNE MENU
		 */
		if(Menu.pressIn(position.x, position.y)){
			draw();
			return true;
		}

		Paints.breakLine();

		/*
		 * VYTVORI SA KONTEXTOVÉ MENU
		 */
		actContextMenu = new ContextMenuManager(position);

		/*
		 * AK SA PRESUVAL NEJAKÝ OBJEKT TAK SA ZRUŠÍ PRESÚVANIE
		 */
		if(selectedObjects.movedObject){
			selectedObjects.movedObject.moving = false;
			selectedObjects.movedObject = false;
			this._movedObject = null;
		}

		draw();
		return false;
	}

	mouseDoubleClick(position){
		var result	= false,
			vec 	= new GVector2f(100, 40);

		Scene.forEach(e => {
			if(!result && isDefined(e.doubleClickIn) && e.doubleClickIn(position.x, position.y)){
				result = e;
			}
		});

		if(!result){
			getText("", position, vec, val => val.length && Scene.addToScene(new TextField(val, position, vec)));
		}

		draw();
		return true;
	}

	mouseUp(position, closeDialog = true){
		var possibleChild = null;
		var result = false;
		var clickOnParent = false;
		var clickOnConnectorObject = null;
		
		if(selectedObjects.size() === 1){
			possibleChild = selectedObjects.firstObject;
		}
		if(Options.showClicks){
			Project.scene.mouseUp(position.x, position.y);
		}

		this._movedObject = null;


		/*
		 * AK JE VYBRANY NASTROJ RUBBER TAK SA VYMAŽÚ OBJEKTY KTORÉ BOLY VYGUMOVANÉ
		 */
		if(Creator.operation === OPERATION_RUBBER){
			Paints.removeSelectedPaths();
			//return false;
		}

		/*
		 * AK JE VYBRANY NASTROJ AREA TAK SA BUĎ DOKONČÍ VYTVARANIE ALEBO PRESUN
		 */
		if(Creator.operation == OPERATION_AREA && area){
			if(area.isCreating){
				area.endCreate(position);
			}
			else if(area.moving){
				area.moving = false;
			}
			//return false;
		}

		/*
		 * SKONTROLUJE KONTEXTOVE MENU A AK SA KLILKLO NA NEHO TAK HO VYPNE A SKONCI
		 */
		if(actContextMenu){
			if(!actContextMenu.clickIn(position.x, position.y)){
				actContextMenu = false;
			}
			else{
				return false;
			}
		}
		
		/*
		 * AK SA VYTVARAL OBJEKT TAK SA JEHO VYTVARANIE DOKONČÍ
		 */
		 
		if(Creator.object && Creator.object.name != OBJECT_LINE){
			Creator.finishCreating(position);
			return false;
		}
		

		/*
		 * AK JE VYBRANY NASTROJ KRESBA TAK SA PRERUSI CIARA
		 */
		if(Creator.operation == OPERATION_DRAW_PATH && Components.draw()){
			Paints.addPoint(position);
			Paints.breakLine();
			//return false;
		}

		/*
		 * SKONTROLUJE SA MENU A CREATOR
		 */
		if(Menu.clickIn(position.x, position.y)){
			return;
		}

		if(Creator.clickIn(position.x, position.y)){
			return;
		}

		if(closeDialog){
			closeDialog();
		}

		Scene.forEach(o => {
			if(!result && o.clickIn(position.x, position.y)) {
				if(possibleChild){
					if(possibleChild.parent === o){ //ak klikol na svojho rodiča tak sa nekontroluje priradenie dietata
						clickOnParent = true;
					}
					else if(possibleChild !== o){//TODO treba asi prerobiť na jedno dieťa;
						//o.addChildren(possibleChild);
						//clickOnParent = true;
					}
				}
				if(o.selectedConnector){
					clickOnConnectorObject = o;
				}
				if(Creator.object){//toto sa stará o konektory
					if(o.selectedConnector){
						console.log("teraz");
						Creator.object.targetB = o;
					}
					//Scene.addToScene(Creator.object);
					result = true;
					return;
				}
				else{
					Input.isKeyDown(KEY_L_CTRL) ? selectedObjects.add(o) : selectedObjects.clearAndAdd(o);
				}
				result = true;
			}
		});

		/*
		 * AK SA HYBALO S NEJAKYM OBJEKTOM TAK SA DOKONCI POHYB
		 */
		if(selectedObjects.movedObject){
			if(clickOnConnectorObject && selectedObjects.movedObject.name === OBJECT_LINE){
				selectedObjects.movedObject.setTarget(clickOnConnectorObject);
				console.log("teraz");
			}
			selectedObjects.movedObject.moving = false;
			selectedObjects.movedObject = false;
			this._movedObject = null;
			//return false;
		}

		if(possibleChild && !clickOnParent){
			possibleChild.removeParent();
		}
		if(Creator.object){//tu može byť iba line ktorá nebola pripojená na konektor
			Creator.finishCreating();
		}
		//Creator.object = false;
		if(!result){
			selectedObjects.clear();
		}
	}

	mouseMove(position, movX, movY){
		/*
		 * KONTROLA HOVER LISTENEROV
		 */
		if(Options.changeCursor){//TODO timeline, layersViewer, creator, Line & polygon, selectors, connectors
			var isHoverTrue = Menu.hover(position.x, position.y);

			/*
			if(actContextMenu)
				actContextMenu.hover(position.x, position.y);
			*/
			if(!isHoverTrue && Creator.operation === OPERATION_AREA){
				isHoverTrue = area.hover(position.x, position.y);
			}

			if(!isHoverTrue){
				Scene.forEach(e => {
					if(isHoverTrue){
						return;
					}
					isHoverTrue = e.hover(position.x, position.y);
				});
			}
		}

		/*
		 * AK JE VYBRANY NASTROJ AREA A AREA JE VYTVARANA TAK SA PRIDA BOD
		 */
		if(Creator.operation == OPERATION_AREA && area && area.isCreating){
			area.addPoint(position);
			this._clickedOnObject = true;//TODO overiť
			return false;
		}

		/*
		 * AK JE VYBRANY NASTROJ RUBBER A JE STLAČENE TLAČITKO MYŠI TAK SA PRIDA NOVY BOD
		 */
		if(Creator.operation === OPERATION_RUBBER && Input.isButtonDown(LEFT_BUTTON)) {
			//Paints.drawLine(context, position, {x: position.x - movX, y: position.y - movY}, Creator.brushSize, "grey", PAINT_ACTION_LINE);
			Paints.drawLine({
				pointA: position,
				pointB: {x: position.x - movX, y: position.y - movY}, 
				action: PAINT_ACTION_LINE, 
				brushColor: RUBBER_COLOR
			});			
			Paints.findPathsForRemove(position, 1);
			Project.scene.findObjectsForRemove(position.x, position.y, 1);
			this._clickedOnObject = true;//TODO overiť
			return false;
		}

		/*
		 * AK JE OZNACENNY OBJEKT S KTORYM SA HYBE TAK SA POHNE
		 */
		if(this._movedObject && isFunction(this._movedObject.onMouseMove)){
			this._movedObject.onMouseMove(position, movX, movY);
			draw();
			this._clickedOnObject = true;
			return false;
		}

		/*
		 * AK JE VYBRANY NASTROJ DRAW A TLACITKO MYŠI JE STLAČENE TAK SA PRIDA NOVÝ BOD
		 */
		if(Input.isButtonDown(LEFT_BUTTON) && Creator.operation == OPERATION_DRAW_PATH && Components.draw()){
			var radius = 1;
			Paints.addPoint(radius === 1 ? position : position.div(radius).round().mul(radius));
			draw();
			this._clickedOnObject = true;
			return false;
		}

		/*
		/////OBJEKTY PRI POHYBE

		//ak sa hýbe nejakým objektom
		if(selectedObjects.movedObject && Creator.operation != OPERATION_DRAW_PATH){
			//prejdu sa všetky označené objekty a pohne sa nimi
			selectedObjects.forEach(e => Movement.move(e, movX, movY));

			//ak objekt s ktorým sa hýbe nieje označený(už sa sním pohlo) tak sa sním tiež pohne
			if(!selectedObjects.movedObject.selected)
				Movement.move(selectedObjects.movedObject, movX, movY);

			//ak sú nejaké objekty označené tak sa aktualizuje prehlad posledného označeného ináč iba hýbaného
			if(selectedObjects.size())
				updateSelectedObjectView(selectedObjects.getLast());
			else if(selectedObjects.movedObject)
				updateSelectedObjectView(selectedObjects.movedObject);
		}


		/////ČIARA

		//ak sa kreslí čiara tak sa nakreslí nové posunutie
		if(Input.isButtonDown(LEFT_BUTTON) && Creator.operation == OPERATION_DRAW_PATH && Components.draw()){
			Paints.addPoint(position);
			draw();
		}

		/////CREATOR

		//ak sa vytvára objekt tak sa nakreslí nové posunutie
		if(Creator.object){
			updateSelectedObjectView(Creator.object);
			Creator.object.updateCreatingPosition(position);
		}

		if(selectedObjects.movedObject || Input.isKeyDown(SHIFT_KEY) || Creator.object)
			draw();
		*/
	}
}
/*
	compatible:	indexOf, canvas, canvasText, JSON parsing 14.9.2016
*/

glob.initTime	= Date.now();

var movedObject 	= false,
	Logger 			= new LogManager(),//samostatne lebo loguje aj Projekt preto nie v ňom
	Project			= new ProjectManager(PROJECT_AUTHOR),
	Scene 			= Project.scene,
	Creator 		= Project.creator,
	Input 			= Project.input,
	selectedObjects = Project.scene.objectManager,
	Menu 			= Project.topMenu,
	actContextMenu 	= false,//TODO presunuť do noveho objektu na spravu GUI
	Paints			= new PaintManager(),
	Task 			= null,//TODO presunúť do nejakého CONTENTU
	Events 			= typeof EventManager !== KEYWORD_UNDEFINED ? new EventManager() : null,
	SelectedText	= null,
	Options 		= Project.options,
	drawEvent 		= new EventTimer(realDraw, 1000 / FPS),
	pdrawEvent 		= new EventTimer(realPDraw, 1000 / FPS),
	area 			= null,
	Panel			= null,
	Connection		= Project.connection,
	draw 			= () => drawEvent.callIfCan(),
	pdraw 			= () => pdrawEvent.callIfCan(),
	//pcanvas, pcontext, drawMousePos, chatViewer,
	components, Layers, canvas, context, timeLine;


	//Gui 			= Project.gui,
	//Forms		 	= null,
	//Listeners		= Project.listeners,
	//EventHistory 	= new EventSaver(),
	//Content			= new ContentManager(),//TODO presunúť do nejakého CONTENTU
	//Files			= new FileManager(),//TODO presunúť do nejakého CONTENTU
	//TODO Layers presunuť do noveho objektu na spravu GUI

glob.setUpComponents = function(){
	components =  {
		draw : window.location.hash.indexOf(COMPONENT_DRAW) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		share : window.location.hash.indexOf(COMPONENT_SHARE) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		watch : window.location.hash.indexOf(COMPONENT_WATCH) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		tools : window.location.hash.indexOf(COMPONENT_TOOLS) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		save : window.location.hash.indexOf(COMPONENT_SAVE) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		load : window.location.hash.indexOf(COMPONENT_LOAD) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		screen : window.location.hash.indexOf(COMPONENT_SCREEN) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		content : window.location.hash.indexOf(COMPONENT_CONTENT) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		edit : window.location.hash.indexOf(COMPONENT_EDIT) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		layers : window.location.hash.indexOf(COMPONENT_LAYERS) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED,
		task : window.location.hash.indexOf(COMPONENT_TASK) >= 0 || typeof Watcher !== KEYWORD_UNDEFINED
	};
};

var Components = {
	draw	: () => isDefined(components) && isDefined(components.draw) && components.draw === true,
	share	: () => isDefined(components) && isDefined(components.share) && components.share === true,
	watch	: () => isDefined(components) && isDefined(components.watch) && components.watch === true,
	tools	: () => isDefined(components) && isDefined(components.tools) && components.tools === true,
	save	: () => isDefined(components) && isDefined(components.save) && components.save === true,
	load	: () => isDefined(components) && isDefined(components.load) && components.load === true,
	screen	: () => isDefined(components) && isDefined(components.screen) && components.screen === true,
	content	: () => isDefined(components) && isDefined(components.content) && components.content === true,
	layers	: () => isDefined(components) && isDefined(components.layers) && components.layers === true,
	task	: () => isDefined(components) && isDefined(components.task) && components.task === true,
	edit	: () => isDefined(components) && isDefined(components.edit) && components.edit === true
};

function sendMessage(message){
	if(typeof Watcher !== KEYWORD_UNDEFINED){
		Watcher.sendMessage(message, Project.autor);
	}

	if(typeof Sharer !== KEYWORD_UNDEFINED && Sharer.isSharing){
		Sharer.sendMessage(message, Project.autor);
	}

	//chatViewer.recieveMessage(message, Project.autor);
	Panel.recieveMessage(message, Project.autor);
}

function ajax(url, options, dataType){
	if(isFunction(options)){
		options = {success: options};
		if(isString(dataType)){
			options.dataType = dataType;
		}
	}
	else if(!isObject(options)){
		options = {};
	}

	options.method = options.method || "GET";
	options.async = options.async || true;

	var start = 0;
	var xhttp = window.XMLHttpRequest ?  new XMLHttpRequest() :  new ActiveXObject("Microsoft.XMLHTTP");

	if(isFunction(options.abort)){
		xhttp.onabort = options.abort;
	}
	if(isFunction(options.error)){
		xhttp.onerror = options.error;
	}
	if(isFunction(options.progress)){
		xhttp.onprogress = options.progress;
	}
	if(isFunction(options.timeout)){
		xhttp.ontimeout = options.timeout;
	}
	if(isFunction(options.loadEnd)){
		xhttp.onloadend = () => options.loadEnd((Date.now() - start));
	}
	if(isFunction(options.loadStart)){
		xhttp.onloadstart = function(){
			options.loadStart();
			start = Date.now();
		};
	}
	if(isFunction(options.success)){
		xhttp.onreadystatechange = function() {
			if (xhttp.readyState == 4 && xhttp.status == 200 && isFunction(options.success)){
				switch(options.dataType){
					case "json" :
						options.success(JSON.parse(xhttp.responseText));
						break;
					case "html" :
						options.success(new DOMParser().parseFromString(xhttp.responseText, FORMAT_FILE_XML));
						break;
					case "xml" :
						options.success(new DOMParser().parseFromString(xhttp.responseText, FORMAT_FILE_XML));
						break;
					default :
						options.success(xhttp.responseText);
				}
			}
		};
	}
	//console.log(options);
	xhttp.open(options.method, url, options.async);
	xhttp.send();
}
ajax(FOLDER_JSON + "/context.json", data => ContextMenuManager.items = data, "json");
//$.getJSON(FOLDER_JSON + "/context.json", data => ContextMenuManager.items = data);
//ajax(FOLDER_JSON + "/attributes.json", data => Entity.attr = data, "JSON");
$.getJSON(FOLDER_JSON + "/attributes.json", data => Entity.attr = data);


glob.init = function(){
	Project.scene.addToScene(new Rect(new GVector2f(800, 50), new GVector2f(100, 100), "#ff0000"));

	Project.scene.addToScene(new Line([new GVector2f(10, 400), new GVector2f(300, 450)], 5, "#66CCCC"));

	Project.scene.addToScene(new Arc(new GVector2f(600, 300), new GVector2f(50, 50), "#66CCCC"));

	Project.scene.addToScene(new Rect(new GVector2f(800, 50), new GVector2f(100, 100), "#ff0000"));
	Project.scene.addToScene(new Rect(new GVector2f(250, 250), new GVector2f(100, 100), "#00ff00"));

	Project.scene.addToScene(new Polygon([new GVector2f(1200, 100), 
										  new GVector2f(1150, 150), 
										  new GVector2f(1250, 150)], "#ff69b4"));
	Project.scene.addToScene(new Table(new GVector2f(800, 250), 
									   new GVector2f(200, 800), 
									   [["meno", "vek"], ["gabo", 21], ["maros", 35]]), "test2");

	loadImage(e => Project.scene.addToScene(new ImageObject(new GVector2f(300, 400), 
															new GVector2f(300, 400), e)));



	var methods = {
		getArea: {
			name: "getArea",
			retType: KEYWORD_NUMBER,
			access: ACCESS_PUBLIC,
			args: KEYWORD_VOID
		},
		getPosition:{
			name: "getPosition",
			retType: "GVector2f",
			access: ACCESS_PROTECTED,
			args: KEYWORD_VOID
		}
	};

	var attrs = {
		x : {
			name: "x",
			access: ACCESS_PROTECTED,
			type: KEYWORD_NUMBER
		},
		y : {
			name: "y",
			access: ACCESS_PROTECTED,
			type: KEYWORD_NUMBER
		},
		width : {
			name: "width",
			access: ACCESS_PROTECTED,
			type: KEYWORD_NUMBER
		},
		height : {
			name: "height",
			access: ACCESS_PROTECTED,
			type: KEYWORD_NUMBER
		}
	};
	Project.scene.addToScene(new Class(new GVector2f(500, 150), 
									   new GVector2f(250, 250), 
									   "Rectange", 
									   attrs, 
									   methods));
	draw();
};

/*
function setVisibilityData(data){
	Project.topMenu.visible = data.showTopMenu;
}
*/

ajax(FOLDER_JSON + "/forms.json", data => {
	Project.setForm(data);
	var formList = {
		shareForm 	: "sharingForm",
		optionsForm : "optionsForm",
		watchForm 	: "watchForm",
		saveXmlForm : "saveXmlForm",
		saveForm 	: "saveImgForm"
	};
	each(formList, function(e, i){
		var form = document.getElementById(i);
		if(form){
			form.appendChild(Project.form.createForm(e));
		}
	});

	Project.options.init();
}, "json");

/*
$.ajax({
	dataType: "json",
	url: "/js/json/config_user.json",
	//async: false,
	success : function(data){
		console.log("constants: ", setConstants(data.environmentOptions));
		setVisibilityData(data.visibilityOptions);
	}
});
*/

glob.loading = function(){
	//	testCompatibility();
	try{
		/////DOLEZITE!!!
		Project.listeners.hashChange();
		area = new Area();
		Project.initCanvas();


		canvas = Project.canvas;
		context = Project.context;
		pcanvas = Project.canvasManager.pCanvas.canvas;
		pcontext = Project.canvasManager.pCanvas.context;
		
		//if(typeof ConnectionManager === "function")
		//	Connection = new ConnectionManager();
		Project._connection = new ConnectionManager();

		$.getJSON(FOLDER_JSON + "/menu.json",function(data){
			try{
				Project.topMenu.init(data);
			}
			catch(e){
				Logger.exception(getMessage(MSG_INIT_MENU_ERROR), e);
			}
			$.getJSON(FOLDER_JSON + "/creator.json", data2 => {
				try{
					Creator.init(data2);
					Paints.rePaintImage(Creator.brushSize, Creator.brushColor);
					draw();
				}
				catch(e){
					Logger.exception(getMessage(MSG_INIT_CREATOR_ERROR), e);
				}
			});
		});

		//PanelManager = new PanelManager();

		Project.scene.createLayer();
		//Project.scene.createLayer("rightMenu", "gui");
		Project.scene.createLayer("test2");

		Project.context.shadowColor = DEFAULT_SHADOW_COLOR;
		Project.input.initListeners(Project.canvas);

		//if(typeof Sharer !== KEYWORD_UNDEFINED){
		//	chatViewer = new ChatViewer(Project.title + "'s chat", Project.autor, sendMessage);
		//}

		Layers = new LayersViewer({element: G.byId("layerViewerPlaceholder"), visible: Components.layers()});
		//Project.scene.addToScene(Layers, "rightMenu");
		var xOffset = Project.topMenu.position.x + (Project.topMenu.size.x + MENU_OFFSET) * Project.topMenu.visibleElements - MENU_OFFSET;
		Creator.view = new CreatorViewer(new GVector2f(Project.topMenu.visible ? xOffset : MENU_OFFSET, Project.topMenu.position.y - MENU_OFFSET));

		console.log("stranka sa nacítala za: ", (Date.now() - glob.initTime) + " ms");
			
		draw();


		if(ASK_FOR_RESTORE_DATA && localStorage.hasOwnProperty(RESTORE_KEY)){
			if(confirm(getMessage(MSG_LOAD_OLD_PROJECT))){
				var data = JSON.parse(localStorage.getItem(RESTORE_KEY));
				Scene.fromObject(data.scene);
				Creator.fromObject(data.creator);
				Paints.fromObject(data.paint);
			}
		}

	}
	catch(e){
		console.log(e);
		Logger.exception(getMessage(MSG_LOADING_ERROR), e);
	}
};

//$(loading);
function realPDraw(){
	Project.canvasManager.pCanvas.clearCanvas();
	if(Project.connection){
		Project.connection.pdraw(pcontext);
	}
	Project.scene.pdraw(pcontext);
}

function realDraw(){
	if((typeof Watcher !== KEYWORD_UNDEFINED && !Watcher.connected) || !Project.context || !isObject(Project.context)){
		return;
	}
	Project.increaseDrawCounter();
	CanvasHandler.clearCanvas(Project.context);
	if(Project.options.grid){
		glob.drawGrid();
	}

	if(Creator.operation == OPERATION_AREA && area){
		area.draw();
	}

	Project.scene.draw();
	Creator.draw();
	Project.topMenu.draw();
	if(actContextMenu){
		actContextMenu.draw();
	}
	Logger.log("kreslí sa všetko", LOGGER_DRAW);
	if(typeof timeLine !== KEYWORD_UNDEFINED && timeLine){
		timeLine.draw();
	}

	/*
	Project.context.font = "30px " + DEFAULT_FONT_FAMILY;
	Project.context.fillStyle = "red";
	Project.context.fillText("draw(ms): " + (new Date().getMilliseconds() - drawMousePos), window.innerWidth - 100, 15);
	*/
}
class Entity{
	/**
	 * @param name
	 * @param position
	 * @param size
	 * @param data
	 */
	constructor(name, position = new GVector2f(), size = new GVector2f(), data = {}){
		this._position 			= position;
		this._size 				= size;
		this._name 				= name;

		this._drawCounter		= -1;
		this._selected 			= false;
		this._visible 			= true;
		this._moving 			= false;
		this._locked			= false;
		this._minSize 			= false;
		this._selectedConnector = false;

		this._layer				= PROJECT_LAYER_TITLE;

		this._parent			= null;
		this._childrens			= [];

		Entity.changeAttr(this, data);

		if(isUndefined(this._connectors)){	//presunute nižšie lebo chcem priradiť iba ak neexsituju
			this._connectors 	= [new GVector2f(0.5, 0), new GVector2f(0.5, 1), new GVector2f(0, 0.5), new GVector2f(1, 0.5)];
		}

		if(isUndefined(this._id)){	//presunute pod priradenie atributov lebo chcem priradiť ID iba ak nieje ešte
			this._id			= Project.generateId();//Entity.getId();
		}

		if(isUndefined(this._borderWidth)){
			this._borderWidth	= Creator.borderWidth;
		}

		if(isUndefined(this._radius)){
			this._radius 		= Creator.radius;
		}

		if(isUndefined(this._fillColor)){
			this._fillColor 	= Creator.color;
		}

		if(isUndefined(this._borderColor)){
			this._borderColor 	= Creator.borderColor;
		}
	}

	highlight(){
		var counter = 0,
			speed = HIGHLIGHT_SPEED,
			movement = 1,
			interval = setInterval(() => {
				this._position.sub(speed);
				this._size.add(speed * 2);
				counter += movement;
				if(counter === HIGHLIGHT_LIMIT){
					speed *= -1;
					movement *= -1;
				}
				else if(counter === 0){
					if(--HIGHLIGHT_COUNT > 0){
						speed *= -1;
						movement *= -1;
					}
					else{
						clearInterval(interval);
					}
				}
				draw();
			}, 1000 / FPS);
	}

	isIn(x, y, radius = 0){
		return x + radius > this._position.x && x - radius < this._position.x + this._size.x &&
			   y + radius > this._position.y && y - radius < this._position.y + this._size.y;
	}

	removeChildren(element){
		var index = this._childrens.indexOf(element);
		if(index >= 0){
			this._childrens.splice(index, 1);
			element._parent = null;
		}
		return element;
	}

	removeParent(){
		if(this._parent){
			this._parent.removeChildren(this);
		}

		return this;
	}

	get parent(){
		return this._parent;
	}

	addChildren(element){
		if(element._parent !== this && this._parent !== element){
			var index = this._childrens.indexOf(element);
			if(index < 0){
				this._childrens.push(element);
				element._parent = this;
			}
		}
		return element;
	}

	eachChildren(func){
		each(this._childrens, e => func(e));
	}

	/**
	 * Vygeneruje jedinečný identifikátor
	 *
	 * @returns {Number}
	 */
	static getId(){
		if(isUndefined(Entity._actId)){
			Entity._actId = 0;
		}
		return Entity._actId++;
	}


	/**
	 * Pridá k objektu nový connector
	 */
	addConnector(){
		objectToArray(arguments).forEach(e => this._connectors.push(e), this);
	}


	/**
	 * Vráti true ak je šanca že bolo kliknuté na niektorú časť objektu
	 *
	 * @param x
	 * @param y
	 * @param obj
	 * @returns {boolean}
	 */
	clickInBoundingBox(x, y, obj = this){
		return x + SELECTOR_SIZE > obj._position.x && x - SELECTOR_SIZE < obj._position.x + obj._size.x &&
			   y + SELECTOR_SIZE > obj._position.y && y - SELECTOR_SIZE < obj._position.y + obj._size.y;
	}


	/**
	 * Zistí či bolo kliknuté na objekt a ak áno zavolá príslušnú funkciu
	 * @param x
	 * @param y
	 * @returns {boolean}
	 */
	clickIn(x, y){
		//TODO nechceme aby to rátalo ani ak je zamknutý
		//if(this.locked)
		//	return false;

		if (!this.clickInBoundingBox(x, y)){
			return false;
		}
		return this._clickIn(x, y);
	}

	_clickIn(x, y){return false;}

	hover(x, y){
		if(!this.clickInBoundingBox(x, y)){
			return false;
		}
		return this._hover(x, y);
	}

	_hover(x, y){
		return false;
	}

	/**
	 * Vykoná príslušnú akciu po kliknutí
	 */
	//_doClickAct(index, x, y){};


	/**
	 * Zistí či bolo pressnuté na objekt a ak áno zavolá príslušnú funkciu
	 * @param x
	 * @param y
	 */
	pressIn(x, y){
		return false;
	}



	/*
	 * vykoná príslušnú akciu po pressnutí
	 */
	//_doPressAct(index, x, y){};


	/**
	 * Vyčistí objekt (vykonáva sa tesne pred zmazaním)
	 */
	cleanUp(){}


	_draw(){}

	/**
	 * Vykreslí objekt
	 */
	draw(ctx = context){
		//skontroluje či sa túto snímku už nevykresloval
		if(context === ctx){//ale iba ak sa kreslí na hlavný canvas(nie pcanvas)
			if(this._drawCounter === Project.drawCounter){
				return;
			}
			this._drawCounter = Project.drawCounter;
		}

		//ak je neviditelný nevykreslí sa
		if (!this.visible){
			return;
		}


		this._draw(ctx);


		for(var e in this._childrens){
			this._childrens[e].draw(ctx);
		}
	}


	/**
	 * Nastavý objektu atribút
	 *
	 * @param obj
	 * @param attr
	 * @param val
	 * @returns {*}
	 */
	static setAttr(obj, attr, val){
		if(isUndefined(Entity.attr) || isDefined(Entity.attr.Entity[attr]) || isDefined(Entity.attr[obj.name][attr])){
			obj["_" + attr] = val;
		}
		else{
			Logger.error(getMessage(MSG_WRONG_ATTRIBUTE, obj.name, attr));
		}

		Events.objectChange(obj, attr, val);
		return obj;
	}


	/**
	 * Zmení objektu atribút
	 *
	 * @param obj
	 * @param data
	 * @param val
	 * @returns {*}
	 */
	static changeAttr(obj, data, val){
		if(isObject(data)){
			each(data, (e, i) => Entity.setAttr(obj, i, e));
		}
		else{
			Entity.setAttr(obj, data, val);
		}
		return obj;
	}


	/**
	 * Vypočíta maximálnu a minimálnu poziciu z pola bodov
	 *
	 * @param points
	 * @param position
	 * @param size
	 */
	static findMinAndMax(points, position, size){
		position.set(points[0]);
		size.set(points[0]);
		each(points, function(e, i){
			if(i){
				position.x = Math.min(points[i].x, position.x);
				position.y = Math.min(points[i].y, position.y);
				size.x = Math.max(points[i].x, size.x);
				size.y = Math.max(points[i].y, size.y);
			}
		});

		size.sub(position);
	}


	/**
	 * Skontroluje či sa súradnica nachadza na nejakom connectore
	 *
	 * @param vec
	 */
	checkConnectors(vec){
		//if(Creator.operation != OPERATION_DRAW_JOIN)
		//	return;

		this._selectedConnector = false;
		//this._connectors.forEach(function(e){
		each(this._connectors, (e, i) => {
			if(this._selectedConnector){
				return;
			}
			var d = e.getClone().mul(this.size);
			if (vec.dist(this.position.x + d.x, this.position.y + d.y) < SELECTOR_SIZE){
				this._selectedConnector = i;
				//if(!Creator.object)
				//	Creator.createObject(this);
			}
		});
	}

	getConnectorPosition(i){
		var conn = this._connectors[i];
		if(conn){
			return this._position.getClone().add(this._size.getClone().mul(conn));
		}
	}


	/**
	 * Vykreslí všetky connectory
	 *
	 * @param obj
	 */
	static drawConnectors(obj, ctx){
		if(Creator.operation != OPERATION_DRAW_JOIN &&
			(Creator.operation != OPERATION_DRAW_LINE || !Input.isKeyDown(L_CTRL_KEY))){
			return;
		}

		obj._connectors.forEach(e => drawConnector(e, obj, ctx));
	}


	/**
	 * Animuje pohyb alebo zmenu velkosti
	 *
	 * @param obj
	 * @param targetPos
	 * @param fps
	 */
	static animateMove(obj, targetPos, fps = FPS){
		var vec = targetPos.getClone().sub(obj.position).div(fps),
			counter = 0,
			int = setInterval(function(){
			obj.position.add(vec);
			draw();
			if(++counter == fps){
				clearInterval(int);
				obj.position.set(targetPos);
			}
		}, 1000 / fps);
	}


	/**
	 * Nastaví konkrétny typ pohybu
	 *
	 * @param obj
	 * @param vec
	 */
	static setMoveType(obj, vec){
		if (vec.dist(obj.position.x + (obj.size.x >> 1), obj.position.y) < SELECTOR_SIZE){
			obj.moveType = 0;
		}
		else if (vec.dist(obj.position.x + obj.size.x, obj.position.y + (obj.size.y >> 1)) < SELECTOR_SIZE){
			obj.moveType = 1;
		}
		else if (vec.dist(obj.position.x + (obj.size.x >> 1), obj.position.y + obj.size.y) < SELECTOR_SIZE){
			obj.moveType = 2;
		}
		else if (vec.dist(obj.position.x, obj.position.y + (obj.size.y >> 1)) < SELECTOR_SIZE){
			obj.moveType = 3;
		}
		else if (vec.dist(obj.position.x + obj.size.x, obj.position.y + obj.size.y) < SELECTOR_SIZE){
			obj.moveType = 5;
		}
		else if (vec.x > obj.position.x && vec.y > obj.position.y && vec.x < obj.position.x + obj.size.x && vec.y < obj.position.y + obj.size.y){
			obj.moveType = 4;
		}
	}

	/**
	 * Vráti nový objekt buď podla stringu alebo podla objektu ktorý obsahuje typ inštancie
	 *
	 * @param obj
	 * @returns {*}
	 */
	static createInstance(obj){
		var type = isString(obj) ? obj : obj._name;
		switch(type){
			case OBJECT_RECT :
				return new Rect();
			case OBJECT_ARC :
				return new Arc();
			case OBJECT_TABLE :
				return new Table();
			case OBJECT_TEXT :
				return new TextField("");
			case OBJECT_POLYGON :
				return new Polygon([0, 0, 0]);
			case OBJECT_LINE :
				return new Line([0, 0, 0]);
			case OBJECT_CLASS :
				return new Class();
			default :
				Logger.error(getMessage(MSG_UNKNOWN_OBJECT_NAME, obj._name));
				return null;
		}
	}

	/**
	 * Vytvorým nový objekt
	 *
	 * @param obj
	 * @param generateId
	 * @returns
	 */
	static create(obj, generateId = true){
		//ak niekto pošle JSON ako konštruktor
		if(isString(obj)){
			obj = JSON.parse(obj);
		}

		//vytvorím novú inštanciue
		var result = Entity.createInstance(obj);

		if(result){
			//nakopírujem atributy
			each(obj, function(e, i){
				if(e && isDefined(e["_x"]) && typeof isDefined(e["_y"])){
					result[i] = new GVector2f(e._x, e._y);
				}
				else if(i == "data"){
					result[i] = e.map(ee => ee.map(eee => eee));
				}
				else if(i == "points"){
					result[i] = e.map(ee => new GVector2f(ee._x, ee._y));
				}
				else if(i == "_id" && generateId){
					result[i] = Project.generateId();//Entity.getId();
				}
				else{
					result[i] = e;
				}
			});
			Logger.write(MSG_OBJECT_SUCCESSFULLY_CREATED, result.name || "Neznámy");
			Logger.log("Vytvoril sa objekt " + (result.name || "Neznámy"), LOGGER_OBJECT_CREATED);
		}
		return result;
	}

	/**
	 * vytvorý kópiu objektu
	 */
	/*
	static getClone(obj){
		var res = Entity.create(obj);
			res.position.add(obj.size);
		return res;
		var copy = Object.create(obj.__proto__);
		each(obj, function(e, i){
			if(e.constructor.name == "GVector2f")
				copy[i] = e.getClone();
			else if(i == "data"){
				copy[i] = [];
				e.forEach(function(ee){
					ee.forEach(eee => tmp.push(eee));
					copy[i].push(tmp);
				});
			}
			else if(i == "points"){
				copy[i] = [];
				e.forEach(ee => copy[i].push(ee.getClone().add(obj.size)));
			}
			else
				copy[i] = e;
		});

		copy.position.add(obj.size);
		return  clone;
	}
	*/
	/**
	 * GETTERS
	 *
	 * @returns {*}
	 */
	get id(){return this._id;}
	get name(){return this._name;}
	get size(){return this._size;}
	get layer(){return this._layer;}
	get radius(){return this._radius;}
	get locked(){return this._locked;}
	get minSize(){return this._minSize;}
	get visible(){return this._visible;}
	get selected(){return this._selected;}
	get position(){return this._position;}
	get fillColor(){return this._fillColor;}
	get borderWidth(){return this._borderWidth;}
	get borderColor(){return this._borderColor;}
	get selectedConnector(){return this._selectedConnector;}


	/**
	 * SETTERS
	 *
	 */
	//set id(val){this._id = val;}
	set layer(val){this._layer = val;}
	set locked(val){this._locked = val;}
	set minSize(val){this._minSize = val;}
	set selected(val){this._selected = val;}
	//set fillColor(val){this._fillColor = val;}
	//set borderWidth(val){this._borderWidth = val;}
	//set borderColor(val){this._borderColor = val;}
	set selectedConnector(val){this._selectedConnector = val;}
}

function testAnimation(){
	var obj = [];
	for(var i=0 ; i<100 ; i++){
		obj.push(new Rect(new GVector2f(Math.random() * canvas.width, Math.random() * canvas.height), new GVector2f(50, 50) , "blue"));
		Scene.addToScene(obj[obj.length - 1]);
		Entity.animateMove(obj[obj.length - 1], new GVector2f(300, 300));
	}

}
/*
	compatible: forEach, canvas 14.9.2016
*/
class CreatorViewer extends Entity{
	constructor(position = new GVector2f(100, 100), size = new GVector2f(400, 40), data = {}){
		super("CreatorViewer", position, size, data);
		this._items 		= [];
		this._canvas		= document.createElement("canvas");
		this._context 		= this._canvas.getContext('2d');
		
		Entity.changeAttr(this,{
			fillColor: MENU_FILL_COLOR,
			borderColor: MENU_BORDER_COLOR,
			borderWidth: MENU_BORDER_WIDTH,
			radius: MENU_RADIUS
		});
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}
	init(){
		var counter = 0,
			posY 	= 0;
		this.size.x = (MENU_WIDTH + MENU_OFFSET) * getLength(Creator.items) + MENU_OFFSET;
		this.size.y = MENU_HEIGHT + (MENU_OFFSET << 1);

		this._canvas.width 	= this._size.x;
		this._canvas.height	= MENU_HEIGHT << 4;
		this._context 		= this._canvas.getContext('2d');

		each(Creator.items, function(e, i, arr){
			posY = 0;
			arr[i].offset = counter;

			doRect({
				//bgColor: e.image,
				x: counter,
				y: posY,
				width: MENU_WIDTH,
				height: MENU_HEIGHT,
				radius: this._radius,
				borderColor: this._borderColor,
				fillColor: this._fillColor,
				borderWidth: this._borderWidth,
				ctx: this._context
			});

			if(isDefined(e.values)){
				//e.values.forEach(function(ee, ii){
				each(e.values, function(ee, ii){
					if(posY > 0){
						doRect({
							//bgColor: e.image,
							x: counter,
							y: posY,
							width: MENU_WIDTH,
							height: MENU_HEIGHT,
							radius: this._radius,
							borderColor: this._borderColor,
							fillColor: this._fillColor,
							borderWidth: this._borderWidth,
							ctx: this._context
						});
					}
					if(ee == Creator[i]){
						arr[i].selectedIndex = ii;
					}

					this._drawIcon(i, ee, counter, posY);
					posY += MENU_HEIGHT;
				}, this);
			}
			else if(e.type === "bool"){
				arr[i].selectedIndex = 0;
				this._drawIcon(i, e.value, counter, posY);
			}
			else if(i == ATTRIBUTE_FONT_COLOR){
				fillText("Abc", 
						 counter + (MENU_WIDTH >> 1), 
						 posY + (MENU_HEIGHT >> 1), 
						 DEFAULT_FONT_SIZE, 
						 Creator.fontColor, 
						 0, 
						 FONT_ALIGN_CENTER, 
						 this._context);
			}
			else{
				arr[i].selectedIndex = 0;
				this._drawIcon(i, Creator[i], counter, posY);
			}
			counter += MENU_WIDTH;
		}, this);
		this.changeOperation();
		//window.open(this._canvas.toDataURL("image/png"), '_blank');
	}

	_drawBool(value, posX, posY, width, height, offset){
		var center = posY + height >> 1;

		if(value){
			doLine({
				points:[new GVector2f(posX + offset, center),
						new GVector2f(posX + offset + width / 4, center + offset * 3),
						new GVector2f(posX + width - offset, center - offset * 2)],
				borderWidth: MENU_BORDER_WIDTH << 2,
				borderColor: CHECKBOX_COLOR_TRUE,
				ctx: this._context
			});
		}
		else{
			doLine({
				points:[[new GVector2f(posX + offset, posY + offset),
						 new GVector2f(posX + width - offset, posY + height - offset)],
						[new GVector2f(posX + offset, posY + height - offset),
						 new GVector2f(posX + width - offset, posY + offset)]],
				borderWidth: MENU_BORDER_WIDTH << 2,
				borderColor: CHECKBOX_COLOR_FALSE,
				ctx: this._context
			});
		}
	}

	_drawIcon(key, value, posX, posY, width = MENU_WIDTH, height = MENU_HEIGHT,  offset = 5){
		switch(key){
			case "allLayers" :
				this._drawBool(value, posX, posY, width, height, offset);
				break;
			case "controll" :
				this._drawBool(value, posX, posY, width, height, offset);
				break;
			case ATTRIBUTE_LINE_WIDTH :
				doLine({
					points: [posX + offset, 
							 posY + (height >> 1), 
							 posX + width - offset, 
							 posY + (height >> 1)],
					borderWidth: value,
					borderColor: MENU_BORDER_COLOR,
					ctx: this._context
				});
				break;
			case ATTRIBUTE_RADIUS :
				doRect({
					position: [posX + (offset << 1), posY + (offset << 1)],
					size: [width - (offset << 2), height - (offset << 2)],
					borderWidth: 5,
					borderColor: MENU_BORDER_COLOR,
					radius: value,
					ctx: this._context
				});
				break;
			case ATTRIBUTE_FILL_COLOR :
				doRect({
					position: [posX + (offset << 1), posY + (offset << 1)],
					size: [width - (offset << 2), height - (offset << 2)],
					borderWidth: 5,
					borderColor: MENU_BORDER_COLOR,
					fillColor: Creator[ATTRIBUTE_FILL_COLOR],
					ctx: this._context
				});
				break;
			case ATTRIBUTE_BRUSH_TYPE:
				if(value === "line"){
					doArc({
						position: [posX + (offset << 1), posY + (offset << 1)],
						size: [width - (offset << 2), height - (offset << 2)],
						fillColor: MENU_BORDER_COLOR,
						ctx: this._context
					});
				}
				else if(value === "fur"){
					var points = [];
					var centerX = posX + width / 2;
					var centerY = posY + height / 2;
					var sizeX = (width - offset * 2);
					var sizeY = (height - offset * 2);
					for(var i=0 ; i<100 ; i++){
						var valX = sizeX * (Math.random() - 0.5);
						var valY = sizeY * (Math.random() - 0.5);
						points[points.length] = [centerX + valX, 
												 centerY + valY, 
												 centerX - valX, 
												 centerY - valY];
					}
					doLine({
						points: points,
						borderWidth: 1,
						borderColor: MENU_BORDER_COLOR,
						ctx: this._context
					});
				}
				else{
					doRect({
						position: [posX, posY ],
						size: [width, height],
						bgImage: Paints.getBrush(value),
						ctx: this._context
					});
				}
				break;
			case ATTRIBUTE_BRUSH_COLOR :
				doArc({
					position: [posX + (offset << 1), posY + (offset << 1)],
					size: [width - (offset << 2), height - (offset << 2)],
					fillColor: Creator[ATTRIBUTE_BRUSH_COLOR],
					ctx: this._context
				});
				break;
			case ATTRIBUTE_BRUSH_SIZE :
				doArc({
					position: [posX + (width >> 1), posY + (height >> 1)],
					size: [value , value ],
					center: true,
					fillColor: MENU_BORDER_COLOR,
					ctx: this._context
				});
				break;
			case ATTRIBUTE_BORDER_COLOR :
				doRect({
					position: [posX + (offset << 1), posY + (offset << 1)],
					size: [width - (offset << 2), height - (offset << 2)],
					borderWidth: 5,
					borderColor: Creator[ATTRIBUTE_BORDER_COLOR],
					ctx: this._context
				});
				break;
			case ATTRIBUTE_BORDER_WIDTH :
				doRect({
					position: [posX + (offset << 1), posY + (offset << 1)],
					size: [width - (offset << 2), height - (offset << 2)],
					borderWidth: value,
					borderColor: MENU_BORDER_COLOR,
					ctx: this._context
				});
				break;
			case ATTRIBUTE_FONT_SIZE :
				fillText("Abc", 
						 posX + (width >> 1), 
						 posY + (height >> 1), 
						 value, 
						 MENU_FILL_COLOR, 
						 0, 
						 FONT_ALIGN_CENTER, 
						 this._context);
				break;
			default :
				fillText(key, 
						 posX + (width >> 1), 
						 posY + (height >> 1), 
						 7, 
						 MENU_FONT_COLOR, 
						 0, 
						 FONT_ALIGN_CENTER, 
						 this._context);
		}
	}

	_clickOn(x, y){
		if(y < this.position.y || x < this.position.x || x > this.position.x + this.size.x){
			return false;
		}
		var counter =  this.position.x + MENU_OFFSET,
			click 	= null,
			num;
		each(this._items, function(e, i, arr){
			if(!click && x > counter && x < counter + MENU_WIDTH){
				if(y < this.position.y + MENU_OFFSET + MENU_HEIGHT){
					click = e;
				}
				else if(e.itemsSelected){
					num = this.position.y + MENU_OFFSET;
					if(isDefined(e.item.values)){
						each(e.item.values, function(ee, ii){
							num += MENU_HEIGHT + MENU_OFFSET;
							if(!click && y > num && y < num + MENU_HEIGHT){
								click = e;
								e.item.selectedIndex = ii;
							}
						});
					}
				}
			}
			else if(e.itemsSelected){
				arr[i].itemsSelected = false;
			}

			counter += MENU_OFFSET + MENU_WIDTH;
		}, this);
		return click;
	}

	clickIn(x, y, doAct = true){//TODO skúsiť prerobiť do čitatelnejšej formy
		var inst = this,
			e = this._clickOn(x, y);
		if(!e){
			return false;
		}
		if(!doAct && e){
			return true;
		}
		if(isDefined(e.item.values)){
			Creator.setOpt(e.key, e.item.values[e.item.selectedIndex]);
			e.itemsSelected = !e.itemsSelected;
		}
		else if(e.item.type == "color"){
			pickUpColor(color => Creator.setOpt(e.key, color));
		}
		else if(e.item.type == "bool"){
			e.item.value = !e.item.value;
			if(e.key === "controll"){
				Creator._controllPress = e.item.value;
			}
			if(e.key === "allLayers"){
				Creator._allLayers = e.item.value;
			}
			inst.init();
			draw();
		}
		return true;
	}

	static allowedOption(operation, allowed){
		switch(operation){
			case 1000:
				return isIn(OBJECT_RECT, allowed);
			case 1001:
				return isIn(OBJECT_ARC, allowed);
			case 1002:
				return isIn(OBJECT_PAINT, allowed);
			case 1003:
				return isIn(OBJECT_LINE, allowed);
			case 1004:
				return isIn(OBJECT_JOIN, allowed);
			case 1006:
				return isIn(OBJECT_RUBBER, allowed);
			case 1007:
				return isIn(OBJECT_AREA, allowed);
		}
		return false;
	}

	changeOperation(){
		this._items = [];
		each(Creator.items, function(e, i){
			if(!CreatorViewer.allowedOption(Creator.operation, e.allowedFor)){
				return;
			}
			this._items[this._items.length] = {
				item: e,
				key: i,
				itemsSelected: false
			};

		}, this);
	}

	draw(){
		var counter = MENU_OFFSET;
		//this._items.forEach(function(e){
		each(this._items, function(e){
			doRect({
				bgImage: {
					x: e.item.offset,
					y: e.item.selectedIndex * MENU_HEIGHT,
					w: MENU_WIDTH,
					h: MENU_HEIGHT,
					img: this._canvas
				},
				x: this.position.x + counter,
				y: this.position.y + MENU_OFFSET,
				width: MENU_WIDTH,
				height: MENU_HEIGHT,
				radius: this._radius,
				borderColor: this._borderColor,
				borderWidth: this._borderWidth
			});

			fillText(e.key, 
					 this.position.x + counter + (MENU_WIDTH >> 1), 
					 this.position.y + MENU_OFFSET + (MENU_HEIGHT >> 1), 
					 7, 
					 MENU_FONT_COLOR, 
					 0, 
					 FONT_ALIGN_CENTER);

			if(e.itemsSelected && isDefined(e.item.values)){
				var num = this.position.y + MENU_OFFSET;
				//e.item.values.forEach(function(ee, ii){
				each(e.item.values, function(ee, ii){
					num += MENU_OFFSET + MENU_WIDTH;
					doRect({
						bgImage: {
							x: e.item.offset,
							y: ii * MENU_HEIGHT,
							w: MENU_WIDTH,
							h: MENU_HEIGHT,
							img: this._canvas
						},
						x: this.position.x + counter,
						y: num,
						width: MENU_WIDTH,
						height: MENU_HEIGHT,
						radius: this._radius,
						borderColor: this._borderColor,
						borderWidth: this._borderWidth
					});
				},this);
			}


			counter += MENU_WIDTH + MENU_OFFSET;
		}, this);
	}
}
class TextField extends Entity{
	constructor(text, position, size, fontColor = DEFAULT_FONT_COLOR){
		super("Text", position, size, {fillColor: DEFAULT_FILL_COLOR, radius: DEFAULT_RADIUS});//TODO premenovať na input
		this._text 			= text || "";
		this._textColor 	= fontColor;
		this._fontSize 		= DEFAULT_FONT_SIZE;
		this._moveType 		= -1;
		this._taskResult	= false;
		this._hightlight	= false
		this.size.x 		= calcTextWidth(text, this._fontSize + "pt " + DEFAULT_FONT_FAMILY) + (DEFAULT_FONT_OFFSET << 1);
		this.minSize 		= this.size.getClone();
		this._verticalTextAlign = FONT_VALIGN_TOP;
		this._horizontalTextAlign = FONT_HALIGN_LEFT;
		this._fontOffset 	= DEFAULT_FONT_OFFSET;
		this._link			= false;
		this.addConnector(new GVector2f(0, 0), new GVector2f(1, 0),new GVector2f(0, 1),new GVector2f(1, 1))
	}

	get moveType(){return this._moveType;}
	get text(){return this._text;}
	get taskResult(){return this._taskResult;}

	set taskResult(val){this._taskResult = val;}
	set moveType(val){this._moveType = val;}
	set verticalTextAlign(val){this._verticalTextAlign = val;}
	set horizontalTextAlign(val){this._horizontalTextAlign = val;}

	

	draw(ctx = context){
		var pos = this.position.getClone();

		doRect({
			shadow: this.moving && !this.locked,
			position: this.position,
			size: this.size,
			radius: this.radius,
			fillColor: this.fillColor,
			borderWidth: this._borderWidth,
			borderColor: !this._hightlight ? DEFAULT_BORDER_COLOR : this._hightlight == HIGHTLIGHT_CORRECT ? "green" : "red",
			draw: true,
			fill: true,
			ctx: ctx
		});


		ctx.textAlign = this._horizontalTextAlign;
		ctx.textBaseline = this._verticalTextAlign;
		ctx.fillStyle = this._textColor;
		ctx.font = this._fontSize + "pt " + DEFAULT_FONT_FAMILY;
		
		if(this._horizontalTextAlign == FONT_HALIGN_LEFT){
			pos.x += this._fontOffset;
		}
		else if(this._horizontalTextAlign == FONT_HALIGN_CENTER){
			pos.x += this.size.x >> 1;
		}
		else if(this._horizontalTextAlign == FONT_HALIGN_RIGHT){
			pos.x += this.size.x - this._fontOffset;
		}

		if(this._verticalTextAlign == FONT_VALIGN_MIDDLE){
			pos.y += this.size.y >> 1;
		}
		else if(this._verticalTextAlign == FONT_VALIGN_BOTT){
			pos.y += this.size.y - this._fontOffset;
		}

		ctx.fillText(this._text, pos.x, pos.y);

		drawBorder(ctx, this);
		Entity.drawConnectors(this, ctx);
	}

	clickIn(x, y){
		if(!this.clickInBoundingBox(x, y)){
			return false;
		}

		var pos = this.position,
			vec = new GVector2f(x, y);


		this.checkConnectors(vec);
		if(this._selectedConnector){
			return true;
		}

		if(vec.dist(pos.x + (this.size.x >> 1), pos.y) < SELECTOR_SIZE){
			this._moveType = 0;
		}
		else if(vec.dist(pos.x + this.size.x, pos.y + (this.size.y >> 1)) < SELECTOR_SIZE){
			this._moveType = 1;
		}
		else if(vec.dist(pos.x +(this.size.x >> 1), pos.y + this.size.y) < SELECTOR_SIZE){
			this._moveType = 2;
		}
		else if(vec.dist(pos.x, pos.y + (this.size.y >> 1)) < SELECTOR_SIZE){
			this._moveType = 3;
		}
		else if(vec.dist(pos.x + this.size.x, pos.y + this.size.y) < SELECTOR_SIZE){
			this._moveType = 5;
		}
		else if(x > this.position.x && y > this.position.y && x < this.position.x + this.size.x && y < this.position.y + this.size.y){
			this._moveType = 4;
		}
		return this._moveType >= 0;
	}

	doubleClickIn(x, y){
		if(!this.clickInBoundingBox(x, y)){
			return false;
		}

		getText(this._text, new GVector2f(x, y), this._size.getClone().sub(4), function(val){
			if(val.length == 0){
				Scene.remove(this);
			}
			this._text = val;
			this._size.x = calcTextWidth(val) + (DEFAULT_FONT_OFFSET << 1);

			if(Task && this.taskResult){
				this._hightlight = Task.checkResult(this) ? HIGHTLIGHT_CORRECT : HIGHTLIGHT_WRONG;
			}
		}, this);

		return true;
	}

	set text(val){
		this._text = val;
		this._size.x = calcTextWidth(val) + (DEFAULT_FONT_OFFSET << 1);
	}



}
class Table extends Entity{
	constructor(position, size, data = [[]]){
		super(OBJECT_TABLE, position, size, {borderColor: shadeColor1(TABLE_HEADER_COLOR, -20), radius: TABLE_RADIUS});
		this.data = data;
		this._headerColor 	= TABLE_HEADER_COLOR;
		this.moveType 		= -1;
		this._bodyColor	 	= TABLE_BODY_COLOR;
		this._textOffset	= TABLE_TEXT_OFFSET;
		this._columnWidth 	= this._size.x / this.data[0].length;
		this._lineHeight	= TABLE_LINE_HEIGHT;

		this._fontSize 		= DEFAULT_FONT_SIZE;

		this.size.set(this._size.x, data.length * this._lineHeight);
		this._calcMaxTextWidth();
	}

	clear(pos, type){
		if(type == "row"){
			var row = parseInt((pos - this._position.y) / this._lineHeight);
			this.data[row].forEach(function(e, i){
				this.data[row][i] = "";
			}, this);
		}
		else if(type == "column"){
			var column = parseInt((pos - this._position.x) / this._columnWidth);
			this.data.forEach(function(e){
				e[column] = "";
			});
		}
		else if(type == "table"){
			this.data.forEach(function(e){
				e.forEach(function(ee, i){
					e[i] = "";
				}, this);
			}, this);
		}
	}

	addRow(y, type){
		var row = parseInt((y - this._position.y) / this._lineHeight),
			offset = 0;

		if(type == "below")
			offset++;

		var newRow = [];
		this.data[0].forEach(function(){
			newRow.push([""]);
		});
		this.data.splice(row + offset, 0, newRow);
		this._size.y = this.data.length * this._lineHeight;
		this._checkSize();
	}

	addColumn(x, type){
		var column = parseInt((x - this._position.x) / this._columnWidth),
			offset = 0;
		if(type == "right")
			offset++;

		this.data.forEach(function(e){
			e.splice(column + offset, 0, [""]);
		});

		this._columnWidth 	= this._size.x / this.data[0].length;
		this._checkSize();

	}

	removeRow(y){
		var row = parseInt((y - this._position.y) / this._lineHeight);

		if(row > 0){
			this.data.splice(row, 1);
		}
		else{
			Logger.error(getMessage(MSG_TRY_REMOVE_TABLE_HEAD));
		}
		this._size.y = this.data.length * this._lineHeight;
		this._calcMaxTextWidth();

		if(this.data.length == 0)
			Scene.remove(this);
	}

	removeColumn(x){
		var column = parseInt((x - this._position.x) / this._columnWidth);

		this.data.forEach(function(e){
			e.splice(column, 1);
		});
		this._columnWidth 	= this._size.x / this.data[0].length;
		this._calcMaxTextWidth();

		if(this.data[0].length == 0)
			Scene.remove(this);
	}

	clickIn(x, y){
		if(!this.clickInBoundingBox(x, y))
			return false;

		var pos = this.position,
			vec = new GVector2f(x, y);

		if(vec.dist(pos.x + (this.size.x >> 1), pos.y) < SELECTOR_SIZE)
			this.moveType = 0;
		else if(vec.dist(pos.x + this.size.x, pos.y + (this.size.y >> 1)) < SELECTOR_SIZE)
			this.moveType = 1;
		else if(vec.dist(pos.x +(this.size.x >> 1), pos.y + this.size.y) < SELECTOR_SIZE)
			this.moveType = 2;
		else if(vec.dist(pos.x, pos.y + (this.size.y >> 1)) < SELECTOR_SIZE)
			this.moveType = 3;
		else if(vec.dist(pos.x + this.size.x, pos.y + this.size.y) < SELECTOR_SIZE)
			this.moveType = 5;
		else if(x > this.position.x && y > this.position.y && x < this.position.x + this.size.x && y < this.position.y + this.size.y)
			this.moveType = 4;
		return this.moveType >= 0;
	}

	_calcMaxTextWidth(value){
		var w;
		context.font = this._fontSize + "pt " + DEFAULT_FONT;
		if(isString(value)){
			w = context.measureText(value).width + (this._textOffset << 1);
			if(w > this._maxTextWidth){
				this._maxTextWidth = w;
				return;
			}
		}
		this._maxTextWidth = 0;
		this.data.forEach(function(e){
			e.forEach(function(ee){
				var w = context.measureText(ee).width + (this._textOffset << 1);
				if(w > this._maxTextWidth)
					this._maxTextWidth = w;
			},this);
		}, this);
	}

	_checkSize(){
		if(this.size.y < this._fontSize * 2 * this.data.length)
			this.size.y = this._fontSize * 2 * this.data.length;

		this._lineHeight = this.size.y / this.data.length;
		this._columnWidth = Math.max(this.size.x / this.data[0].length, this._maxTextWidth);
		this.size.x = this._columnWidth * this.data[0].length;
	}

	doubleClickIn(x, y){
		if(!this.clickInBoundingBox(x, y) || this.locked)
			return false;

		var row = parseInt((y - this._position.y) / this._lineHeight),
			column = parseInt((x - this._position.x) / this._columnWidth),
			posY = this._position.y + row * this._lineHeight + 1,
			posX = this._position.x + column * this._columnWidth + 1,
			w = this._columnWidth;

		getText(this.data[row][column], new GVector2f(posX, posY), new GVector2f(w, this._lineHeight).sub(4), function(val){
			this.data[row][column] = val;
			this._calcMaxTextWidth(val);
			this._checkSize();
		}, this);

		return true;
	}

	draw(ctx = context){
		var i,
			j,
			posX = this._position.x,
			posY = this._position.y,
			points = [];


		if(this.moveType >= 0)
			this._checkSize();

		//FILL HEADER
		//TODO pre fillText doplniť context do ktorého sa má kresliť
		doRect({
			position: this._position,
			width: this._size.x,
			height: this._lineHeight,
			radius: {tr: this.radius, tl: this.radius},
			fillColor: this._headerColor,
			shadow: this.moving && !this.locked,
			ctx: ctx
		});

		//FILL BODY
		doRect({
			x: this._position.x,
			y: this._position.y +  this._lineHeight,
			width: this._size.x,
			height: this._lineHeight * (this.data.length - 1),
			radius: {br: this.radius, bl: this.radius},
			fillColor: this._bodyColor,
			shadow: this.moving && !this.locked,
			ctx: ctx
		});

		//DRAW BORDER
		doRect({
			position: this._position,
			size: this._size,
			radius: this.radius,
			borderColor: this.borderColor,
			borderWidth: this.borderWidth,
			ctx: ctx
		});

		///DRAW HEADER TEXT
		for(i=0 ; i<this.data[0].length ; i++) {
			if (i > 0)
				points.push([posX, this._position.y, posX, this._position.y + this.data.length * this._lineHeight]);
			fillText(this.data[0][i], posX + (this._columnWidth >> 1),  this._position.y + (this._lineHeight >> 1), this._fontSize, DEFAULT_FONT_COLOR, 0, FONT_ALIGN_CENTER);
			posX += this._columnWidth;
		}

		//DRAW BODY TEXT
		for(i=1 ; i<this.data.length ; i++){
			posX = this._position.x;
			posY += this._lineHeight;
			if(i > 0)
				points.push([this._position.x, posY, this._position.x + this._size.x, posY]);
			for(j=0 ; j<this.data[i].length ; j++) {
				fillText(this.data[i][j], posX + (this._columnWidth >> 1),  posY + (this._lineHeight >> 1), this._fontSize, DEFAULT_FONT_COLOR, 0, FONT_ALIGN_CENTER);
				posX += this._columnWidth;
			}
		}

		//HORIZONTAL AND VERTICAL LINES
		doLine({
			points: points,
			borderWidth: this.borderWidth,
			borderColor: this.borderColor,
			ctx: ctx
		});

		drawBorder(ctx, this);
	}
}
class Class extends Table{
	constructor(position, size, title, attributes = {}, methods = {}, access = ACCESS_PUBLIC){
		super(position, size, [[]]);
		this._name = OBJECT_CLASS;
		this._title = title;
		this._access = access;
		this._methods = methods;
		this._attr = attributes;
		this._fontSize	= 15;
		this._lineHeight = 30;
		this._headerColor = "#24D330";
		this._bodyColor = "#CCFFCC";
		Entity.changeAttr(this, ATTRIBUTE_BORDER_COLOR, shadeColor1(this._headerColor, -20));

		this._makeData();

		this.size.set(this._size.x, this.data.length * this._lineHeight);
		this._calcMaxTextWidth();
		this._checkSize();
	}

	static _parseAttribute(string){
		var tmp = string.replace(/ /g, '').split(":");
		return {
			type: tmp[1],
			access: tmp[0][0],
			name:  tmp[0].slice(1, tmp[0].length)
		};
	}

	static _parseMethod(string){
		var tmp = string.replace(/ /g, '').split(")"),
			tmp2 = tmp[0].split("("),
			args = tmp2[1].split(",").map(a => a.split(":"));
		if(args[0][0] == "void")
			args = "void";
		return {
			returnType: tmp[1].replace(":", ""),
			access: tmp[0][0],
			name:  tmp2[0].slice(1, tmp2[0].length),
			args: args
		};
	}

	addMethod(name, returnType = "void", args = "void", access = ACCESS_PUBLIC){
		this._methods[name] = {
			name: name,
			retType: returnType,
			access: access,
			args: args
		};
		this._makeData();
	}

	static toAccess(access){
		switch(access){
			case ACCESS_PUBLIC: return "public";
			case ACCESS_PRIVATE: return "private";
			case ACCESS_PROTECTED: return "protected";
			default : return "";
		}
	}

	addAttribute(name, type, access = ACCESS_PUBLIC){
		this._attr[name] = {
			name: name,
			type: type,
			access: access
		};
		this._makeData();
	}

	static _methodToString(e){
		var args = (Array.isArray(e.args) ? e.args.map(e => e[0] + ": " + e[1]).join(", ") : e.args);
		return 	e.access + " " + e.name + "(" + args + "): " + e.retType;
	}

	static _attributeToString(e){
		return e.access + " " + e.name + ": " + e.type;
	}

	_makeData(){
		this.data = [[this._title]];
		each(this._attr, e => this.data.push([Class._attributeToString(e)]));
		each(this._methods, e => this.data.push([Class._methodToString(e)]));
	}

	getJavaSource(){
		var result = Class.toAccess(this._access) + " class " + this._title + "{\n\t";

		result += $.map(this._attr, e => Class.toAccess(e.access) + " " + e.type + " " + e.name + ";\n").join("\t");

		result += $.map(this._methods, function(e){
			var args = (Array.isArray(e.args) ? e.args.map(e => e[1] + " " + e[0]).join(", ") : ""),
				subRes = "\n\t" + Class.toAccess(e.access) + " " + e.retType + " ";
				subRes += e.name + "(" + args + "){\n\t\tTODO auto generated body\n\t}\n";
			return subRes;
		}).join("\t");
		result += "}";

		return result;
	}
}
class Polygon extends Entity{
	constructor(points, color){
		super(OBJECT_POLYGON, new GVector2f(), new GVector2f(), {fillColor: color});
		this.points 		= points;
		this.movingPoint	= -1;
		if(points.length < 3){
			Logger.warn(getMessage(MSG_POLYGON_WITH_TOO_LESS_POINTS));
			Scene.remove(this);
		}

		Entity.findMinAndMax(this.points, this.position, this.size);
	}


	doubleClickIn(x, y){
		if(!this.clickInBoundingBox(x, y)){
			return false;
		}

		this.points.forEach(function(e, i){
			if(new GVector2f(x, y).dist(e) < SELECTOR_SIZE){
				this.points.splice(i, 1);
				Entity.findMinAndMax(this.points, this.position, this.size);
			}
		}, this);

		if(this.points.length < 3){
			Scene.remove(this);
		}

		return true;
	}

	clickIn(x, y) {
		if (!this.clickInBoundingBox(x, y)){
			return false;
		}

		this.movingPoint = -1;
		var vec = new GVector2f(x, y);
		this.points.forEach(function(e,i, points){
			if(this.movingPoint >= 0){
				return true;
			}
			if(vec.dist(e) < SELECTOR_SIZE){
				this.movingPoint = i;
			}
			else if(i < points.length && vec.dist((e.x + (points[(i + 1) % points.length].x) >> 1),
													  (e.y + (points[(i + 1) % points.length].y) >> 1)) < SELECTOR_SIZE){
				this.movingPoint = parseFloat(i) + 0.5;
			}
		}, this);

		if(this.movingPoint >= 0){
			return true;
		}

		return Polygon.determineClick(this.points, x, y);
	}

	static determineClick(points, x, y){
		for(var i=0 ; i<points.length ; i++){
			var big = i + 1;
			var less = i - 1;
			if(i === 0){
				less = points.length - 1;
			}
			if(i === points.length - 1){
				big = 0;
			}

			var vec1 = points[i].getClone().sub(points[less]);
			var vec2 = points[big].getClone().sub(points[i]);
			var toMouse = new GVector2f(x, y).sub(points[i]);
			if(angleBetween(vec1, vec2) < angleBetween(vec1, toMouse)){
				return false;
			}
		}

		return true;
	}

	draw(ctx = context){
		doPolygon({
			shadow: this.moving && !this.locked,
			points: this.points,
			fillColor: this.fillColor,
			borderColor: this.borderColor,
			borderWidth: this.borderWidth,
			radius: this.radius,
			ctx: ctx
		});
		if(this.selected){
			drawBorder(ctx, this, {});
			for(var i=0 ; i<this.points.length ; i++){
				var min = i - 1;
				if(i === 0){
					min = this.points.length - 1;
				}
				drawSelectArc(ctx, this.points[i].x, this.points[i].y);
				drawSelectArc(ctx, (this.points[i].x + this.points[min].x) >> 1, (this.points[i].y + this.points[min].y) >> 1);
			}
		}

	}
}
class Join extends Entity{
	constructor(obj1, type = JOIN_LINEAR){
		super(OBJECT_JOIN);
		this._obj1 				= obj1;
		this._obj1_connector 	= obj1.selectedConnector;
		this._obj2 				= null;
		this._obj2_connector 	= null;
		this._lineType 			= type;
		Entity.changeAttr(this, {borderColor: "blue", borderWidth: 5});

		this._tmpPos 			= obj1.position.getClone();
	}

	set obj2(val){
		this._obj2 = val;
		this._obj2_connector = val.selectedConnector;
		this._obj1.selectedConnector = false;
		this._obj2.selectedConnector = false;
	}

	set type(val){
		this._lineType = val;
		draw();
	}

	updateCreatingPosition(pos){
		this._tmpPos.set(pos);
	}

	draw(ctx = context){
		if(this._obj1.position == null){
			Logger.warn(getMessage(MSG_TRY_DRAW_WRONG_JOIN));
			Scene.remove(this);
			return;
		}

		var obj1pos = this._obj1.position.getClone().add(this._obj1.size.getClone().mul(this._obj1_connector)),
			obj2pos,
			array = [];


		if(this._obj2 != null){
			obj2pos = this._obj2.position.getClone().add(this._obj2.size.getClone().mul(this._obj2_connector));
		}
		else{
			obj2pos = this._tmpPos;
		}

		array.push(obj1pos);

		if(this._lineType != JOIN_LINEAR){
			var center = obj1pos.getClone().add(obj2pos).br(1),
				diff = obj1pos.getClone().sub(obj2pos);

			diff.x = Math.abs(diff.x);
			diff.y = Math.abs(diff.y);


			if(diff.x > diff.y) {
				if (this._lineType == JOIN_SEQUENCAL) {
					array.push(new GVector2f(center.x, obj1pos.y));
					array.push(new GVector2f(center.x, obj2pos.y));
					array.push(obj2pos);
				}
				else if (this._lineType == JOIN_BAZIER){
					array.push([new GVector2f(center.x, obj1pos.y),new GVector2f(center.x, obj2pos.y), obj2pos]);
				}
			}
			else if(diff.x <= diff.y){
				if(this._lineType == JOIN_SEQUENCAL) {
					array.push(new GVector2f(obj1pos.x, center.y));
					array.push(new GVector2f(obj2pos.x, center.y));
					array.push(obj2pos);
				}
				else if(this._lineType == JOIN_BAZIER)
					array.push([new GVector2f(obj1pos.x, center.y), new GVector2f(obj2pos.x, center.y), obj2pos]);
			}
		}
		else{
			array.push(obj2pos);
		}

		if(this._lineType == JOIN_BAZIER){
			drawBazierCurve(array, this.borderWidth, this.borderColor);
		}
		else{
			doLine({points: array, borderWidth: this.borderWidth, borderColor: this.borderColor, ctx: ctx});
		}
	}
}
class Rect extends Entity {
	constructor(position, size, fillColor){
		super(OBJECT_RECT, position, size, {fillColor: fillColor});
		this.moveType 	= -1;
		this.minSize 	= new GVector2f(SELECTOR_SIZE);
		this.addConnector(new GVector2f(0, 0), new GVector2f(1, 0),new GVector2f(0, 1),new GVector2f(1, 1));
		//this._radius = Creator.radius;
		//console.log("creator: " + Creator.radius);
	}

//	set radius(val){
		//this._radius = parseFloat(val);
		/*
		if(this._radius < 1)
			this._radius *= 100;
		*/
//		this._checkRadius();
//	}

	updateCreatingPosition(pos){
		this.size.x = pos.x - this.position.x;
		this.size.y = pos.y - this.position.y;
	}

	_hover(x, y){
		if(this.clickInBoundingBox(x, y)){
			if(this._locked){
				setCursor(CURSOR_NOT_ALLOWED);
			}
			else{
				setCursor(CURSOR_POINTER);
			}
			return true;
		}

		setCursor(CURSOR_DEFAULT);
		return false;
	}

	_clickIn(x, y){
		var vec = new GVector2f(x, y);
		this.moveType = -1;
		if(Input.isKeyDown(KEY_L_CTRL)){
			this.checkConnectors(vec);
			if(this._selectedConnector){
				return true;
			}
		}
		
		Entity.setMoveType(this, vec);

		return this.moveType >= 0;
	}

	_checkRadius(){
		var minRadius = Math.min(this.size.x, this.size.y) >> 1;
		return this._radius > minRadius ? minRadius : this._radius;
	}

	_draw(ctx){
		doRect({
			position: this.position,
			size: this.size,
			fillColor: this.fillColor,
			shadow: this.moving && !this.locked,
			borderWidth: this.borderWidth,
			borderColor: this.borderColor,
			radius: this._checkRadius(),
			ctx: ctx
		});
		Entity.drawConnectors(this, ctx);

		drawBorder(ctx, this);
	}
}

class Paint extends Entity{
	constructor(){
		super(OBJECT_PAINT, new GVector2f(), new GVector2f());
		this._points 		= [Paint.defArray()];
		this._count 		= 0;
		this._canvas		= Project.canvasManager.createCanvas(Project.canvas.width, Project.canvas.height, "canvas" + Project.generateId());
		this.onScreenResize();
		this._editBackup	= [];
	}
	get points(){
		return this._points;
	}

	isEmpty(){
		for(var i=0 ; i<this._points.length ; i++){
			if(this._points[i].points.length > 0){
				return false;
			}
		}
		return true;	
	}
	onScreenResize(){
		this._canvas.setCanvasSize(canvas.width, canvas.height);
		this.redraw(this._points);
	}
	static defArray(){
		return {
			id: PaintManager.getId(),
			color: null,
			action: null,
			size: null,
			type: null,
			points: [],
			min: null,
			max: null,
			forRemove: false
		};
	}

	animate(speed = 20, limit = this._points.length - 1){
		var points 	= this._points,
			i 		= 0,
			ii 		= 0,
			inst 	= this;
		this.cleanUp();

		var interval = setInterval(function(){
			if(i >= limit || i >= points.length - 1){
				clearInterval(interval);
				return;
			}
			//inst.addPoint(points[i].points[ii], points[i].color);
			Creator.setOpt(ATTRIBUTE_BRUSH_COLOR, points[i].color);
			Creator.setOpt(ATTRIBUTE_BRUSH_SIZE, points[i].size);
			Creator.setOpt(ATTRIBUTE_BRUSH_TYPE, points[i].type);
			inst.addPoint(points[i].points[ii]);

			if(ii++ == points[i].points.length - 1){
				inst.breakLine();
				i++;
				ii = 0;
			}
			draw();
		}, speed);
	}

	redraw(points, limit = points.length - 1){
		this.cleanUp();
		var res = [];
		points.forEach(function(e, i){
			if(i > limit || isNull(e.color)){
				return;
			}
			res.push(e);

			e.points.forEach(function(ee, ii, arr){
				if(ii){
					//Paints.drawLine(this._canvas.context, ee, arr[ii - 1], e.size, e.color, e.action, e.type);
					Paints.drawLine({
						ctx: this._canvas.context, 
						pointA: ee,
						pointB: arr[ii - 1], 
						action: e.action,
						points: arr, 
						brushSize: e.size, 
						brushType: e.type, 
						brushColor: e.color
					});
				}
			}, this);
		}, this);
		this._points = res;
		if(points.length > 0 && points[points.length - 1].points.length){
			this.breakLine();
		}
		if(!points[points.length - 1].points.length){
			this._points.push(Paint.defArray());
		}
		Logger.log("prekresluje sa " + this.constructor.name, LOGGER_DRAW);
	}

	undo(){
		if(this._points.length === 1){
			return false;
		}

		if(isNull(this._points[this._points.length - 1].color)){
			this._points.pop();
		}

		this._editBackup.push(this._points.pop());

		this.redraw(this._points);
		if(this._points.length === 0){
			this._points.push(Paint.defArray());
		}
	}

	redo(){
		if(this._editBackup.length === 0){
			return false;
		}

		if(isNull(this._points[this._points.length - 1].color)){
			this._points.pop();
		}
		this._points.push(this._editBackup.pop());
		this.redraw(this._points); // toto nemusí prepisovať celé
	}

	addLine(line){
		console.log("prijala sa line: ", line);
	}
	/*
	animateLine(line, time = 0){
		if(time === 0){
			//console.log("pred: ", this._points);
			//console.log("last: ", last);
			if(this._points[this._points.length - 1].points.length > 0){
				this._points.push(line);

				//console.log("a");
			}
			else{
				this._points[this._points.length - 1] = line;
				this._points.push(Paint.defArray());
				//console.log("b");
			}
			//console.log("po: ", this._points);
			this.redraw(this._points);
		}
		draw();
	}
	 */

	/**
	 * Pridá nový pod do malby podla aktualne nakresleneho štetca
	 *
	 * @param point
	 */
	addPoint(point){
		if(this._points.length === 0){
			this._points.push(Paint.defArray());
		}

		var lastArr = this._points[this._points.length - 1],
			arr = lastArr.points;

		if(CUT_OFF_PATHS_BEFORE && arr.length > 2){
			var p1 = arr[arr.length - 2].getClone().sub(arr[arr.length - 1]);
			var p2 = arr[arr.length - 1].getClone().sub(point);
			var angle = GVector2f.angle(p1, p2) * p2.length();
			if(angle < CUT_OFF_BEFORE_DISTANCE){
				return;
			}
		}

		this._editBackup = [];
		this._count++;

		if(isNull(lastArr.color)){ //TODO toto nižšie sa bude asi stále prepisovať
			lastArr.color = Creator.brushColor;
			lastArr.action = Paints.action;
			lastArr.type = Creator.brushType;
			lastArr.size = Creator.brushSize;
			lastArr.min = point.getClone();
			lastArr.max = point.getClone();
		}

		if(arr.length){
			//Paints.drawLine(this._canvas.context, arr[arr.length - 1], point, Creator.brushSize, Creator.brushColor, Paints.action, Creator.brushType);
			Paints.drawLine({
				ctx: this._canvas.context, 
				pointA: arr[arr.length - 1],
				pointB: point,
				points: arr
			});
		}
		arr.push(point);
		lastArr.min.x = Math.min(lastArr.min.x, point.x);
		lastArr.min.y = Math.min(lastArr.min.y, point.y);
		lastArr.max.x = Math.max(lastArr.max.x, point.x);
		lastArr.max.y = Math.max(lastArr.max.y, point.y);
	}

	fromObject(content, concat = false){
		each(content, ee => {
			each(ee.points, (e, i , arr) => {
				arr[i] = new GVector2f(e._x, e._y);
			});
		});
		this.redraw(concat ? content.concat(this._points) : content);
	}

	toObject(){
		return this._points;
	}

	cleanUp(){
		this._points = [Paint.defArray()];
		this._points[this._actColor] = [[]];
		this._count = 0;
		this._canvas.context.clearRect(0, 0, canvas.width, canvas.height);
		Logger.log(getMessage(MSG_OBJECT_CLEANED, this.constructor.name), LOGGER_OBJECT_CLEANED);
	}

	static roundPath(path, maxDist){
		for(var i = path.points.length - 3 ; i-- ; i > 0){
			var p1 = path.points[i], 
				p2 = path.points[i + 1], 
				p3 = path.points[i + 2];
			var angle = GVector2f.angle(p2.getClone().sub(p1), p3.getClone().sub(p1));
			var b = p2.getClone().sub(p3).length();
			var height = b * angle;
			if(height < maxDist){
				path.points.splice(i + 1, 1);
			}
		}
	}

	breakLine(){
		if(this._points.length === 0){
			this._points.push(Paint.defArray());
		}
		else if(this._points[this._points.length - 1].points.length < 2){
			this._points[this._points.length - 1] = Paint.defArray();
		}
		else{
			this._points.push(Paint.defArray());
			if(CUT_OFF_PATHS_AFTER){
				Paint.roundPath(this._points[this._points.length - 2], CUT_OFF_AFTER_DISTANCE);
				this.redraw(this._points);
			}
			return this._points[this._points.length - 2];
		}
		return false;
	}

	findPathsForRemove(pos, radius){
		//TODO dorobiť na porovnávanie čiarok pretože toto porovnáva len body a pri rýchlich pohyboch to nemusí trafiť
		var pointsToRemove = [];
		each(this._points, (e, i) => {
			if(!e.forRemove && e.min && e.max){
				var offset = (Creator.brushSize >> 1) + (e.size >> 1);
				if(pos.x + offset > e.min.x - e.size && pos.y + offset > e.min.y &&
				   pos.x - offset < e.max.x + e.size && pos.y - offset < e.max.y ){
					each(e.points, ee => {
						if(!e.forRemove && ee.dist(pos) < Creator.brushSize){//TODO tu má byť asi offset
							e.forRemove = true;
							pointsToRemove.push({
								line: e, 
								points: [],
								lineIndex: i
							});
						}
					});
				}
			}
		});
		return false;
		/*
		if(pointsToRemove.length){//ak existuje čiara ktorá sa má vymazať
			console.log(pointsToRemove);
			each(pointsToRemove, (e) => {
				var line1Points = [];
				var line2Points = [];
				each(e.line.points, (ee) => {
					if(ee.dist(pos) < Creator.brushSize)
						e.points.push(ee);
					else{
						if(e.points) // druha čast
							line1Points.push(ee);
						else // prvá časť
							line2Points.push(ee);
					}
				});
				//vymaže povodnu čiaru
				console.log(e.line.points, e.points, line1Points, line2Points)
				this._points.splice(e.lineIndex, 1);
				//vytvorí prvú čast
				var line1 = {};
				line1.action = e.line.action;
				line1.color = e.line.color;
				line1.forRemove = false;
				//line1.max; //TODO dopočítať
				//line1.min; //TODO dopočítať
				line1.points = line1Points;
				line1.size = e.line.size;
				line1.type = e.line.type;
				this._points.push(line1);
				this.redraw(this._points);
			})
		}
		*/
		
	}

	removeSelectedPaths(){
		var i = this._points.length;
		while (i--){
			if(this._points[i].forRemove){
				this._points.splice(i, 1);
			}
		}
		this.redraw(this._points);
	}

	draw(ctx = context) {
		if (!this.visible){
			return;
		}
		ctx.drawImage(this._canvas.canvas, 0, 0);
		/*
		each(this._points, e => {
			if(!isNull(e.min) && e.points.length > 4)
				doRect({
					x: e.min.x,
					y: e.min.y,
					width: e.max.x - e.min.x,
					height: e.max.y - e.min.y,
					borderColor: "black",
					ctx: ctx
				})
		})
		*/
	}
}
class Line extends Entity{
	constructor(points, width, fillColor, targetA = null, targetB = null) {
		super(OBJECT_LINE, new GVector2f(), new GVector2f(), {fillColor: fillColor, borderWidth: width});
		this._points 			= points;
		this.movingPoint		= -1;
		this._lineCap			= LINE_CAP_BUTT;
		this._joinType			= LINE_JOIN_MITER;
		this._lineStyle			= LINE_STYLE_NORMAL;
		this._lineType			= JOIN_LINEAR;
		this._arrow 			= new Image();
		this._arrow.src 		= "img/arrow.png";
		this._arrowEndType		= 0;
		this._arrowStartType	= 0;
		this.targetA 			= targetA;
		this.targetB 			= targetB;

		this._startText = null;
		/*
		this._startText = {
			text: "startText",
			dist: 70,
			angle: Math.PI / 2
		};
		*/
		this._text_A = "začiatok 10%";
		this._text_B = "koniec 90%";

		if(points.length < 2){
			Logger.warn(getMessage(MSG_LINE_WITH_TOO_LESS_POINTS));
			Scene.remove(this);
		}
		Entity.findMinAndMax(this._points, this.position, this.size);
	}

	setStartText(text, dist = 0, angle = 0, ctx = context){
		if(arguments.length === 0 || !isString(text) || text.length === 0){
			this._startText = null;
			return;
		}
		var fontSize = 10;
		this._startText = {
			text: text,
			dist: dist,
			fontSize: fontSize,
			angle: angle,
			textWidth : CanvasHandler.calcTextWidth(ctx, text, fontSize + "pt Comic Sans MS")
		};

		if(this._startText.dist === 0){
			this._startText.dist = this._startText.textWidth;
		}
	}

	get points(){return this._points;}

	set lineCap(val){this._lineCap = val;}
	set arrowEndType(val){this._arrowEndType = val;}
	set lineType(val){this._lineType = val;}
	set joinType(val){this._joinType = val;}
	set lineStyle(val){this._lineStyle = val;}
	set arrowStartType(val){this._arrowStartType = val;}

	doubleClickIn(x, y){
		if(!this.clickInBoundingBox(x, y)){
			return false;
		}

		this._points.forEach(function(e, i){
			if(new GVector2f(x, y).dist(e) < SELECTOR_SIZE){
				this._points.splice(i, 1);
				Entity.findMinAndMax(this._points, this.position, this.size);
			}
		}, this);

		//TODO determineClick ak niečo vráti tak sa vytvorí text

		if(this._points.length < 2){
			Scene.remove(this);
		}

		return true;
	}

	_clickIn(x, y){
		this.movingPoint = -1;

		if(this._startText !== null){
			var final = this._points[this._points.length - 1].getClone();
			var semiFinal = this._points[this._points.length - 2].getClone();
			var vector = semiFinal.sub(final).normalize();
			var angle = this._startText.angle;
			var newVector = new GVector2f(vector.x * Math.cos(angle) - vector.y * Math.sin(angle),
				vector.x * Math.sin(angle) + vector.y * Math.cos(angle));
			var position = final.add(newVector.mul(this._startText.dist));
			if(position.dist(new GVector2f(x, y)) < this._startText.textWidth){
				console.log("aaaaaaaaaanooooooooo");
			}
		}


		this._points.forEach(function(e,i, points){
			if(this.movingPoint >= 0){
				return true;
			}
			if(new GVector2f(x, y).dist(e) < SELECTOR_SIZE){
				this.movingPoint = i;
			}
			else if(i + 1 < points.length &&
				new GVector2f(x, y).dist((e.x + (points[i + 1].x) >> 1),
					(e.y + (points[i + 1].y) >> 1)) < SELECTOR_SIZE){
				this.movingPoint = parseFloat(i) + 0.5;
			}
		}, this);
		if(this.movingPoint >= 0){
			return this.movingPoint >= 0;
		}

		for(var i=1 ; i<this._points.length ; i++){
			if(Line.determineClick(this._points[i-1], this._points[i], x, y, 10)){
				return true;
			}
		}
		return false;
	}

	set targetB(val){
		var object = val ? val.id : "";
		if(this._targetB == object){
			return;
		}
		this._targetB			= object;
		this._targetLayerB		= val ? val.layer : "";
		this._targetConnectionB	= val ? val.selectedConnector : "";
	}

	set targetA(val){
		var object = val ? val.id : "";
		if(this._targetA == object){
			return;
		}
		this._targetA			= object;
		this._targetLayerA		= val ? val.layer : "";
		this._targetConnectionA	= val ? val.selectedConnector : "";
	}

	setTarget(val){
		if(this.movingPoint === 0){
			this.targetA = val;
		}
		else if(this.movingPoint == this.points.length - 1){
			this.targetB = val;
		}
	}

	static determineClick(p1, p2, x, y, maxDist){
		if(x < Math.min(p1.x, p2.x) || x > Math.max(p1.x, p2.x) || y < Math.min(p1.y, p2.y) || y > Math.max(p1.y, p2.y)){
			return false;
		}

		var dist = p1.dist(p2),
			log = Math.ceil(Math.log2(dist)),
			min,
			max,
			center,
			i;
		if(p1.x < p2.x){
			min = p1.getClone();
			max = p2.getClone();
		}
		else{
			min = p2.getClone();
			max = p1.getClone();
		}
		center = min.getClone().add(max).br(1);
		for(i=0 ; i<log ; i++){
			if(x > center.x){
				min = center;
			}
			else{
				max = center;
			}
			center = min.add(max).br(1);

			if(Math.abs(y - center.y) < maxDist){
				return true;
			}
		}
		return false;
	}

	updateCreatingPosition(pos){
		this._points[this._points.length - 1].set(pos);
		Entity.findMinAndMax(this._points, this.position, this.size);
	}

	draw(ctx = context){
		var obj, size = this._points.length;

		if(this._targetA){
			obj = Project.scene.getObject(this._targetLayerA, this._targetA);
			if(obj){
				this._points[0].set(obj.getConnectorPosition(this._targetConnectionA));
			}
			else{
				this.targetA = obj;
			}
		}

		if(this._targetB){
			obj = Project.scene.getObject(this._targetLayerB, this._targetB);
			if(obj){
				this._points[size - 1].set(obj.getConnectorPosition(this._targetConnectionB));
			}
			else{
				this.targetB = obj;
			}
		}
		if(this._targetA || this._targetB){
			Entity.findMinAndMax(this._points, this.position, this.size);
		}

		if(isNumber(this._radius) && this._radius > 1){
			this._radius += "";
		}

		doLine({
			shadow: this.moving && !this.locked,
			lineCap: this._lineCap,
			joinType: this._joinType,
			lineStyle: this._lineStyle,
			points: this._points,
			borderWidth: this.borderWidth,
			borderColor: this.fillColor,
			radius: this.radius,
			lineDash: this._lineStyle == LINE_STYLE_STRIPPED ? [15, 5] : [],
			ctx: ctx
		});

		Arrow.drawArrow(ctx, this._points[1], this._points[0], this, this._arrowEndType);
		Arrow.drawArrow(ctx, this._points[size - 2], this._points[size - 1], this, this._arrowStartType);

		var point, offset;

		//text_B
		var first = this._points[0].getClone();
		var second = this._points[1].getClone();
		offset = CanvasHandler.calcTextWidth(ctx, this._text_B, "10pt Comic Sans MS");
		point = first.add(second.sub(first).normalize().mul((offset >> 1) + 10));
		doRect({
			position: point,
			fillColor: "white",
			width: offset,
			height: 10,
			center: true,
			ctx: ctx
		});
		ctx.fillStyle = "black";
		ctx.textAlign = FONT_HALIGN_CENTER;
		ctx.textBaseline = FONT_VALIGN_MIDDLE;
		ctx.fillText(this._text_B, point.x, point.y);

		if(isObject(this._startText) && this._startText !== null){
			var final = this._points[this._points.length - 1].getClone();
			var semiFinal = this._points[this._points.length - 2].getClone();
			var vector = semiFinal.sub(final).normalize();
			var angle = this._startText.angle;
			var newVector = new GVector2f(vector.x * Math.cos(angle) - vector.y * Math.sin(angle),
										  vector.x * Math.sin(angle) + vector.y * Math.cos(angle));
			var position = final.add(newVector.mul(this._startText.dist));
			doRect({
				position: position,
				fillColor: "white",
				width: this._startText.textWidth,
				height: this._startText.fontSize,
				center: true,
				ctx: ctx
			});
			ctx.fillStyle = "black";
			ctx.textAlign = FONT_HALIGN_CENTER;
			ctx.textBaseline = FONT_VALIGN_MIDDLE;
			ctx.fillText(this._startText.text, position.x, position.y);
		}
		/*
		if(isObject(this._startText)){
			var final = this._points[this._points.length - 1].getClone();
			var semiFinal = this._points[this._points.length - 2].getClone();
			var vector = semiFinal.sub(final).normalize();
			var angle = this._startText.angle;
			var newVector = new GVector2f(vector.x * Math.cos(angle) - vector.y * Math.sin(angle),
										  vector.x * Math.sin(angle) + vector.y * Math.cos(angle));
			var textWidth = CanvasHandler.calcTextWidth(ctx, this._startText.text, "10pt Comic Sans MS");
			var position = final.add(newVector.mul(this._startText.dist));
			doRect({
				position: position,
				fillColor: "white",
				width: textWidth,
				height: 10,
				center: true,
				ctx: ctx
			});
			ctx.fillStyle = "black";
			ctx.textAlign = FONT_HALIGN_CENTER;
			ctx.textBaseline = FONT_VALIGN_MIDDLE;
			ctx.fillText(this._startText.text, position.x, position.y);
		}
		*/

		/*
		//text_A
		var last = this._points[this._points.length - 1].getClone();
		var subLast = this._points[this._points.length - 2].getClone();
		offset = CanvasHandler.calcTextWidth(ctx, this._text_A, "10pt Comic Sans MS");
		point = last.add(subLast.sub(last).normalize().mul((offset >> 1) + 10));
		doRect({
			position: point,
			fillColor: "white",
			width: offset,
			height: 10,
			center: true,
			ctx: ctx
		});
		ctx.fillStyle = "black";
		ctx.textAlign = FONT_HALIGN_CENTER;
		ctx.textBaseline = FONT_VALIGN_MIDDLE;
		ctx.fillText(this._text_A, point.x, point.y);
		*/


		context.lineWidth = DEFAULT_BORDER_WIDTH << 1;
		if(this.selected){
			drawBorder(ctx, this, {});
			drawSelectArc(ctx, this._points[0].x, this._points[0].y);
			for(var i=1 ; i<size ; i++){
				drawSelectArc(ctx, this._points[i].x, this._points[i].y);
				drawSelectArc(ctx, (this._points[i].x + this._points[i - 1].x) >> 1, (this._points[i].y + this._points[i - 1].y) >> 1);
			}
		}
	}
}
class Arc extends Entity{
	constructor(position, size, fillColor){
		super(OBJECT_ARC, position, size, {fillColor: fillColor, minSize: new GVector2f(SELECTOR_SIZE)});
		this.moveType 	= -1;
	}

	updateCreatingPosition(pos){
		this.size.x = pos.x - this.position.x;
		this.size.y = pos.y - this.position.y;
	}

	_clickIn(x, y){
		var vec = new GVector2f(x, y);
		this.moveType = -1;

		this.checkConnectors(vec);
		if(this._selectedConnector){
			return true;
		}


		Entity.setMoveType(this, vec);
		return this.moveType >= 0;
	}

	_draw(ctx){
		doArc({
			position: this.position,
			size: this.size,
			fillColor: this.fillColor,
			borderColor: this.borderColor,
			fill: this._fill !== false,
			borderWidth: this.borderWidth,
			shadow: this.moving && !this.locked,
			ctx: ctx
		});

		Entity.drawConnectors(this, ctx);
		
		drawBorder(ctx, this);
	}
}
const MINIMAL_DIAGONAL = 10;

class Area{
	constructor(){
		this.clear();
		this._name = OBJECT_AREA;
		this._moving = false;
		this._min = new GVector2f();
		this._max = new GVector2f();
		this._offset = new GVector2f();
	}

	get name(){
		return this._name;
	}

	get moving(){
		return this._moving;
	}

	move(x, y){
		this._offset.add(x, y);
	}

	set moving(val){
		this._moving = val;
		if(!val){
			each(this._points, (e) => {
				e.x += this._offset.x;
				e.y += this._offset.y;
			});
			this._min.add(this._offset);
			this._max.add(this._offset);
			this._offset.set(0, 0);
		}
	}

	get isCreating(){
		return this._isCreating;
	}

	clear(){
		this._points = [];
		this._isCreating = false;
	}

	get isReady(){
		return this._min && this._max && this._min.dist(this._max) > MINIMAL_DIAGONAL;
	}

	removeSelected(onBorder, revert = false){
		var inst = this;
		var size = this._max.getClone().sub(this._min);
		
		//TODO spojiť vymazavanie objektov a malieb do jedneho ciklu
		
		Project.scene.forEach(function(e){//prejde všetky objekty
			var tl = inst._isPointIn(e.position.x, e.position.y),
				tr = inst._isPointIn(e.position.x + e.size.x, e.position.y),
				bl = inst._isPointIn(e.position.x, e.position.y + e.size.y),
				br = inst._isPointIn(e.position.x + e.size.x, e.position.y + e.size.y);

			if(onBorder){//ak sa maže aj z hranice tak stačí aby bol 1 roh vo vnutry
				if(tl || tr || bl || br){
					Scene.remove(e);
				}
			}
			else{
				if(tl && tr && bl && br){//ináč musia byť všetky
					Scene.remove(e);
				}
			}

		});

		each(Project.scene.layers, layer => {
			var paths = layer.paint.points;
			each(paths, path => {
				if(!path.points.length){
					return false;
				}
				var tl = inst._isPointIn(path.min.x, path.min.y),
					tr = inst._isPointIn(path.max.x, path.min.y),
					bl = inst._isPointIn(path.min.x, path.max.y),
					br = inst._isPointIn(path.max.x, path.max.y);

				if(!tl && !tr && !bl && !br){	//nieje šanca že je vo vnutry
					return false;
				}

				var result;
				if(onBorder){//ak maže z hranice tak sa hlada taky ktory je vo vnutry
					result = false;
					each(path.points, point => {
						if(result){
							return;
						}
						result = inst._isPointIn(point.x, point.y);
					});
				}
				else{//ak iba vo vnutry tak sa hlada taky ktory je mimo hranice
					result = true;
					each(path.points, point => {
						if(!result){
							return;
						}
						result = inst._isPointIn(point.x, point.y);
					});
				}
				path.forRemove = result;
			});
			layer.paint.removeSelectedPaths();
		});
	}

	_isPointIn(x, y){
		if(this._points < 2){
			return false;
		}
		var countLeft = 0; 
		var countRight = 0;
		var unRecognized = [];
		each(this._points, function(a, i, arr){
			var b = arr[(i + 1) % arr.length];
			//ak prechadza hor. čiarov kde je bod
			if((a.y >= y && b.y < y) || (a.y <= y && b.y > y)){
				if(b.x > x && a.x > x){
					countRight++;
				}
				else if(b.x < x && a.x < x){
					countLeft++;
				}
				else{//nenachada sa ani nalavo ani napravo
					unRecognized.push([a.x, a.y, b.x, b.y]);
				}
			}
		});

		if(unRecognized.length === 0 && (countRight % 2 === 0 || countLeft % 2 === 0 )){
			return false;
		}

		//TODO skontrolovať nerozpoznane čiary;

		return true;
	}

	hover(x, y){
		if(this._isCreating){
			return false;
		}

		var val = x > this._min.x && y > this._min.y && x < this._max.x && y < this._max.y;

		if(val){
			val = this._isPointIn(x, y);
		}
		setCursor(val ? CURSOR_POINTER : CURSOR_DEFAULT);
		return val !== false;
	}

	clickIn(x, y){
		return this._isPointIn(x, y);
	}

	addPoint(position){
		var last = this._points[this._points.length - 1];
		
		doLine({
			points: [last.x, last.y, position.x, position.y],
			borderWidth: 5,
			borderColor: "blue"
		});

		this._min.x = Math.min(this._min.x, position.x);
		this._min.y = Math.min(this._min.y, position.y);
		this._max.x = Math.max(this._max.x, position.x);
		this._max.y = Math.max(this._max.y, position.y);

		this._points.push(position);
	}

	startCreate(position){
		this.clear();
		this._points.push(position);
		this._isCreating = true;
		this._min.set(position);
		this._max.set(position);
	}

	endCreate(position){
		this._points.push(position);
		this._isCreating = false;

		this._min.x = Math.min(this._min.x, position.x);
		this._min.y = Math.min(this._min.y, position.y);
		this._max.x = Math.max(this._max.x, position.x);
		this._max.y = Math.max(this._max.y, position.y);
	}

	draw(ctx = context){
		if(this._isCreating || this._points.length <= 3){
			return;
		}
		doPolygon({
			points: this._points,
			offset: this._offset,
			borderWidth: 5,
			borderColor: "red"
		});

	}
}
/*
{

	vertices : [{
		x:
		y:
		fillColor:
		size:
		borderWidth:
		borderColor:
		label:
	}],
	edges : [{
		fillColor: 
		borderWidth:
		labelA:
		labelB:
		startA:
		startB:
		A:
		B:
	}]
}
*/
class Graph extends Entity{
	constructor(vertices = [], edges = []) {
		super(OBJECT_GRAPH, new GVector2f(), new GVector2f());
		this._vertices = vertices
		this._edges = edges
	}

	addVertex(vertex){
		if(!isObject(vertex) || isUndefined(vertex.x) || isUndefined(vertex.y))
			return false;

		vertex["fillColor"]		= vertex["fillColor"]	|| GRAPH_FILL_COLOR;
		vertex["borderColor"] 	= vertex["borderColor"]	|| GRAPH_BORDER_COLOR;
		vertex["size"]			= vertex["size"]		|| GRAPH_VERTEX_COLOR;
		vertex["borderWidth"]	= vertex["borderWidth"]	|| GRAPH_BORDER_WIDTH;
		vertex["label"]			= vertex["label"]		|| "";
		this._vertices.push(vertex);
	}
	addEdge(edge){
		if(!isObject(edge) || isUndefined(edge.A) ||isUndefined(edge.B))
			return false;
		edge["fillColor"]	= edge["fillColor"] 	|| GRAPH_BORDER_COLOR;
		edge["borderWidth"] = edge["borderWidth"] 	|| GRAPH_BORDER_WIDTH;
		edge["labelA"]		= edge["labelA"] 		|| "";
		edge["labelB"] 		= edge["labelB"] 		|| "";
		edge["startA"] 		= edge["startA"] 		|| LINE_NONE;
		edge["startB"] 		= edge["startB"] 		|| LINE_NONE;
		this._edges.push(edge);
	}

	draw(){
		//TODO nakresliť čiary
		each(this._edges, e => {
			if(typeof this._vertices[e.A] !== "undefined" && typeof this._vertices[e.B] !== "undefined"){
				doLine({
					points: [this._vertices[e.A].x, this._vertices[e.A].y, this._vertices[e.B].x, this._vertices[e.B].y],
					borderWidth: e.borderWidth,
					borderColor: e.fillColor,
				})
			}
		});

		each(this._vertices, e => doArc({
			x: e.x,
			y: e.y,
			fillColor: e.fillColor,
			size: e.size,
			borderColor: e.borderColor,
			borderWidth: e.borderWidth,
			center: true
		}))
	}
}

function initGraphs(){
	var g = new Graph();
	g.addVertex({x: 100, y: 100, size: 30, borderWidth: 5, borderColor: "blue", fillColor: "red"});
	g.addVertex({x: 500, y: 100, size: 40, borderWidth: 15, borderColor: "blue", fillColor: "red"});
	g.addVertex({x: 300, y: 300, size: 50, borderWidth: 25, borderColor: "blue", fillColor: "red"});

	g.addEdge({fillColor:"pink", borderWidth: 10, A: 0, B:1});
	g.addEdge({fillColor:"brown", borderWidth: 20, A: 1, B:2});
	g.addEdge({fillColor:"orange", borderWidth: 30, A: 0, B:2});
	Scene.addToScene(g);
}
class ImageObject extends Entity{
	constructor(position, size, image, data){
		super(OBJECT_IMAGE, position, size, data);
		this._radius = 20;

		this._image = image || null;

		//if(!image)
		//	loadImage(e => this._image = e);
	}

	set image(img){this._image = img;}

	updateCreatingPosition(pos){
		this.size.x = pos.x - this.position.x;
		this.size.y = pos.y - this.position.y;
	}

	clickIn(x, y){
		if (!this.clickInBoundingBox(x, y)){
			return false;
		}

		var vec = new GVector2f(x, y);
		this.moveType = -1;

		this.checkConnectors(vec);
		if(this._selectedConnector){
			return true;
		}

		Entity.setMoveType(this, vec);

		return this.moveType >= 0;
	}

	draw(ctx = context){
		//context.drawImage(this._image, this.position.x, this.position.y, this.size.x, this.size.y);
		doRect({
			bgImage: this._image || false,
			fill: this._image === null,
			position: this._position,
			size: this.size,
			radius: this.radius,
			draw: true,
			shadow: this.moving && !this.locked,
			borderWidth: this.borderWidth,
			borderColor: this.borderColor,
			ctx: ctx
		});

		drawBorder(ctx, this);
	}
}
class TextArea extends Entity{
	constructor(text, position, size, fontColor = DEFAULT_FONT_COLOR){
		super(OBJECT_TEXT, position, size, {fillColor: DEFAULT_BACKGROUND_COLOR, radius: DEFAULT_RADIUS});
		this._text 		= text || "";
		this._textColor = fontColor;
		this._fontSize 	= DEFAULT_FONT_SIZE;
		this._moveType 	= -1;
		this._verticalTextAlign = FONT_VALIGN_TOP;
		this._horizontalTextAlign = FONT_HALIGN_LEFT;
		this._fontOffset = DEFAULT_TEXT_OFFSET;
		this._selected = false;
		this._padding = 20;
		this._lineHeight = 30;

		this.addConnector(new GVector2f(0, 0), new GVector2f(1, 0),new GVector2f(0, 1),new GVector2f(1, 1))
	}

	_blur(){
		this._selected = false;
		SelectedText = null;
	}

	set text(val){
		console.log(val);
		this._text = val.split("\n");
	}

	clickIn(x, y){
		if(!this.clickInBoundingBox(x, y)){
			if(this._selected){
				this._blur();
			}
			return false;
		}

		this._selected = true;
		SelectedText = this;

		var pos = this.position,
			vec = new GVector2f(x, y);

		var area = document.getElementById("selectedEditor");
		
		if(area){
			document.body.removeChild(area);
		}

		area = document.createElement("div");
		area.setAttribute("id", "selectedEditor");
		area.setAttribute("contenteditable", "true");
		area.style.top = this._position.y + "px";
		area.style.left = this._position.x + "px";
		area.style.width = this._size.x + "px";
		area.style.height = this._size.y + "px";
		area.style.backgroundColor = this._fillColor;
		area.style.borderRadius = this._radius + "px";
		area.style.padding = this._padding + "px";
		area.style.color = this._textColor;
		area.style.zIndex = 100000;

		area.style.font = this._fontSize + "pt " + DEFAULT_FONT;

		document.body.insertBefore(area, document.getElementById("myCanvas"));

		this.checkConnectors(vec);
		if(this._selectedConnector){
			return true;
		}

		if(vec.dist(pos.x + (this.size.x >> 1), pos.y) < SELECTOR_SIZE){
			this._moveType = 0;
		}
		else if(vec.dist(pos.x + this.size.x, pos.y + (this.size.y >> 1)) < SELECTOR_SIZE){
			this._moveType = 1;
		}
		else if(vec.dist(pos.x +(this.size.x >> 1), pos.y + this.size.y) < SELECTOR_SIZE){
			this._moveType = 2;
		}
		else if(vec.dist(pos.x, pos.y + (this.size.y >> 1)) < SELECTOR_SIZE){
			this._moveType = 3;
		}
		else if(vec.dist(pos.x + this.size.x, pos.y + this.size.y) < SELECTOR_SIZE){
			this._moveType = 5;
		}
		else if(x > this.position.x && y > this.position.y && x < this.position.x + this.size.x && y < this.position.y + this.size.y){
			this._moveType = 4;
		}
		return this._moveType >= 0;
	}

	draw(){
		var pos = this.position.getClone();

		doRect({
			shadow: this.moving && !this.locked,
			position: this.position,
			size: this.size,
			radius: this.radius,
			fillColor: this.fillColor,
			borderWidth: this._borderWidth,
			draw: true,
			fill: true
		});

		context.textAlign = this._horizontalTextAlign;
		context.textBaseline = this._verticalTextAlign;
		context.fillStyle = this._textColor;
		context.font = this._fontSize + "pt " + DEFAULT_FONT;

		var offsetY = this._padding;
		each(this._text, e => {
			//console.log(offsetY + "kreslí sa: "+ this._fontSize);
			context.fillText(e, pos.x + this._padding, pos.y + offsetY);
			offsetY += this._lineHeight* 1.40	;//29 * 1.41;//this._fontSize * 1.333333 *2;
		})
	}
}
class Arrow{
	static drawArrow(ctx, pFrom, pTo, parent, type = 0, angle = Math.PI / 6, length = 30){
		if(type === 0){
			return;
		}

		var vec = pTo.getClone().sub(pFrom).normalize();
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);

		var p0 = new GVector2f(pTo.x, pTo.y);
		var p1 = new GVector2f(pTo.x - (vec.x * cos - vec.y * sin) * length,
							   pTo.y - (vec.x * sin + vec.y * cos) * length);
		var p2 = new GVector2f(pTo.x - (vec.x * cos + vec.y * sin) * length,
							   pTo.y + (vec.x * sin - vec.y * cos) * length);

		var p3 = new GVector2f(((pTo.x - ((vec.x * cos - vec.y * sin) * length << 1)) + (pTo.x - ((vec.x * cos + vec.y * sin) * length << 1))) >> 1,
							   ((pTo.y - ((vec.x * sin + vec.y * cos) * length << 1)) + (pTo.y + ((vec.x * sin - vec.y * cos) * length << 1))) >> 1);

		switch(type){
			case 2210:
				doLine({
					points: [[p1, p0],
					    	 [p2, p0]],
					borderColor: parent.borderColor,
					borderWidth: parent.borderWidth,
					ctx: ctx
				});
				break;
			case 2211:
				doPolygon({
					points: [p0, p1, p2],
					fill:true,
					draw: true,
					borderColor: parent.borderColor,
					fillColor: parent.fillColor,
					borderWidth: parent.borderWidth,
					ctx: ctx
				});
				break;
			case 2212:
				doPolygon({
					points: [p0, p1, p2],
					fill:true,
					draw: true,
					borderColor: parent.borderColor,
					fillColor: parent.borderColor,
					borderWidth: parent.borderWidth,
					ctx: ctx
				});
				break;
			case 2213:
				doPolygon({
					points: [p1, p0, p2, p3],
					fill: true,
					draw: true,
					borderColor: parent.borderColor,
					fillColor: parent.fillColor,
					borderWidth: parent.borderWidth,
					ctx: ctx
				});
				break;
			case 2214:
				doPolygon({
					points: [p1, p0, p2, p3],
					fill: true,
					draw: true,
					borderColor: parent.borderColor,
					fillColor: parent.borderColor,
					borderWidth: parent.borderWidth,
					ctx: ctx
				});
				break;
		}
	}
}
class Test{
	static allTests(){
		//var T = new Test();
		//T.testInput();
	}

	testContextMenu(){

	}

	testInput(){
		var input = new InputManager();

		if(input.isButtonDown(0) || input.isButtonDown("gabo") || input.isButtonDown(false) || input.isButtonDown(0)){
			Logger.error("button je dole aj ked by tam nemal byť");
		}

		if(input.isKeyDown(0) || input.isKeyDown("gabo") || input.isKeyDown(false) || input.isKeyDown(0)){
			Logger.error("key je dole aj ked by tam nemal byť");
		}


		input.keyDown(0);

		if(!input.isKeyDown(0)){
			Logger.error("key nieje dole ked by mal byť dole");
		}

		input.keyUp(0);

		if(input.isKeyDown(0)){
			Logger.error("key je dole aj ked by tam už nemal byť");
		}

		input.buttonDown({button: 0});

		if(!input.isButtonDown(0)){
			Logger.error("button nieje dole ked by mal byť dole");
		}

		input.buttonUp({button: 0});

		if(input.isButtonDown(0)){
			Logger.error("button je dole aj ked by tam už nemal byť");
		}
	}

	testTable(){

	}
}
/*
	compatible:	forEach 14.9.2016
*/

class SharerManager{
	constructor(){
		this._id = false;
		this._socket = false;
		this._sharing = false;
		this.paint = {
			addPoint: (point, layer) => this._paintOperation(ACTION_PAINT_ADD_POINT, point, layer),
			breakLine: (layer) => this._paintOperation(ACTION_PAINT_BREAK_LINE, layer),
			clean: (layer) => this._paintOperation(ACTION_PAINT_CLEAN, layer)
		};
		this._sender = new EventTimer(e => this._sendStack(), 1000 / 60);
		this._buffer = [];
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}

	get isSharing(){return this._sharing;}

	_sendStack(){
		if(!this._socket || this._socket.disconnected)
			return;
		this._socket.emit("sendBuffer", this._buffer);
		this._buffer = [];
	}
	startShare(options){
		this._socket = io();
		this._sharing = true;
		this._startTime = Date.now();
		this._sharePaints = options.sharePaints;
		this._shareCreator = options.shareCreator;
		this._shareObjects = options.shareObjects;
		this._maximalWatchers = options.maxWatchers;
		this._actualWatchers = [];
		var inst = this,
			data = {
				res: {
					x: window.innerWidth,
					y: window.innerHeight
				},
				pass: options.password,
				limit: options.maxWatchers,
				realTime: options.realTime,
				detailMovement: options.detailMovement,
				share: {
					menu: options.shareMenu,
					paints: this._sharePaints,
					creator: this._shareCreator,
					objects: this._shareObjects
				}
			};

		this._socket.on('chatMessage',function(data){
			Panel.recieveMessage(data["text"], data["sender"]);
		});


		this._sendMessage('startShare', data);

		this._socket.on('notification', function(data){
			Logger.write("prijatá správa: " + data["msg"]);
			console.log(data["msg"]);
		});

		this._socket.on('confirmShare', function(data){
			inst._id = data["id"];

			var a = document.createElement("a");
			a.setAttribute("target", "_blank");
			a.setAttribute("href", inst.watcherUrl);
			a.appendChild(document.createTextNode("adrese"));
			a.style.float="none";

			var span = document.createElement("span");
			span.appendChild(document.createTextNode("zdiela sa na "));
			span.appendChild(a);
			span.appendChild(document.createTextNode(" s ID " + data["id"]));

			Logger.write(span);
			Menu.disabled("sharing", "watch");
			Menu.disabled("sharing", "stopShare");
			Menu.disabled("sharing", "shareOptions");
			Menu.disabled("sharing", "copyUrl");
			Menu.disabled("sharing", "startShare");
			//chatViewer.show();
			Panel.startShare(sendMessage);
		});

		this._socket.on('getAllData', function(recData){
			console.log("prišla žiadosť o odoslanie všetkých dát");
			var data = {
				id: inst._id,
				msg: {
					scene: Scene.toObject(),
					creator: Creator.toObject(),
					paint: Paints.toObject()
				},
				target: recData.target
			};
			console.log("recData.nickName: " + recData.nickName);
			Panel.addWatcher(recData.nickName);
			inst._actualWatchers.push(recData.nickName);
			Logger.write("prijatá správa: Nový watcher " + recData.nickName + " sa úspešne pripojil");
			inst._sendMessage('sendAllData', data);
		});
	}

	get maxWatchers(){return this._maximalWatchers;}
	get duration(){return (Date.now() - this._startTime);}

	stopShare(){
		Menu.disabled("sharing", "watch");
		Menu.disabled("sharing", "stopShare");
		Menu.disabled("sharing", "shareOptions");
		Menu.disabled("sharing", "copyUrl");
		Menu.disabled("sharing", "startShare");

		this._id = false;
		this._socket.disconnect();
		this._socket = false;
		this._sharing = false;
		Panel.stopShare();
	}

	copyUrl(){
		var area = document.createElement("textarea");
		area.appendChild(document.createTextNode(this.watcherUrl));
		document.body.appendChild(area);
		area.select();
		try{
			document.execCommand('copy');
			Logger.write("Adresa zdielania bola úspečne skopírovaná do schránky");
		}catch(e){
			Logger.write("Nepodarilo sa skopírovať adresu zdielania");
		}
		document.body.removeChild(area);
	}

	changeCreator(key, val){
		var data = {
			id: this._id,
			msg: {
				key: key,
				val: val
			}
		};
		this._sendMessage('changeCreator', data);
	}

	get watcherUrl(){
		return location.origin + "/watcher?id=" + this._id;
	}

	_paintOperation(action, arg1, arg2){
		if(!this._sharePaints)
			return false;

		var data = {
			id: this._id,
			msg : {
				action: action
			}
		};
		switch(action){
			case ACTION_PAINT_ADD_POINT :
				data["msg"]["pX"] = arg1.x;
				data["msg"]["pY"] = arg1.y;
				data["msg"]["layer"] = arg2;
				break;
			case ACTION_PAINT_BREAK_LINE :
				data["msg"]["layer"] = arg1;
				break;

			case ACTION_PAINT_CLEAN :
				data["msg"]["layer"] = arg1;
				break;
			default:
				Logger.error("nastala chyba lebo sa chce vykonať neznáma paintAction: " + action);
				return;
		}
		this._sendMessage('paintAction', data);
	}

	sendMessage(text, sender){
		var data = {
			id: this._id,
			msg: {
				text: text,
				sender: sender
			}
		};
		this._sendMessage('chatMessage', data);
	}

	mouseChange(x, y, isLeftButtonD){
		if(!this._id)
			return false;
		var data = {
			id: this._id,
			msg: {
				posX: Input.mousePos.x,
				posY: Input.mousePos.y,
				buttonDown: Input.isButtonDown(LEFT_BUTTON)
			}
		};

		this._sendMessage('mouseData', data);
	}
	_sendMessage(title, data){
		this._sender.callIfCan();
		this._buffer.push([title, data]);
		this._socket.emit(title, data);
	}

	objectChange(o, action, keys){
		if(!this._socket)
			return;
		var data = {
			id: this._id,
			msg:{
				action: action
			}
		};
		switch(action ){
			case ACTION_OBJECT_MOVE:
				data["msg"]["oId"] = o.id;
				data["msg"]["oL"] = o.layer;
				data["msg"]["oX"] = o.position.x;
				data["msg"]["oY"] = o.position.y;
				data["msg"]["oW"] = o.size.x;
				data["msg"]["oH"] = o.size.y;
				break;
			case ACTION_OBJECT_CHANGE:
				data["msg"]["oId"] = o.id;
				data["msg"]["oL"] = o.layer;
				data["msg"]["keys"] = {};
				//keys.forEach((e, i) => data.msg.keys["i"] = o[i]);
				each(keys, (e, i) => data.msg.keys["i"] = o[i]);
				break;
			case ACTION_OBJECT_DELETE:
				data["msg"]["oId"] = o.id;
				data["msg"]["oL"] = o.layer;
				break;
			case ACTION_OBJECT_CREATE:
				data["msg"]["o"] = o;
				break;
			default:
				Logger.error("nastala chyba lebo sa chce vykonať neznáma akcia: " + action);
				return;
		}
		this._sendMessage('action', data);
	}

	write(msg){
		this._sendMessage('broadcastMsg', {id: this._id, msg: msg});
	}
}
/*
	compatible:	14.9.2016
*/
class TaskManager{
	constructor(results, title, layer){
		this._title 		= title;
		this._layer 		= layer;
		this._resultCount 	= 0;
		this._results 		= {};
		this._start 		= Date.now();

		each(results, (e, i) =>{
			this._results[i] = {
				correctValue: e,
				correct: false
			}
			this._resultCount++;
		})
		Logger.log(getMessage(MSG_OBJECT_CREATED, this.constructor.name), LOGGER_COMPONENT_CREATE);
	}
	onSuccess(){
		Logger.write("Všetko je vyriešené správne");
	}
	_getMissingResultsCount(){
		var missing = 0;
		each(this._results, (e) => {
			if(!e.correct)
				missing++;
		});

		return missing
	}

	checkResult(el){
		if(this._results[el.id] && this._results[el.id].correctValue === el.text){
			this._results[el.id].correct = true;
			this._results[el.id].time = Date.now();
			if(this._getMissingResultsCount() === 0)
				this.onSuccess();
			return true;
		}

		return false;
	}

	draw(){
		
	}
}
/**
 * Created by Gabriel on 29. 10. 2016.
 */


class FormManager{
	constructor(data){
		this._data = data;
		this._allowerAttributes = ["id", "style", "name", "value", "onclick", "onchange", "placeholder", "disabled", "visible"]
	}

	createForm(id){
		return this._generateForm(this._data[id]);
	}

	static _setAllCheckedAttributes(element, allowedAttributes, data){
		for(var i in allowedAttributes){
			if(allowedAttributes.hasOwnProperty(i) && data[allowedAttributes[i]]){
				element.setAttribute(allowedAttributes[i], data[allowedAttributes[i]]);
			}
		}
	}

	static createTable(titles, data){
		var row = G("tr", {}), tbl = new G("table", {
			attr: {border: "1"}, 
			style: {borderCollapse : "collapse",width: "100%"}
		});
		for(let title of titles){
			row.append(new G("td", {cont: title, style: {padding: "5px", fontWeight: "bold", textAlign: "center"}}));
		}
		tbl.append(row);
		for(var i in data){
			row = G("tr", {});
			for(var j in data[i]){
				row.append(new G("td", {
					style: {padding: "5px"},
					cont: j != 0 ? data[i][j] : getFormattedDate(data[i][j])
				}));
			}
			tbl.append(row);
		}
		return tbl;
	}

	_createInput(data, isChildren = false){
		if(data.visible === false)
			return null;
		var i, input, result = new G("div", {});

		if(isIn(data.type, "checkbox", "multiCheckbox") && !isChildren){
			result.attr("class", "panel");
		}

		if(data.label && data.id && !isChildren){
			result.append('<label for="' + data.id + '">' + data.label + ': </label>');
		}

		if(data.type === "multiCheckbox"){
			result.append(G.createElement("div", {cont: data.label}));
			var container = new G("div", {});

			for(i in data.items){
				if(data.items.hasOwnProperty(i)){
					container.append(this._createInput(data.items[i], true));
				}
			}

			result.append(container);
		}
		else if(data.type == "wrapper"){
			var wrapper = new G("div", {});
			FormManager._setAllCheckedAttributes(wrapper.first(), this._allowerAttributes, data);

			for(i in data.items){
				if(data.items.hasOwnProperty(i)){
					wrapper.append(this._createInput(data.items[i]));
				}
			}
			result.append(wrapper);
		}
		else if(data.type === "combobox"){
			input = new G("select", {});

			FormManager._setAllCheckedAttributes(input.first(), this._allowerAttributes, data);

			if(data.disabled === true){
				input.attr("disabled", data.disabled);
			}

			for(i in data.options){
				if(data.options.hasOwnProperty(i)){
					input.append(G.createElement("option", {value: data.options[i].value}, data.options[i].label));
				}
			}
			result.append(input);
		}
		else if(data.type === "plainText"){
			result.append(data.text);
		}
		else{
			input = new G("input", {attr: {type: data.type}});
			if(typeof data.checked === "boolean"){
				input.attr("checked", data.checked);
			}

			FormManager._setAllCheckedAttributes(input.first(), this._allowerAttributes, data);

			result.append(input);
		}
		if(isChildren){
			result.append('<label for="' + data.id + '">' + data.label + ': </label>');
		}

		return result.first();
	}

	_generateForm(form){
		var result = new G("form", {cont: "<h2>" + form.title + "</h2><br/>"});

		for(var i in form.elements){
			if(form.elements.hasOwnProperty(i)){
				var element = this._createInput(form.elements[i]);
				if(element){
					result.append(element);
				}
			}
		}

		return result.first();
	}
}